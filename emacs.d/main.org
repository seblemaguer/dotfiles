#+TITLE: Emacs configuration file
#+AUTHOR: Sébastien Le Maguer
#+EMAIL: lemagues@tcd.ie
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  fr
#+OPTIONS:   H:5 num:t toc:t prop:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://seblemaguer.github.io/css/default.css" />
#+PROPERTY: header-args :tangle "~/.emacs.d/init.el"

This is my emacs configuration file. It is under version control and available, among other
configurations, at this repository: https://github.com/seblemaguer/dotfiles

* Server
Before anything happens, we start the server to avoid conflict if there is a problem during the
loading phase.

#+begin_src emacs-lisp
  (server-start)
#+end_src

We also provide a helper to shutdown properly the server.

#+begin_src emacs-lisp
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+end_src

* Core [100%]
This section focuses on providing helpers and utilities required for the rest of the configuration.

** DONE Fundamentals [100%]
CLOSED: [2021-01-03 Sun 10:46]
This section define the fundamental variables and helpers which are recurrently used in the configuration.

*** DONE Define some important variables
CLOSED: [2021-01-03 Sun 10:39]
The section defines the variables =default-plugin-dir= and set the =custom-file=.
Some default values related to emacs' core behaviour, like the garbage collector, are also set here.

#+begin_src emacs-lisp
  ;; Define root directory and add the plugins
  (defvar default-plugin-dir (format "%s/plugins" user-emacs-directory)
    "The plugins directory")

  ;; Don't screw up my files with custom
  (setq custom-file (format "%s/custom.el" user-emacs-directory))
  (load custom-file 'noerror)

  ;; Silence!!!!!!
  (setq save-abbrevs 'silently
        ad-redefinition-action 'accept

        ;; Garbage collection (see https://github.com/jethrokuan/.emacs.d/blob/master/config.org)
        gc-cons-threshold 100000000
        large-file-warning-threshold 100000000)
#+end_src

*** DONE Identification helper
CLOSED: [2021-01-03 Sun 10:41]
In order to keep the authentification as private as possible, two primitives are defined here;
one to get the user (=my:auth-source-get-user=) and on to get the password (=my:auth-source-get-passwd=).

#+begin_src emacs-lisp
  (require 'cl-lib)
  (cl-defun my:auth-source-get-user (&rest spec &allow-other-keys)
    "Helper to get the user given the SPEC from authsource."
    (let ((founds (apply 'auth-source-search spec)))
      (when founds
	(plist-get (nth 0 founds) :user))))

  (cl-defun my:auth-source-get-passwd (&rest spec &allow-other-keys)
    "Helper to get the password given the SPEC from authsource."
    (let ((founds (apply 'auth-source-search spec)))
      (when founds
	(funcall (plist-get (nth 0 founds) :secret)))))
#+end_src

*** DONE Dealing with tangling this file
CLOSED: [2021-01-03 Sun 10:46]
:PROPERTIES:
:FROM:     https://www.reddit.com/r/emacs/comments/6t37yg/org_mode_dot_emacs/
:END:
This section defines two functions:
one to generate the emacs init file from =~/.emacs.d/main.org= and one to byte-compile the emacs init file.


#+begin_src emacs-lisp
  (defun tangle-main-org ()
    "Tangle ~/.emacs.d/main.org to ~/.emacs.d/init.el."
    (interactive)

    ;; Tangle to init.el
    (with-current-buffer (find-file (concat user-emacs-directory "main.org"))
      (org-babel-tangle))

    ;; byte-compile plugins
    (byte-recompile-directory (expand-file-name default-plugin-dir) 0))

  (defun compile-init ()
    "Byte compiles ~/.emacs.d/init.el."
    (interactive)
    (when (equal (buffer-name)
                 (concat "main.org"))
      ;; Recompile init file
      (byte-compile-disable-warning  'make-local) ;; NOTE: apparently people says this warning is simply wrong, so ignore it!
      (byte-recompile-file (format "%s/init.el" user-emacs-directory) t 0 nil)))
#+end_src

** DONE Package management [100%]
CLOSED: [2021-01-03 Sun 11:04]
My configuration relies on a lot (too-many?) of packages.
It relies primarly on =use-package= and some extensions.
The process of how to deal with the packages is the following:
  - by default, if possible, let's use =melpa=
  - if the package is not on melpa, let's use =straight=
  - if the package is on melpa but requires extra development, let's use =straight=

Furthermore, each package is tagged with several keywors to have a "machine-dependent" loading scheme.

*** DONE Emacs package configuration
CLOSED: [2021-01-03 Sun 10:51]
In this section, we are configuring the repositories and emacs internal package management. The only
specificity here is that the TLS algorithm is specific for 26.2.1.

#+begin_src emacs-lisp
  (require 'package)

  (when (and (= emacs-major-version 26)
             (= emacs-minor-version 2)
             (= emacs-build-number 1))
    (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"))

  (setq package-enable-at-startup nil
        package-check-signature nil
        package-archives '(("GNU ELPA"     . "https://elpa.gnu.org/packages/")
                           ("MELPA"        . "https://melpa.org/packages/")
                           ("ORGMODE"      . "http://orgmode.org/elpa/"))
        package-archive-priorities  '(("ORGMODE"      . 15)
                                      ("MELPA"        . 10)
                                      ("GNU ELPA"     . 5))
        package-check-signature nil)

  (package-initialize)
#+end_src

*** DONE Load use-package
CLOSED: [2021-01-03 Sun 10:51]
In this section, we are initializing =use-package= in the classic way.

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))
  (setq use-package-verbose t)
#+end_src

*** DONE Straight
CLOSED: [2021-01-03 Sun 10:52]
In this section, we are configuring =straight=.
=Straight= supports =use-package= by default.
Therefore, there is no extra-configuration for this to do.

 #+begin_src emacs-lisp
   (defvar bootstrap-version)
   (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 5))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))

   (unless (string= (getenv "TRAVIS") "true")
     (setq straight-vc-git-default-protocol 'ssh))
 #+end_src
 
*** DONE Tagging
CLOSED: [2021-01-03 Sun 10:58]
I am using keywords/tags to define a loading scheme for each of the machine where emacs is installed.
Each package, from now on, has one or multiple keywords associated using the key =:tags=.
Each computer has a series of tags which are required to be loaded.
The specification respects the following syntax:
  - list of strings which are
  - a tag prefixed by =!= explicitely reject packages whose have this tag associated with
  - ="ALL"= is a joker indicating =all the tags!= $\rightarrow$ no filtering


#+begin_src emacs-lisp
  (use-package use-package-tags
    :straight (use-package-tags :type git :host github :repo "seblemaguer/use-package-tags")
    :config
    (setq use-package-tags-enabled
          `(("lemagues-surface" . ("ALL" "!MUSIC"))
            ("sig201"           . ("ALL"))
            ("mackenzie"        . ("!MAIL" "!RSS" "!USER" "!GUI" "!MULTIMEDIA" "!CHAT" "!DESKTOP"))
            (,use-package-tags-default-host . ("CORE" "!USER" "!DESKTOP")))))
#+end_src

*** DONE Hydra
CLOSED: [2021-01-03 Sun 11:01]
I use hydra a lot so it is easier to add its support directly in the use-package configuration part.
The combination pretty-hydra/major-mode-hydra provides an easy and powerful way to declare hydra.
While alternatives exist, I find this combination more straightforward and cleaner when it is used in combination with =use-package=.

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :ensure t
    :tags '("CORE")
    :preface
    (defun with-alltheicon (icon str &optional height v-adjust)
      "Displays an icon from all-the-icon."
      (s-concat (all-the-icons-alltheicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-faicon (icon str &optional height v-adjust)
      "Displays an icon from Font Awesome icon."
      (s-concat (all-the-icons-faicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-fileicon (icon str &optional height v-adjust)
      "Displays an icon from the Atom File Icons package."
      (s-concat (all-the-icons-fileicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str))

    (defun with-octicon (icon str &optional height v-adjust)
      "Displays an icon from the GitHub Octicons."
      (s-concat (all-the-icons-octicon icon :v-adjust (or v-adjust 0) :height (or height 1)) " " str)))

  (use-package major-mode-hydra
    :ensure t
    :demand t
    :tags '("CORE")
    :bind
    ("M-SPC" . major-mode-hydra))
#+end_src

*** DONE Paradox to enhance package list management
CLOSED: [2021-01-03 Sun 11:04]
The default =list-packages= provides a nice experience.
Nonetheless, a key feature is missing: which are the new packages available after refresh.
=Paradox= is providing this information so I am using it for now even if I prefer the rendering of the default package listing.

#+begin_src emacs-lisp
  (use-package paradox
    :ensure t
    :tags '("CORE")
    :commands (paradox-upgrade-packages paradox-list-packages)
    :custom (paradox-automatically-star t)
    :config
    (setq paradox-execute-asynchronously t
          paradox-github-token (my:auth-source-get-passwd :host "api.github.com" :user "seblemaguer^paradox")))
#+end_src

** DONE Load private part
CLOSED: [2021-01-03 Sun 11:11]
Some parts can't be totally hidden using the =my:auth-source-get-*= helpers.
These sensitive configuration parts are store in a dedicated file (identified by the variable =privade-file=) which is loaded here.

#+begin_src emacs-lisp
  (defvar private-file "~/.emacs.d/private-variables.el"
    "Path to the file which stores my configuration.")

  (when (file-exists-p private-file)
    (load private-file))
#+end_src

** DONE Notifications [100%]
CLOSED: [2021-01-03 Sun 11:14]
Emacs is my entry point for almost everything.
Therefore, it is also useful to have the notifications handled directly in Emacs.
To do so, I rely on the couple sauron/alert.
Alert is the entry point for raising notifications while sauron is used to log the notifications.

This combination allows me to use the modeline as an indicator of the priority of the notification.
By doing so, I can be aware of a notification but choose to ignore it if I am focusing on something else.
If another notification of at most the same priority is raised, it will be logged but there won't be any visible cue.
However, if a notification of an higher priority is raised, the color of the modeline will be updated to reflect the priority of the notification.

*** DONE Sauron
CLOSED: [2021-01-03 Sun 11:13]
Sauron is the pivot of the notification system.
However, I need to use my own fork for two reasons:
the upstream has some priority issues with ERC; I would like to ignore some events emitted by the *org-agenda*.

#+begin_src emacs-lisp
  (use-package sauron
    :straight (sauron :type git :host github :repo "djcb/sauron"
                      :fork (:host github
                                   :repo "seblemaguer/sauron"
                                   :branch "functional"))
    :tags '("CORE" "NOTIFICATION")
    :commands (sauron-start-hidden)

    :config
    (defun sauron-keep-priority (msg props)
      "Function to define which event should keep the same priority
    and not be raised even if it is recent. The criterion is based on
    MSG and PROPS."
      (or
       (string= (plist-get props :sender) "root")
       (string= (plist-get props :event) "join")
       (string= (plist-get props :event) "quit")))

    (setq sauron-separate-frame nil ;; The notification is on the same window ?
          sauron-sticky-frame t
          sauron-max-line-length nil ;; No max. length for the line
          sauron-modules '(sauron-org) ;; reduced the default modules
          sauron-column-alist '(( timestamp  .  20)
                                ( origin     .  20)
                                ( priority   .   4)
                                ( message    . nil))
          sauron-org-exclude-todo-states (list "IN PROCESS" "EXEC_STARTED" "PAUSED" "DELEGATED" "WAITING")
          sauron-insensitivity-handler 'sauron-keep-priority)
  )
#+end_src

*** DONE Sauron/Alert/Modeline integration
CLOSED: [2021-01-03 Sun 11:14]
By using my plugin =sauron-mode-line=, I link Alert and Sauron.
By this way, all the Alert notifications are automatically transmitted to Sauron.
If a Sauron event is raised, it is transmitted to Alert to adapt the modeline bar.
This plugin is in charge to managing the communication and avoid any cycle.

#+begin_src emacs-lisp
  (use-package sauron-mode-line
    :tags '("CORE" "NOTIFICATION")
    :load-path default-plugin-dir
    :custom
    (sauron-event-added-functions 'sauron-mode-line-notifier-from-sauron)

    :commands (sauron-mode-line-start-hidden)
    :hook (after-init . sauron-mode-line-start-hidden)
    :bind
    (("<f7>"   . sauron-mode-line-toggle-hide-show)
     ("C-<f7>" . sauron-mode-line-clear)))
#+end_src

** DONE Documentation [100%]
CLOSED: [2021-01-03 Sun 11:19]
Emacs is dense and provides a lot of features.
Too many to remember everything.
This part is there to help to navigate the documentation more easily.

*** DONE Key bindinds
CLOSED: [2021-01-03 Sun 11:18]
=helm-descbinds= is a useful package which provides a way to list all the shortcuts available in the current buffer.

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :ensure t
    :tags '("CORE" "DOCUMENTATION")
    :commands (helm-descbinds)
    :bind
    ("C-h b" . helm-descbinds))
#+end_src

*** DONE Helpful
CLOSED: [2021-01-03 Sun 11:19]
=helpful= is a powerful package to access to the documentation of a key/symbol/...
It also supports references and back-references.
I am using it as the entry point of any documentation I want to access.

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :tags '("CORE" "DOCUMENTATION")
    :commands (helpful-key helpful-symbol helpful-at-point)
    :bind (("C-h k" . helpful-key)
           ("C-h a" . helpful-symbol)
           ("C-h h" . helpful-at-point)))
#+end_src

** DONE Buffer listing
CLOSED: [2021-01-03 Sun 11:24]
Buffer listing is the fundamental navigation tool.
After playing with =ibuffer= and other helpers, I settled using =bufler=.
This choice has been made due its the simplicity and its recursive nature.
=bufler= can be used in conjunction with =prism=.
While this latter package is to define some visual aspect, I only use it in conjunction with =bufler=.
Therefore, I decided to set it up here.

#+begin_src emacs-lisp
  ;; I need prism to use my configuration of bufler
  (use-package prism
    :ensure t
    :tags '("CORE" "BUFFER")
    :config
    (defun load-prism (frame)
      (with-selected-frame frame
        (remove-hook 'after-make-frame-functions 'load-prism)
        (prism-set-colors :num 16
          :desaturations (cl-loop for i from 0 below 16
                                  collect (* i 2.5))
          :lightens (cl-loop for i from 0 below 16
                             collect (* i 2.5))
          :colors (list "#C0392B" "#3498DB" "#16A085")

          :comments-fn
          (lambda (color)
            (prism-blend color
                         (face-attribute 'font-lock-comment-face :foreground) 0.25))

          :strings-fn
          (lambda (color)
            (prism-blend color "white" 0.5)))))

    (if (daemonp)
        (add-hook 'after-make-frame-functions 'load-prism)
      (load-prism (car (frame-list)))))

  (use-package bufler
    :ensure t
    :tags '("CORE" "BUFFER")
    :bind (("C-x C-b" . bufler)
           ("C-x b"   . bufler-switch-buffer))

    :custom
    (bufler-reverse nil)
    (bufler-face-prefix "prism-level-")
    (bufler-vc-state t)
    (bufler-list-group-separators '((0 . "\n")))
    (bufler-initial-face-depth 1)
    (bufler-groups (bufler-defgroups
                     (group (group-or "Help/Info"
                                      (mode-match "*Help*" (rx bos "help-"))
                                      (mode-match "*Info*" (rx bos "info-"))
                                      (mode-match "*Apropos*" (rx bos "apropos-"))))

                     (group (group-or "Mail"
                                      (mode-match "*Mu4e*" (rx bos "mu4e-"))))

                     (group (group-or "Chatty"
                                      (mode-match "ERC" (rx bos "erc-"))
                                      (name-match "*Slack*" (rx bos "*Slack"))
                                      (mode-match "Matrix" (rx bos "matrix-client-")))

                            (group (mode-match "ERC" (rx bos "erc-"))
                                   (group (name-match "Channels" (rx bos (or "#" "&"))))
                                   (group (name-match "Servers" ".*:[0-9]\\{4\\}"))
                                   ;; (auto-erc)
                                   )

                            (group (name-match "Slack" (rx bos "*Slack"))
                                   (group (group-not "Message" (name-match "Logging" "\\*Slack[^-]*Log -")))
                                   (group (name-match "Logging" "\\*Slack[^-]*Log -")))

                            (group (mode-match "Matrix" (rx bos "matrix-client-"))))

                     (group (mode-match "EMMS" (rx bos "emms-")))

                     (group (group-or "RSS"
                                      (mode-match "*Elfeed*" (rx bos "elfeed-"))
                                      (name-match "*Elfeed*" (rx bos "*elfeed"))
                                      (name-match "rss.org" (rx bos "rss.org"))))

                     (group (group-or "Todo"
                                      (name-match "Todo" (rx bos "todo.org"))))

                     ;; Subgroup collecting all special buffers (i.e. ones that are not
                     ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
                     ;; through to other groups, so they end up grouped with their project buffers).
                     (group (group-and "*Special*"
                                       (lambda (buffer)
                                         (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                                              buffer)
                                                     (funcall (mode-match "Dired" (rx bos "dired"))
                                                              buffer)
                                                     (funcall (auto-file) buffer))
                                           "*Special*")))

                            ;; Subgroup collecting these "special special" buffers separately for convenience.
                            (group (name-match "**Special**"
                                               (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))

                            ;; For my- calendars
                            (group (name-match "*Calendar*" "^[*]?[Cc]alendar.*$"))

                            ;; Package management
                            (group (name-match "*Packages*" (rx bos (or "*Paradox" "*Packages*"))))

                            ;; Processes in background
                            (group (name-match "*Prodigy*" (rx bos "*prodigy-")))

                            ;; Subgroup collecting all other Magit buffers, grouped by directory.
                            (group (mode-match "*Magit* (non-status)" (rx bos (or "magit" "forge") "-"))
                                   (auto-directory))

                            ;; Subgroup for Helm buffers.
                            (mode-match "*Helm*" (rx bos "helm-"))

                            ;; Remaining special buffers are grouped automatically by mode.
                            (auto-mode))


                     (group (group-and "*Projectile*"
                                       (lambda (buffer)
                                         (unless (funcall (lambda (buf)
                                                            (with-current-buffer buf
                                                              (string= (projectile-project-name) "-"))) buffer)
                                           "*Projectile*")))

                            ;; Subgroup collecting buffers in a projectile project.
                            (auto-projectile)
                            (auto-mode))

                     ;; Subgroup collecting buffers in a projectile project.
                     (group
                      (auto-tramp)
                      (auto-mode))

                     ;; Subgroup collecting buffers in a version-control project,
                     ;; grouping them by directory.
                     (auto-mode)
                     (auto-directory))))

#+end_src

** DONE Minibuffer
CLOSED: [2021-01-03 Sun 11:24]
Minibuffer configuration part. Nothing really outstanding, just the classical stuff.

#+begin_src emacs-lisp
  (use-package minibuffer
    :tags '("CORE" "MINIBUFFER")
    ;; :hook
    ;; (eval-expression-minibuffer-setup .  #'eldoc-mode)
    :config
    (setq read-file-name-completion-ignore-case t
          completion-ignore-case t
          resize-mini-windows t)

    (file-name-shadow-mode 1))
#+end_src

** DONE Large files
CLOSED: [2021-01-03 Sun 11:28]
Large files are difficult to handle properly in emacs.
The best way is to use =vlf=.
However, the entry point is actually =vlf-setup=.
This leads to ensuring the package =vlf= with the use-package header defined to be =vlf-setup=

#+begin_src emacs-lisp
  (use-package vlf-setup
    :ensure vlf
    :tags '("CORE")
    :init (setq vlf-application 'dont-ask))
#+end_src

* Session [100%]
As I am using emacs as a daemon/client combination,
my daily routine consists of opening emacs at the beginning of work and switching it off on the evening.
Therefore it is difficult to track what needs to be remembered.
This section provides helpers which automatises key part to make the transition between two sessions smoother.

** DONE Recent files
CLOSED: [2021-01-03 Sun 11:31]
Opening recent files is always an easy and fast shortcut. Some files should be ignored though. That
leads to this configuration

#+begin_src emacs-lisp
  (use-package recentf
    :tags '("CORE" "SESSION" "RECENT")
    :init
    (recentf-mode 1)

    :config
    (setq recentf-max-menu-items 100)     ;; Increase limit

    ;; Emacs
    (add-to-list 'recentf-exclude (format "%s/.orhc-bibtex-cache" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/configuration/emacs\\.d/\\(?!\\(main.*\\)\\)" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/\\.emacs\\.d/.*" (getenv "HOME")))

    ;; Some caches
    (add-to-list 'recentf-exclude (format "%s/\\.ido\\.last" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/\\.recentf" (getenv "HOME")))

    ;; elfeed
    (add-to-list 'recentf-exclude (format "%s/\\.elfeed/.*" (getenv "HOME")))
    (add-to-list 'recentf-exclude (format "%s/pCloudDrive/emacs/elfeed/.*" (getenv "HOME")))

    ;; Org-mode organisation
    (add-to-list 'recentf-exclude (format "%s/pCloudDrive/org/perso/emacs/.*" (getenv "HOME")))

    ;; Org/todo/calendars
    (add-to-list 'recentf-exclude ".*todo.org")
    (add-to-list 'recentf-exclude (format "%s/Calendars/.*" (getenv "HOME")))

    ;; Maildir
    (add-to-list 'recentf-exclude (format "%s/maildir.*" (getenv "HOME"))))
#+end_src

** DONE Backup files [100%]
CLOSED: [2021-01-03 Sun 11:33]
This section is dedicated to deal with backups. The main logic is to exlude some specific files
(either because of they are sensitive, either because they are just results of a process). For the
other ones, I want to have an easy way to navigate in it.

*** DONE Global backup configuration
CLOSED: [2021-01-03 Sun 11:33]
This the global backup configuration. For that I adapted a little bit the wonderful
snapshot-timemachine package.

#+begin_src emacs-lisp
  (use-package snapshot-timemachine
    :ensure t
    :tags '("CORE" "SESSION" "BACKUP")
    :init

    (defun my-make-backup-file-name (FILE)
      (let* ((dirname backup-directory)
             (backup-filename (concat dirname (file-truename FILE))))
        (unless (file-exists-p (file-name-directory  backup-filename))
          (make-directory (file-name-directory backup-filename) t))
        backup-filename))

    ;; Redefine find-backup-filename to avoid the "!" replacement
    (defun find-backup-file-name (fn)
      "Find a file name for a backup file FN, and suggestions for deletions.
    Value is a list whose car is the name for the backup file
    and whose cdr is a list of old versions to consider deleting now.
    If the value is nil, don't make a backup.
    Uses `backup-directory-alist' in the same way as
    `make-backup-file-name--default-function' does."
      (let ((handler (find-file-name-handler fn 'find-backup-file-name)))
        ;; Run a handler for this function so that ange-ftp can refuse to do it.
        (if handler
            (funcall handler 'find-backup-file-name fn)
          (if (or (eq version-control 'never)
                  ;; We don't support numbered backups on plain MS-DOS
                  ;; when long file names are unavailable.
                  (and (eq system-type 'ms-dos)
                       (not (msdos-long-file-names))))
              (list (make-backup-file-name fn))
            (let* ((basic-name (make-backup-file-name fn))
                   (base-versions (concat (file-name-nondirectory basic-name)
                                          ".~"))
                   (backup-extract-version-start (length base-versions))
                   (high-water-mark 0)
                   (number-to-delete 0)
                   possibilities deserve-versions-p versions)
              (condition-case ()
                  (setq possibilities (file-name-all-completions
                                       base-versions
                                       (file-name-directory basic-name))
                        versions (sort (mapcar #'backup-extract-version
                                               possibilities)
                                       #'<)
                        high-water-mark (apply 'max 0 versions)
                        deserve-versions-p (or version-control
                                               (> high-water-mark 0))
                        number-to-delete (- (length versions)
                                            kept-old-versions
                                            kept-new-versions
                                            -1))
                (file-error (setq possibilities nil)))
              (if (not deserve-versions-p)
                  (list (make-backup-file-name fn))
                (cons (format "%s.~%d~" basic-name (1+ high-water-mark))
                      (if (and (> number-to-delete 0)
                               ;; Delete nothing if there is overflow
                               ;; in the number of versions to keep.
                               (>= (+ kept-new-versions kept-old-versions -1) 0))
                          (mapcar (lambda (n)
                                    (format "%s.~%d~" basic-name n))
                                  (let ((v (nthcdr kept-old-versions versions)))
                                    (rplacd (nthcdr (1- number-to-delete) v) ())
                                    v))))))))))

    ;; Default Backup directory
    (defvar backup-directory "~/.emacs.d/backups/")
    (setq backup-directory-alist `((".*" . ,backup-directory)))
    (when (not (file-exists-p backup-directory))
      (make-directory backup-directory t))
    (setq make-backup-file-name-function #'my-make-backup-file-name)
    ;; Auto-save
    (defvar auto-save-directory "~/.emacs.d/auto-save/")
    (setq auto-save-file-name-transforms `((".*" ,auto-save-directory t)))
    (when (not (file-exists-p auto-save-directory))
      (make-directory auto-save-directory t))

    ;; Tramp backup
    (defvar tramp-backup-directory "~/.emacs.d/tramp-backups/")
    (setq tramp-backup-directory-alist `((".*" . ,tramp-backup-directory)))

    (when (not (file-exists-p tramp-backup-directory))
      (make-directory tramp-backup-directory t))

    (setq make-backup-files t               ; backup of a file the first time it is saved.
          backup-by-copying t               ; don't clobber symlinks
          version-control t                 ; version numbers for backup files
          delete-old-versions t             ; delete excess backup files silently
          delete-by-moving-to-trash t
          kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
          kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
          auto-save-default t               ; auto-save every buffer that visits a file
          auto-save-timeout 20              ; number of seconds idle time before auto-save (default: 30)
          auto-save-interval 200            ; number of keystrokes between auto-saves (default: 300)
          )

    :config

    (defun snapshot-timemachine-backup-finder (file)
      "Find snapshots of FILE in rsnapshot backups."
      (let* ((file (expand-file-name file))
             (file-dir (file-name-directory file))
             (file-base (file-name-nondirectory file))
             (backup-files (directory-files (concat backup-directory file-dir) t
                                            (format "%s.*" file-base))))
        (seq-map-indexed (lambda (backup-file index)
                           (make-snapshot :id index
                                          :name (format "%d" index)
                                          :file backup-file
                                          :date (nth 5 (file-attributes backup-file))))
                         backup-files)))

    (setq snapshot-timemachine-snapshot-finder #'snapshot-timemachine-backup-finder))
#+end_src

*** DONE Sensitive mode
CLOSED: [2021-01-03 Sun 11:33]
There are some files which are not desired to be backed up. This part goal is to setup this
"avoiding saving" spécificities.

#+begin_src emacs-lisp
  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    " Sensitive"
    ;; The minor mode bindings.
    nil
    (if (symbol-value sensitive-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t)
          ;; disable auto-save
          (if auto-save-default
              (auto-save-mode -1)))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (auto-save-mode 1))))


  (use-package auto-minor-mode
    :ensure t
    :tags '("CORE" "SESSION" "MINOR")
    :config
    (add-to-list 'auto-minor-mode-alist '("\\.git/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("emacs\\.d/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("emacs\\.d/emms/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("Calendars/.*.org\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("\\.gpg\\'" . sensitive-mode)))
#+end_src

** DONE Reload file at saved position
CLOSED: [2021-01-03 Sun 11:35]
:PROPERTIES:
:FROM:     https://github.com/munen/emacs.d
:END:
When a file is large, it is easier to restart from the exact position where we stopped.
To do so, I am using the package =saveplace=

#+begin_src emacs-lisp
  (use-package saveplace
    :ensure t
    :tags '("CORE" "SESSION")
    :init
    (setq save-place-file (format "%s/saveplace" user-emacs-directory))
    :config
    (save-place-mode 1))
#+end_src

** DONE Scratch
CLOSED: [2021-01-03 Sun 11:39]
I am using the scratch buffer as a notebook.
Therefore, as everything which is not saved elsewhere is saved there, I am using =scratch-ext= to deal with the saving/loading part.
The backups are stored on the cloud so it requires a connection and can't be used on a server.
Finally, instead of having the scratch buffer using the =emacs-lisp-mode= as the major mode, I am using =org-mode= which is less limited.

#+begin_src emacs-lisp
  (use-package scratch-ext
    :ensure t
    :tags '("CORE" "SESSION" "REQUIRES_CONNECTION")
    :hook (after-init . scratch-ext-restore-last-scratch)
    :config
    ;; Org-mode + start folded buffer
    (setq initial-major-mode 'org-mode)
    (set-buffer (get-buffer-create "*scratch*"))
    (set (make-local-variable 'org-startup-folded) t))
#+end_src

* Org-mode [100%]
=Org-mode= is the core of how I am organizing tasks, writing documents, ...
While it is mainly a programming/writing language, it involves too many subparts and, therefore, has its own section.

** DONE Global
CLOSED: [2021-01-03 Sun 12:42]
This section defines the global configuration for =org-mode=.
First, it actually relies on =org-plus-contrib=, especially for the bibtex support.
Then, it defines the fundamentals of the GTD pipeline by adding some TODO keywords:
  - =CANCELLED= and =POSTPONED= for task which can't be done for whatever reason;
  - =WAITING= for tasks which are blocked by an external event;
  - =PAUSED= for tasks which are manually put to sleep for whatever reason;
  - =EXEC_STARTED= for tasks which are running but doesn't requires any manual operation (i.e. process on the cluster)
  - =DELEGATED= for tasks which are delegated to someone else

Some additional keywords are also defined to deal with more specific events:
  - =RELEASE= points to an album to be released
  - =MAIL= points to an email to be replied to
  - =REVIEW= points to an article, ... to review

Finally, some keywords are there for note purposes:
  - =NOTE= points to a note to be saved
  - =EVENT= points to an event to happen
  - =MANDATORY= points to an event which I have to do but it is recurrent!

#+begin_src emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :tags '("ORG")
    :config

    ;; Global
    (setq org-startup-indented t
          org-startup-folded t
          org-enforce-todo-dependencies t
          org-cycle-separator-lines 2
          org-blank-before-new-entry '((heading) (plain-list-item . auto))
          org-insert-heading-respect-content nil
          org-reverse-note-order nil
          org-show-following-heading t
          org-show-hierarchy-above t
          org-show-siblings '((default))
          org-id-method 'uuidgen
          org-deadline-warning-days 30
          org-table-export-default-format "orgtbl-to-csv"
          org-src-window-setup 'other-window
          org-clone-delete-id t
          org-cycle-include-plain-lists t
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-hide-emphasis-markers t
          org-global-properties '(("Effort_ALL" . "0:15 0:30 0:45 1:00 2:00 3:00 4:00 5:00 6:00 0:00")
                                  ("STYLE_ALL" . "habit"))

          ;; Todo part
          org-todo-keywords '(;; Baseline sequence
                              (sequence "TODO(t)" "DELEGATED(e)" "EXEC_STARTED(S)" "IN PROCESS(s)"  "MEETING(M)" "WAITING(w)" "PAUSED(p)" "|" "DONE(d)" "CANCELLED(c@/!)" "POSTPONED(o@/!)")

                              ;; Specific "to complete"
                              (sequence "REVIEW(r)" "RELEASE(R)" "MAIL(m)" "|")

                              ;; Note information
                              (sequence "|" "NOTE(N)" "EVENT(E)" "MANDATORY(M)"))

          org-todo-state-tags-triggers '(("CANCELLED" ("CANCELLED" . t))
                                         ("POSTPONED" ("POSTPONED" . t)))

          ;; Priority definition
          org-highest-priority ?A
          org-lowest-priority ?E
          org-default-priority ?C

          ;; Archiving
          org-archive-mark-done t
          org-log-done 'time

          ;; Refiling
          org-refile-targets '((nil . (:maxlevel . 6))
                               (org-agenda-files . (:maxlevel . 6)))
          org-completion-use-ido nil
          org-refile-use-outline-path 'file
          org-outline-path-complete-in-steps nil
          org-refile-allow-creating-parent-nodes 'confirm)

    ;; Faces
    (setq org-todo-keyword-faces
          '(("TODO"          :background "red1"          :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("IN PROCESS"    :background "lightgray"     :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("MEETING"       :foreground "red1"                              :weight bold)

            ;; Specific helpers
            ("REVIEW"        :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("MAIL"          :background "purple"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; I can't really do anything here!
            ("WAITING"       :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("PAUSED"        :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("EXEC_STARTED"  :background "light green"   :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("DELEGATED"     :background "gold"          :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; Done but not complete
            ("CANCELLED"     :background "lime green"    :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("POSTPONED"     :background "lime green"    :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; Done and I don't care to be complete
            ("EVENT"         :foreground "purple"                            :weight bold)
            ("NOTE"          :foreground "purple"                            :weight bold)
            ("RELEASE"       :foreground "purple"                            :weight bold)
            ("MANDATORY"     :foreground "red"                               :weight bold)

            ;; Done and complete
            ("DONE"          :background "forest green"  :foreground "lightgray" :weight bold :box (:line-width 2 :style released-button))
            )

          org-priority-faces '((?A . (:foreground "red" :weight bold))
                               (?B . (:foreground "orange"  :weight bold))
                               (?C . (:foreground "orange"))
                               (?D . (:foreground "forest green"))
                               (?E . (:foreground "forest green"))))


    ;; Edition
    (setq org-list-allow-alphabetical t
          org-highlight-latex-and-related '(latex)
          org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"
          org-babel-results-keyword "results" ;; Display images directly in the buffer
          org-confirm-babel-evaluate nil
          org-startup-with-inline-images t))
#+end_src
** DONE Source [100%]
CLOSED: [2021-01-03 Sun 13:59]
The source visualisation of org files can be pretty raw.
This section provides configurations to help the navigation and the visualisation of such files.

*** DONE Pretty bullets
CLOSED: [2021-01-03 Sun 12:55]
The key problem in my opinion is how are visualize the headings.
=org-superstar= provides a clearer indentation and visualisation of such headings.
This is fundamental to have an easy navigation in such files which can be really large (see the current one!).

#+begin_src emacs-lisp
  (use-package org-superstar
    :ensure t
    :tags '("ORG" "VISUAL")
    :hook (org-mode . org-superstar-mode)
    :config
    (setq org-superstar-headline-bullets-list '("◉" "○" "▷" "✸")
          org-superstar-item-bullet-alist '((?+ . ?•) (?* . ?➤) (?- . ?–))))
#+end_src

*** DONE Babel [50%]
CLOSED: [2021-01-03 Sun 13:10]
Babel is the key feature for litterate programming in =org-mode=.
This section provides the configuration for babel by first configuring jupyter.
Jupyter is more powerful than the default python management which is why I chose to use it for python source blocks.

#+begin_src emacs-lisp
  (use-package jupyter
    :ensure t
    :tags '("ORG")
    :defer t
    :config
    (org-babel-jupyter-override-src-block "python"))

  (use-package ob
    :ensure org-plus-contrib
    :tags '("ORG")
    :config

    ;; Define specific modes for specific tools
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (add-to-list 'org-src-lang-modes '("dot"      . graphviz-dot))

    ;; Define the list of languages to load
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((emacs-lisp . t)
                                   (dot        . t)
                                   (ditaa      . t)
                                   (R          . t)
                                   (ruby       . t)
                                   (gnuplot    . t)
                                   (clojure    . t)
                                   (shell      . t)
                                   (ledger     . t)
                                   (org        . t)
                                   (plantuml   . t)
                                   (latex      . t)
                                   (python     . t)
                                   (jupyter    . t)))          ; must be last

    ;; Predefine header considering
    (setq org-babel-default-header-args:sh      '((:results . "output replace"))
          org-babel-default-header-args:bash    '((:results . "output replace"))
          org-babel-default-header-args:shell   '((:results . "output replace"))
          org-babel-default-header-args:jpython '((:async . "yes")
                                                  (:session . "py")))

    ;; Define pathes for some tools
    (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar"
          org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"))


#+end_src

*** DONE ID Generation
CLOSED: [2021-01-03 Sun 13:30]
I don't like how identifier are hashed in org-mode.
This package aims to provide an equivalent to the "auctex/reftex" label generation module but for org-mode.

#+begin_src emacs-lisp
  (use-package org-id+
    :straight (org-id+ :repo "seblemaguer/org-id-plus" :type git :host github)
    :commands (org-id+-add-ids-to-headlines-in-file)
    :tags '("ORG"))
#+end_src
*** DONE Checklist
CLOSED: [2021-01-03 Sun 13:55]
I am using checklist regularly.
Consequently, adding its support in org-mode is a big advantage.
To do so, I am relying the package =org-checklist= which is provided by =org-plus-contrib=.

#+BEGIN_SRC emacs-lisp
  (use-package org-checklist
    :ensure org-plus-contrib
    :tags '("ORG"))
#+END_SRC

** DONE Export [100%]
CLOSED: [2021-01-03 Sun 13:47]
This section focuses on configuring the export of org files to some document format.

*** DONE HTML
CLOSED: [2021-01-03 Sun 13:44]
In this section, we configure the export for HTML main files and for presentation using =reveal.js=.
Both configurations relies on =htmlize= to deal with the coloring part.
We also defines additional link to support audios and videos.

#+begin_src emacs-lisp
  (use-package htmlize
    :ensure t
    :tags '("ORG"))

  (use-package ox-html
    :ensure org-plus-contrib
    :after ox
    :requires (htmlize)
    :tags '("ORG")
    :init
    (defun endless/export-audio-link (path desc format)
      "Export org audio links to hmtl."
      (cl-case format
        (html (format "<audio src=\"%s\" controls>%s</audio>" path (or desc "")))))

    (defun endless/export-video-link (path desc format)
      "Export org video links to hmtl."
      (cl-case format
        (html (format "<video controls src=\"%s\">%s</video>" path (or desc "")))))

    :config
    (setq org-html-xml-declaration '(("html" . "")
                                     ("was-html" . "<?xml version=\"1.0\" encoding=\"%s\"?>")
                                     ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\"; ?>"))
          org-export-html-inline-images t
          org-export-with-sub-superscripts nil
          org-export-html-style-extra "<link rel=\"stylesheet\" href=\"org.css\" type=\"text/css\" />"
          org-export-html-style-include-default nil
          org-export-htmlize-output-type 'css ; Do not generate internal css formatting for HTML exports
          )

    (org-link-set-parameters "video" :ignore #'endless/export-video-link)
    (org-link-set-parameters "audio" :ignore #'endless/export-audio-link)

    (add-to-list 'org-file-apps '("\\.x?html?\\'" . "/usr/bin/firefox %s")))

  (use-package ox-reveal
    :ensure t
    :tags '("ORG")
    :requires (ox-html htmlize))
#+end_src

*** DONE Latex
CLOSED: [2021-01-03 Sun 13:46]
In this section, the export for latex and beamer are configured.
The key part is that we are using minted to deal with the source.
Therefore, we have to modify the call to the =latexmk= command (which is therefore required).

#+begin_src emacs-lisp
  (use-package ox-latex
    :ensure org-plus-contrib
    :tags '("ORG")
    :after ox
    :config
    (setq org-latex-listings t
          org-export-with-LaTeX-fragments t
          org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f")))

  (use-package ox-beamer
    :ensure org-plus-contrib
    :tags '("ORG")
    :after ox)

  (use-package ox-bibtex
    :ensure org-plus-contrib
    :tags '("ORG")
    :after ox
    :defer t)
#+end_src

*** DONE Markdown
CLOSED: [2021-01-03 Sun 13:47]
I am using mainly the Github markdown format.
Therefore, I use the package =ox-gfm=

#+begin_src emacs-lisp
  (use-package ox-gfm
      :ensure t
      :tags '("ORG")
      :after ox)
#+end_src

** DONE Agenda [100%]
CLOSED: [2021-01-03 Sun 14:22]
In this section, I configure the agenda part of org-mode.
It is my main source of visualizing the todo tasks.
I rely on the baseline =org-agenda= package and on =org-super-agenda= for a better visualisation.

*** DONE Baseline configuration
CLOSED: [2021-01-03 Sun 14:21]
The baseline configuration is fairly standard.
The only important bits are:
  - the todo file is set to =~/pCloudDrive/org/todo/todo.org=
  - some icons are associated to some categories

#+begin_src emacs-lisp
  (use-package org-agenda
    :ensure org-plus-contrib
    :tags '("ORG" "USER")
    :commands (org-agenda)
    :init
    (defun color-org-header (tag backcolor)
      "Highlight the line in org-agenda in the given BACKCOLOR if TAG is present on the line."
      (interactive)
      (goto-char (point-min))
      (while (re-search-forward tag nil t)
        (add-text-properties (line-beginning-position) (+ (line-end-position) 1)
                             `(face (:background, backcolor)))))

    ;; Agenda is used at startup, it is better
    (setq initial-buffer-choice '(lambda () (get-buffer org-agenda-buffer-name)))

    :mode-hydra
    (org-agenda-mode
     (:color blue)
     ("Time window" (("d" org-agenda-day-view "Day")
                     ("w" org-agenda-week-view "Week")
                     ("t" org-agenda-fortnight-view "Fortnight")
                     ("m" org-agenda-month-view "Month")
                     ("y" org-agenda-year-view "Year"))))

    :bind
    (([f12] . org-agenda)

     :map org-agenda-mode-map
     ("v"  . org-agenda-hydra/body))

    :config

    ;; Agenda files
    (when (file-exists-p "~/pCloudDrive/org/todo/todo.org")
      (add-to-list 'org-agenda-files "~/pCloudDrive/org/todo/todo.org"))

    ;; Deadline management
    (setq org-agenda-include-diary nil
          org-deadline-warning-days 7
          org-timeline-show-empty-dates t
          org-agenda-span 'day
          org-agenda-prefix-format '((agenda . " %i %-15:c%?-15t% s")
                                     (todo . " %i %-15:c")
                                     (tags . " %i %-15:c")
                                     (search . " %i %-15:c"))

          org-agenda-category-icon-alist `(
                                           ;; Tools / utils
                                           ("[Ee]macs"
                                            ,(format "%s/third_parties/icons/emacs24.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Oo]rg"
                                            ,(format "%s/third_parties/icons/org.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ss]ystem"
                                            ,(format "%s/third_parties/icons/debian.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Tt]ool\\|[Cc]onfiguration\\)s?"
                                            ,(format "%s/third_parties/icons/wrench.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ex]pe\\(riment\\)s?"
                                            ,(format "%s/third_parties/icons/expes.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Admin / meeting
                                           ("[Aa]dmin"
                                            ,(format "%s/third_parties/icons/admin.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Aa]ppointments?"
                                            ,(format "%s/third_parties/icons/appointment.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Vv]isitors"
                                            ,(format "%s/third_parties/icons/visitors.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Ss]ynsig\\|SSW\\)"
                                            ,(format "%s/third_parties/icons/isca.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Tt]rip\\|[Dd]eplacement\\)"
                                            ,(format "%s/third_parties/icons/trip.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Deadlines / dates
                                           ("\\([Pp]resentations?\\)"
                                            ,(format "%s/third_parties/icons/meeting.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Pp]apers?\\|[Bb]lio\\|[Aa]rticles?\\|[Rr]eading\\|[Ww]riting\\)"
                                            ,(format "%s/third_parties/icons/book.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Mm]ails?"
                                            ,(format "%s/third_parties/icons/email.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Rr]eviews?"
                                            ,(format "%s/third_parties/icons/review.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ss]upervising"
                                            ,(format "%s/third_parties/icons/visitors.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Personnal dates
                                           ("[rM]edical"
                                            ,(format "%s/third_parties/icons/medical.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Anniv"
                                            ,(format "%s/third_parties/icons/anniversary.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Concert"
                                            ,(format "%s/third_parties/icons/music.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Personnal diverse
                                           ("[Rr]elease"
                                            ,(format "%s/third_parties/icons/cd.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Book"
                                            ,(format "%s/third_parties/icons/book.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           (".*" '(space . (:width (16)))))))
#+end_src

*** DONE Super agenda
CLOSED: [2021-01-03 Sun 14:22]
In this section, I confugre =org-super-agenda=.
As I have my own way of being organized, I redefined completely the groups.

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :tags '("ORG")
    :config

    ;; Create groups
    (setq org-super-agenda-groups
          '(
            ;; CD part
            (:name "Interesting releases"
                   :and (:todo "RELEASE" :date t )
                   :order 8)

            (:name "Ordered Releases"
                   :and (:category "Release" :todo "WAITING")
                   :order 8)

            (:name "Releases"
                   :and (:category "Release" :not (:todo "WAITING"))
                   :order 9)

            (:name "Today"  ; Optionally specify section name
                   :time-grid t  ; Items that appear on the time grid
                   )

            ;; Important thing
            (:name "Important"
                   :and (:priority "A" :date t)
                   :order 2)

            ;; Some standby thingy
            (:name "In process"
                   :todo "PAUSED"
                   :order 7)

            ;; Deadlines
            (:name "Overdue"
                   :deadline past
                   :order 3)
            (:name "Due Today"
                   :deadline today
                   :order 3)
            (:name "Due Soon"
                   :deadline future
                   :order 4)

            ;; Schedule
            (:name "Scheduled, past but opened"
                   :and (:scheduled past :not (:todo "PAUSED") :not (:todo "WAITING") :not (:todo "RELEASE"))
                   :order 5)
            (:name "Scheduled in the next couple of days"
                   :and (:scheduled future :not (:todo "PAUSED") :not (:todo "WAITING") :not (:todo "RELEASE"))
                   :order 6)
            ))

    ;; Activate mode
    (org-super-agenda-mode t)
    (org-agenda nil "a"))
#+end_src

** DONE GTD [100%]
CLOSED: [2021-01-03 Sun 14:45]
Getting Things Done (GTD) is my main way of dealing with tasks.
My main source of inspiration is proposed in http://doc.norang.ca/org-mode.html but I deviate from it on multiple aspects.

*** DONE Clock management
CLOSED: [2021-01-03 Sun 14:42]
:PROPERTIES:
:FROM:     https://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/
:END:
Based on Sacha Chua blog post, I use the following configuration to clock-in/clock-out.
It deviates from Sacha's blog solely on the states; as I am using my own org states.

#+begin_src emacs-lisp
  (use-package org-mru-clock
    :ensure t
    :tags '("ORG")
    :bind* (("C-c C-x i"   . org-mru-clock-in)
            ("C-c C-x C-j" . org-mru-clock-select-recent-task))
    :init
    (setq org-mru-clock-how-many 100
          org-mru-clock-keep-formatting t
          org-clock-persist t)

    (defun sacha/org-clock-in-if-starting ()
      "Clock in when the task is marked IN PROCESS."
      (when (and (string= org-state "IN PROCESS")
                 (not (string= org-last-state org-state)))
        (org-clock-in)))

    (defadvice org-clock-in (after sacha activate)
      "Set this task's status to 'IN PROCESS'."
      (org-todo "IN PROCESS"))

    (defun sacha/org-clock-out-if-waiting-or-pausing ()
      "Clock in when the task is marked STARTED."
      (when (and (or (string= org-state "TODO")
                     (string= org-state "WAITING")
                     (string= org-state "PAUSED")
                     (string= org-state "EXEC_STARTED"))
                 (not (string= org-last-state org-state))
                 (org-clock-is-active))
        (org-clock-out)))

    :hook
    (org-after-todo-state-change . sacha/org-clock-out-if-waiting-or-pausing)
    (org-after-todo-state-change . sacha/org-clock-in-if-starting)

    :config
    (org-clock-persistence-insinuate))
#+end_src

**** Webpage overview
#+begin_src emacs-lisp
  (use-package org-analyzer
    :ensure t
    :custom (org-analyzer-org-directory  "~/pCloudDrive/org/todo")
    :commands (org-analyzer-start))
#+end_src

*** DONE Archiving
CLOSED: [2021-01-03 Sun 14:44]
:PROPERTIES:
:FROM:     https://github.com/daviderestivo/galactic-emacs/blob/master/lisp/org-archive-subtree.el
:END:
I prefer to keep the tree structure.
This is why I use this configuration.

#+begin_src emacs-lisp
  (use-package org-archive
    :ensure org-plus-contrib
    :tags '("ORG")
    :config
    (setq org-archive-default-command 'org-archive-subtree)

    (defadvice org-archive-subtree (around fix-hierarchy activate)
      (let* ((fix-archive-p (and (not current-prefix-arg)
                                 (not (use-region-p))))
             (afile  (car (org-archive--compute-location
                           (or (org-entry-get nil "ARCHIVE" 'inherit) org-archive-location))))
             (buffer (or (find-buffer-visiting afile) (find-file-noselect afile))))
        ad-do-it
        (when fix-archive-p
          (with-current-buffer buffer
            (goto-char (point-max))
            (while (org-up-heading-safe))
            (let* ((olpath (org-entry-get (point) "ARCHIVE_OLPATH"))
                   (path (and olpath (split-string olpath "/")))
                   (level 1)
                   tree-text)
              (when olpath
                (org-mark-subtree)
                (setq tree-text (buffer-substring (region-beginning) (region-end)))
                (let (this-command) (org-cut-subtree))
                (goto-char (point-min))
                (save-restriction
                  (widen)
                  (-each path
                    (lambda (heading)
                      (if (re-search-forward
                           (rx-to-string
                            `(: bol (repeat ,level "*") (1+ " ") ,heading)) nil t)
                          (org-narrow-to-subtree)
                        (goto-char (point-max))
                        (unless (looking-at "^")
                          (insert "\n"))
                        (insert (make-string level ?*)
                                " "
                                heading
                                "\n"))
                      (cl-incf level)))
                  (widen)
                  (org-end-of-subtree t t)
                  (org-paste-subtree level tree-text)))))))))
#+end_src

**** Cleaning helper
:PROPERTIES:
:FROM:     https://www.emacswiki.org/emacs/org-extension.el
:END:

#+begin_src emacs-lisp
  (defun org-archive-all-done-item ()
    "Archive all item that have with prefix DONE."
    (interactive)
    (save-excursion
      (outline-show-all)
      (goto-char (point-min))
      (if (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
          (progn
            (goto-char (point-min))
            (while (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
              (org-advertized-archive-subtree))
            (message "Archive finished"))
        (message "No need to archive"))))

  (defun org-clean-done-item ()
    "Delete all item that have with prefix DONE."
    (interactive)
    (save-excursion
      (outline-show-all)
      (goto-char (point-min))
      (if (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
          (progn
            (goto-char (point-min))
            (while (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
              (org-cut-subtree))
            (message "Cleaning DONE tasks finished"))
        (message "No need to clean"))))
#+end_src

*** DONE Monitoring
CLOSED: [2021-01-03 Sun 14:45]
I tend to have multiple project running in parallel.
To have an overview of what is going on, I am using =org-dashboard=.

#+begin_src emacs-lisp
  (use-package org-dashboard
    :ensure t
    :tags '("ORG")
    :commands (org-dashboard-display))
#+end_src

** DONE Roaming
CLOSED: [2021-01-03 Sun 15:20]
I am using =org-roam= to link all the informations I save and archive in org files.
To visualize everything, I am using =org-roam-server= which is spawning a webserver.
The visualization is more fancy and the graph is auto-organized which makes everything easier to read.

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :tags '("ORG")
    :hook
    (after-init . org-roam-mode)

    :custom
    (org-roam-directory "~/pCloudDrive/org")

    :bind (:map org-roam-mode-map
                (("C-c n l" . org-roam)
                 ("C-c n f" . org-roam-find-file))
           :map org-mode-map
                (("C-c n i" . org-roam-insert))
                (("C-c n I" . org-roam-insert-immediate))))

  (use-package org-roam-server
    :ensure t
    :tags '("ORG" "USER" "GUI"))
#+end_src

** DONE Accessing
CLOSED: [2021-01-03 Sun 15:24]
This section configures packages to access information from the org files.
=org-ql= is providing commands to query the org files in a SQL manner.
=org-protocol= is a package of =org-plus-contrib= which provides helper to use emacsclient to access to org files.
This package is mainly use to bookmark webpages from firefox.

#+begin_src emacs-lisp
  (use-package org-ql
    :ensure t
    :tags '("ORG")
    :commands (org-ql-search org-ql-view org-ql-view-recent-items))

  (use-package org-protocol
    :ensure org-plus-contrib
    :tags '("ORG"))
#+end_src

** DONE Capturing [100%]
CLOSED: [2021-01-04 Mon 08:33]
I use the capturing mechanism provded by org mode to add information for further investigations.
=doct= package is used to have a more human-friendly way a describing the templates.
I also use capturing mechanism to save recipes and some interesting websites.

#+begin_src emacs-lisp
  (use-package doct
    :ensure t
    :tags '("ORG" "CAPTURE" "DESKTOP")
    :commands (doct))

  (use-package org-capture
    :tags '("ORG" "CAPTURE" "DESKTOP")
    :after org
    :commands (org-capture)
    :config
    (setq org-capture-templates
          (doct
           `(("Book"
              :keys "p"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "To read"
              :template-file ,(format "%s/third_parties/org-capture-templates/book.org" user-emacs-directory))

             ("CD"
              :keys "c"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "CD"
              :template-file ,(format "%s/third_parties/org-capture-templates/cd.org" user-emacs-directory))

             ("Concert"
              :keys "C"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "Concert"
              :template-file ,(format "%s/third_parties/org-capture-templates/concert.org" user-emacs-directory))

             ("Reference"
              :keys "f"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "Reference task"
              :template-file ,(format "%s/third_parties/org-capture-templates/reference.org" user-emacs-directory))

             ("Bookmark"
              :keys "L"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :olp ("To review" "Bookmarks")
              :template-file ,(format "%s/third_parties/org-capture-templates/bookmark.org" user-emacs-directory))

             ("Mail"
              :keys "m"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "Mailing"
              :template-file ,(format "%s/third_parties/org-capture-templates/mail.org" user-emacs-directory))

             ("Meeting"
              :keys "M"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "To sort"
              :template-file ,(format "%s/third_parties/org-capture-templates/meeting.org" user-emacs-directory))

             ("RSS"
              :keys "r"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :olp ("To review" "RSS")
              :template-file ,(format "%s/third_parties/org-capture-templates/rss.org" user-emacs-directory))

             ("TODO"
              :keys "t"
              :type entry
              :file "~/pCloudDrive/org/todo/todo.org"
              :headline "To sort"
              :template-file ,(format "%s/third_parties/org-capture-templates/default.org" user-emacs-directory)
              :empty-lines-before 1)))))
#+end_src

*** DONE Cooking
CLOSED: [2021-01-04 Mon 08:33]
=org-ref= provides an easy way to save recipes.
It supports multiple website so its configuration consists only of providing the template.

#+begin_src emacs-lisp
    (use-package org-chef
      :ensure t
      :tags '("ORG" "CAPTURE" "DESKTOP" "CONNECTED")
      :after (org-capture)
      :config
      (add-to-list 'org-capture-templates
                   (doct '(
                           ("Cookbook"
                            :keys "o"
                            :type entry
                            :file "~/pCloudDrive/org/perso/cooking/cookbook.org"
                            :template ("* %^{Description}"
                                       "%(org-chef-get-recipe-from-url)")
                            :empty-lines 1)
                           ))))
#+end_src

*** DONE ORG/Web tools
CLOSED: [2021-01-04 Mon 08:33]
=org-web-tools= is a nice package which allows to sniff a webpage and convert it into org-mode
format. This is really useful to homogeneise documentation.

#+begin_src emacs-lisp
  (use-package org-web-tools
    :ensure t
    :after (org)
    :tags '("ORG" "CAPTURE" "DESKTOP" "CONNECTED"))
#+end_src

* Environment [100%]
In order to have a better editing environment, I configured several fundamental features: undoing, folding, completing and templating.

** DONE Undoing
CLOSED: [2021-01-04 Mon 08:57]
For undoing an operation, I am using =undo-tree=.
The only configuration here is to activate it globally.

#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :tags '("UNDOING")
    :init
    (global-undo-tree-mode))
#+end_src

** DONE Folding
CLOSED: [2021-01-04 Mon 09:00]
For the folding, I am relying by default on the builtin minor mode =outline=.
I prefer the org look-and-feel so I use =outshine= on top of outline.

#+begin_src emacs-lisp
  (use-package outshine
    :straight (outshine :type git :host github :repo "alphapapa/outshine")
    :tags '("FOLDING")
    :commands (outshine-cycle)
    :bind
    (:map outline-minor-mode-map
          ("<C-tab>"  . outshine-cycle)))
#+end_src

** DONE Completing [100%]
CLOSED: [2021-01-03 Sun 17:52]
Completion is one of the biggest time-saver feature a text editor can have.
I rely on three key completion systems for different purposes:
  - =company= is used for inline completion (mainly to access programming helpers and snippets)
  - =selectrum= is used as the standard mini-buffer based completion
  - =helm= is provided for some specific completion tools which are interesting but are not supported by =selectrum=

*** DONE Company
CLOSED: [2021-01-03 Sun 17:42]
In this section, only the global configuration of =company= is provided.
The configuration associated with each language is done separately and is, as much as possible, buffer local.
I also use =company-quickhelp= to provide the description of the current candidate.

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :tags '("COMPLETION")
    :init
    (setq company-backends '(company-capf company-files))

    :config
    ;; Global
    (setq company-idle-delay 1
          company-minimum-prefix-length 1
          company-show-numbers t
          company-tooltip-limit 20)

    ;; Activating globally
    (global-company-mode t))

  (use-package company-quickhelp
    :ensure t
    :after company
    :tags '("COMPLETION" "UI")
    :config
    (company-quickhelp-mode 1))
#+end_src

*** DONE Selectrum
CLOSED: [2021-01-03 Sun 17:42]
This section provides the configuration of =selectrum=.
Nothing fancy happens here, just its activation.

#+begin_src emacs-lisp
  (use-package selectrum
    :ensure t
    :tags '("COMPLETION")
    :config
    (selectrum-mode +1))

#+end_src
*** DONE Helm
CLOSED: [2021-01-03 Sun 17:43]
I use Helm for some specific cases which requires an important visibility space completion.
Once again, nothing fancy here, the configuration to have a better UX.

#+begin_src emacs-lisp
  (use-package helm
    :ensure t
    :tags '("COMPLETION")
    :functions helm-show-completion-default-display-function
    :config
    (setq helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
          helm-quick-update t ; do not display invisible candidates
          helm-idle-delay 0.01 ; be idle for this many seconds, before updating in delayed sources.
          helm-input-idle-delay 0.01 ; be idle for this many seconds, before updating candidate buffer
          helm-show-completion-display-function #'helm-show-completion-default-display-function
          helm-split-window-default-side 'below ;; open helm buffer in another window
          helm-split-window-inside-p t ;; open helm buffer inside current window, not occupy whole other window
          helm-candidate-number-limit 200 ; limit the number of displayed canidates
          helm-move-to-line-cycle-in-source nil ; move to end or beginning of source when reaching top or bottom of source.
          )
    )
#+end_src
*** DONE Extension [100%]
CLOSED: [2021-01-03 Sun 17:52]
While the previous completion system is enough to work on its own, it is possible to enhance the user experince by adding a couple of more tweaks.

**** DONE Prescient
CLOSED: [2021-01-03 Sun 17:44]
Prescient helps to sort candidates by last used first and then sorting by length.
It integrates well with selectrum and company but doesn't support helm (yet?!).

#+begin_src emacs-lisp
  (use-package prescient
    :ensure t
    :tags '("COMPLETION")
    :config
    (prescient-persist-mode +1))

  (use-package selectrum-prescient
    :ensure t
    :tags '("COMPLETION")
    :config (selectrum-prescient-mode +1))

  (use-package company-prescient
    :ensure t
    :tags '("COMPLETION")
    :config (company-prescient-mode +1))
#+end_src

**** DONE Marginalia
CLOSED: [2021-01-03 Sun 17:49]
Marginalia is completing =selectrum= by providing annotations to the candidates.
For now, I am using the default configuration.

#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    :bind (:map minibuffer-local-map
                ("C-M-a" . marginalia-cycle)
           ;; When using the Embark package, you can bind `marginalia-cycle' as an Embark action!
           ;;:map embark-general-map
           ;;     ("A" . marginalia-cycle)
          )

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Must be in the :init section of use-package such that the mode gets
    ;; enabled right away. Note that this forces loading the package.
    (marginalia-mode)

    ;; When using Selectrum, ensure that Selectrum is refreshed when cycling annotations.
    (advice-add #'marginalia-cycle :after
                (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))

    ;; Prefer richer, more heavy, annotations over the lighter default variant.
    ;; E.g. M-x will show the documentation string additional to the keybinding.
    ;; By default only the keybinding is shown as annotation.
    ;; Note that there is the command `marginalia-cycle' to
    ;; switch between the annotators.
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

**** DONE Consult
CLOSED: [2021-01-03 Sun 17:52]
Consult provides a set of commands which are particularly useful.
It is a nice extension to =selectrum= which brings to functionalities close to the ones proposed in =swiper= and =counsel=.

#+begin_src emacs-lisp
  (use-package consult
    :ensure t
    :bind (("C-x M-:"  . consult-complex-command)
           ("C-c h"    . consult-history)
           ("C-c m"    . consult-mode-command)
           ("C-x b"    . consult-buffer)
           ("C-x 4 b"  . consult-buffer-other-window)
           ("C-x 5 b"  . consult-buffer-other-frame)
           ("C-x r x"  . consult-register)
           ("C-x r b"  . consult-bookmark)
           ("C-x C-r"  . consult-recent-file)
           ("M-g g"    . consult-goto-line)
           ("M-g M-g"  . consult-goto-line)
           ("M-g o"    . consult-outline)     ;; "M-s o" is a good alternative.
           ("M-g l"    . consult-line)        ;; "M-s l" is a good alternative.
           ("M-g m"    . consult-mark)        ;; I recommend to bind Consult navigation
           ("M-g k"    . consult-global-mark) ;; commands under the "M-g" prefix.
           ("M-g i"    . consult-imenu)
           ("M-g e"    . consult-error)
           ("M-s m"    . consult-multi-occur)
           ("M-y"      . consult-yank-pop))

    ;; The :init configuration is always executed (Not lazy!)
    :init

    ;; Replace `multi-occur' with `consult-multi-occur', which is a drop-in replacement.
    (fset 'multi-occur #'consult-multi-occur)

    ;; Configure other variables and modes in the :config section, after lazily loading the package
    :config

    ;; Optionally configure narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")
    ;; Optionally make narrowing help available in the minibuffer.
    ;; Probably not needed if you are using which-key.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optional configure a view library to be used by `consult-buffer'.
    ;; The view library must provide two functions, one to open the view by name,
    ;; and one function which must return a list of views as strings.
    ;; Example: https://github.com/minad/bookmark-view/
    ;; (setq consult-view-open-function #'bookmark-jump
    ;;       consult-view-list-function #'bookmark-view-names)

    ;; Optionally enable previews. Note that individual previews can be disabled
    ;; via customization variables.
    (consult-preview-mode))

  ;; Enable Consult-Selectrum integration.
  ;; This package should be installed if Selectrum is used.
  (use-package consult-selectrum
    :ensure t
    :demand t)

  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :ensure t
    :bind (:map flycheck-command-map
                ("!" . consult-flycheck)))
#+end_src

** DONE Templating [100%]
CLOSED: [2021-01-03 Sun 17:58]
I use templates for two cases:
  - starting point as new script/code file
  - accessing to some snippets.
    
In both cases, I rely on =yasnippet=.

*** DONE Snippets
CLOSED: [2021-01-03 Sun 17:57]
The default configuration of yasnippet consists of activating it and plugging it with company.
Obviously, the package =yasnippet-snippets= is also configured to provide default snippets.
Finally, my own snippets are stored in the directory =~/.emacs.d/third_parties/snippets=.

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :tags '("COMPLETION")
    :init
    (yas-global-mode 1))

  ;; Load snippets
  (use-package yasnippet-snippets
    :ensure t
    :tags '("COMPLETION")
    :config

    ;; Add third parties snippets
    (defvar third-parties-snippet-dir (format "%s/third_parties/snippets" user-emacs-directory)
      "Directory containing my own snippets")

    (defun third-parties-snippets-initialize ()
      (add-to-list 'yas-snippet-dirs 'third-parties-snippet-dir t)
      (yas-load-directory third-parties-snippet-dir t))

    (eval-after-load 'yasnippet '(third-parties-snippets-initialize)))
#+end_src

*** DONE File templates
CLOSED: [2021-01-03 Sun 17:58]
This part is using yatemplate (an over-layer of yasnippet) coupled with auto-insert to have a set of
file type dedicated templates. The templates are available in =~/.emacs.d/third_parties/templates= directory.

#+begin_src emacs-lisp
  (use-package yatemplate
    :ensure t
    :tags '("COMPLETION")
    :after yasnippet
    :config

    ;; Define template directory
    (setq yatemplate-dir (concat user-emacs-directory "/third_parties/templates"))

    ;; Coupling with auto-insert
    (setq auto-insert-alist nil)
    (yatemplate-fill-alist)
    ;; (add-hook 'find-file-hook 'auto-insert)
    )
#+end_src
* IDE [100%]
While the environment configuration is fundamental for editing,
it is necessary to add more features to simplify coding life.
This section focuses on three components: the compilation, the commenting and the formatting.

** DONE Compilation [100%]
CLOSED: [2021-01-03 Sun 18:23]
I configured the configuration around two main parts:
refining the default compilation support and add fly-checking support.

*** DONE Baseline compilation
CLOSED: [2021-01-03 Sun 18:23]
I just modify a little bit the default compilation to be a little more "user friendly".
This implies two key features:
  - colorizing the compilation buffer for better reading
  - closing the compilation buffer if the compilation was a success.

A bug (described in http://stackoverflow.com/questions/15489319/how-can-i-skip-in-file-included-from-in-emacs-c-compilation-mode ) is also addressed.
    
#+begin_src emacs-lisp
  (use-package compile
    :defer
    :diminish compilation-in-progress
    :tags '("IDE" "COMPILATION")
    :hook
    (compilation-filter-hook . my-colorize-compilation-buffer)
  
    :init
    (setq compilation-scroll-output t)
  
    :config
    ;; Helper to colorize the compilation buffer
    (defun my-colorize-compilation-buffer ()
      "Colorize compile log."
      (read-only-mode 'toggle)
      (ansi-color-apply-on-region compilation-filter-start (point))
      (read-only-mode 'toggle))

    ;; Auto close if success
    (defun my-compile-autoclose (buffer string)
      "Auto close compile log if there are no errors"
      (when (and (not (string-match-p (buffer-name buffer) "*grep*"))
                 (string-match "finished" string))
        (delete-window (get-buffer-window buffer t))
        (bury-buffer-internal buffer)))
    (add-to-list 'compilation-finish-functions #'my-compile-autoclose)

    (setq compilation-always-kill t
          compilation-ask-about-save nil
          compilation-scroll-output 'first-error)

    ;; the next-error function weirdly stops at "In file included from...". Stop that:
    ;; http://stackoverflow.com/questions/15489319/how-can-i-skip-in-file-included-from-in-emacs-c-compilation-mode
    (setcar (nthcdr 5 (assoc 'gcc-include compilation-error-regexp-alist-alist)) 0))
#+end_src

*** DONE Flychecking
CLOSED: [2021-01-03 Sun 18:13]
For the fly checking, I use flycheck instead of flymake.
The key part of this configuration is the fact that checking the documentation is disabled.
I also use =flycheck-posframe= to have a quick idea of what is going on at the pointed error/warning/...

#+begin_src emacs-lisp
  ;; Disable checking doc
  (use-package flycheck
    :ensure t
    :tags '("CORE" "COMPILATION" "IDE")
    :commands (flycheck-error-list-set-filter flycheck-next-error flycheck-previous-error flycheck-first-error)
    :pretty-hydra
    ((:pre (progn (setq hydra-hint-display-type t) (flycheck-list-errors))
           :post (progn (setq hydra-hint-display-type nil) (quit-windows-on "*Flycheck errors*"))
           :color teal :hint nil)

     ("Errors"
      (("f"  flycheck-error-list-set-filter                            "Filter")
       ("j"  flycheck-next-error                                       "Next")
       ("k"  flycheck-previous-error                                   "Previous")
       ("gg" flycheck-first-error                                      "First")
       ("G"  (progn (goto-char (point-max)) (flycheck-previous-error)) "Last")
       ("<"  project-hydra/body "back"))))

    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  (use-package flycheck-posframe
    :ensure t
    :tags '("CORE" "UI")
    :after flycheck
    :hook (flycheck-mode . flycheck-posframe-mode)
    :config
    (setq flycheck-posframe-warning-prefix "\u26a0 "))
#+end_src

** DONE Commenting
CLOSED: [2021-01-03 Sun 18:33]
For the commenting, the common denominator is how to deal with FIXMEs.
To do so, I relie on two part: fic-mode for the highlighting and occur for the listing.
For language specific configurations, it is done in the language configuration part.

#+begin_src emacs-lisp
  (use-package fic-mode
    :ensure t
    :tags '("CORE" "IDE")
    :hook
    (prog-mode . fic-mode)

    :init
    (defun fic-view-listing ()
      "Use occur to list related FIXME keywords"
      (interactive)
      (occur "\\<\\(FIXME\\|WRITEME\\|WRITEME!\\|TODO\\|BUG\\|NOTE\\):?")))
#+end_src

** DONE Formatting
CLOSED: [2021-01-03 Sun 18:26]
In order to format the buffer, it is better to rely on external formatter/linter.
=format-all= proposes support of big bunch of them, so I am using it.

#+begin_src emacs-lisp
  (use-package format-all
    :ensure t
    :tags '("IDE" "FORMAT")
    :commands (format-all-buffer format-all-mode))
#+end_src

* Programming [100%]
Now that the environment is set, it is time to configure the different part to use emacs as a proper developping environment.
To do so, I rely mainly on Language Server Protocol (LSP).

** DONE LSP general configuration
CLOSED: [2021-01-03 Sun 21:28]
The general configuration of LSP is centered around two key parts: the UI and the keys.
I also override some default parameters to make the experience more appealing.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :tags '("IDE" "PROGRAMMING" "LSP")
    :mode-hydra
    (lsp-mode
     (:color red)
     ("Buffer"
      (("f"   lsp-format-buffer "Format")
       ("m"   lsp-ui-imenu "IMenu")
       ("x"   lsp-execute-code-action "Excute action"))

      "Server"
      (("M-s" lsp-describe-session "Describe")
       ("M-r" lsp-restart-workspace "Restart")
       ("S"   lsp-shutdown-workspace "Shutdown"))

      "Symbol"
      (("d"   lsp-find-declaration "Declaration")
       ("D"   lsp-ui-peek-find-definitions "Definition")
       ("R"   lsp-ui-peek-find-references "References")
       ("i"   lsp-ui-peek-find-implementation "Implementation")
       ("t"   lsp-find-type-definition "Type")
       ("s"   lsp-signature-help "Signature")
       ("o"   lsp-describe-thing-at-point "Documentation")
       ("r"   lsp-rename "Rename"))))

    :commands (lsp lsp-deferred)
    :bind
    (:map lsp-mode-map
          ("C-h M-h" . lsp-mode-hydra/body))

    :init
    (setq lsp-before-save-edits t
          lsp-inhibit-message t
          lsp-eldoc-render-all nil
          lsp-highlight-symbol-at-point nil
          lsp-prefer-flymake nil
          read-process-output-max (* 1024 1024)
          lsp-idle-delay 0.500))

  (use-package lsp-ui
    :ensure t
    :tags '("IDE")
    :after lsp-mode
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-doc-enable t
          lsp-ui-doc-use-webkit nil
          lsp-ui-doc-delay 1.0
          lsp-ui-sideline-delay 1.0
          lsp-ui-doc-include-signature t
          lsp-ui-doc-position 'at-point
          lsp-eldoc-enable-hover nil ; Disable eldoc displays in minibuffer
          lsp-ui-sideline-enable t
          lsp-ui-sideline-show-hover nil
          lsp-ui-sideline-show-diagnostics nil
          lsp-ui-sideline-ignore-duplicate t))
#+end_src

** DONE Data [100%]
CLOSED: [2021-01-03 Sun 21:49]
This section is dedicated to the configuration of modes to deal with data formats.

*** DONE CSV
CLOSED: [2021-01-03 Sun 21:32]
For CSV file, I rely on =csv-mode= but I add more separators.

 #+begin_src emacs-lisp
   (use-package csv-mode
     :ensure t
     :tags '("PROGRAMMING" " DATA")
     :config

     ;; Define separators
     (setq csv-separators '("," ";" ":" " ")))
 #+end_src

*** DONE CUE
CLOSED: [2021-01-03 Sun 21:35]
I use CUE files to guide audio CD I encode.
I developed a dedicated mode for this, so I am using it

#+begin_src emacs-lisp
  (use-package cue-mode
    :straight (cue-mode :repo "seblemaguer/cue-mode" :type git :host github)
    :tags '("PROGRAMMING" "DATA" "RELEASE")
    :mode ("\\.cue$"))
#+end_src

*** DONE JSON
CLOSED: [2021-01-03 Sun 21:47]
I am using JSON both for storing data and for configuration.
The configuration relies on =json-mode= for the main part and =json-reformat= for a better formatting.

#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION")
    :mode ("\\.json$"))

  (use-package json-reformat
    :ensure t
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION" "FORMATTING"))
#+end_src

*** DONE Praat
CLOSED: [2021-01-03 Sun 21:38]
I use praat, and more especially Textgrid, to annotate speech signals.
Praat-mode helps to have a proper visualization of Textgrids in Empacs.

#+begin_src emacs-lisp
  (use-package praat-mode
    :tags '("PROGRAMMING" "DATA")
    :mode ("\\.[tT][Gg]"))
#+end_src

*** DONE XML
CLOSED: [2021-01-03 Sun 21:49]
XML is, as JSON, used for data formatting and configuration.
However, I had to do extra-configurations to have outline support and a better formatting.

#+begin_src emacs-lisp
  (use-package nxml-mode
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION")
    :mode ("\\.xml$" . nxml-mode)
    :commands (pretty-print-xml-region)
    :init
    ;; Mapping xml to nxml
    (fset 'xml-mode 'nxml-mode)

    :hook
    (nxml-mode . (lambda ()
                   (outline-minor-mode)
                   (setq outline-regexp "^[ \t]*\<[a-zA-Z]+")))
    :config

    ;; Global configuration
    (setq nxml-child-indent 2
          nxml-auto-insert-xml-declaration-flag t
          nxml-slash-auto-complete-flag t
          nxml-bind-meta-tab-to-complete-flag t)

    ;; Helper to format
    (defun pretty-print-xml-region (begin end)
      "Pretty format XML markup in region. You need to have nxml-mode
  http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
  this.  The function inserts linebreaks to separate tags that have
  nothing but whitespace between them.  It then indents the markup
  by using nxml's indentation rules."
      (interactive "r")
      (save-excursion
        (nxml-mode)
        (goto-char begin)
        (while (search-forward-regexp "\>[ \\t]*\<" nil t)
          (backward-char) (insert "\n"))
        (indent-region begin end))))
#+end_src

** DONE Configuration [100%]
CLOSED: [2021-01-04 Mon 07:03]
*** DONE Default unix configuration
CLOSED: [2021-01-03 Sun 21:52]
=config-general-mode= is applied for all unix configuration files.
For now, I know/use only files with extension ~rc~ or ~conf~.

#+begin_src emacs-lisp
  (use-package config-general-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("\\.conf$" "\\.*rc$"))
#+end_src

*** DONE Authinfo
CLOSED: [2021-01-03 Sun 21:56]
The default =authinfo-mode= provided by emacs 27.1 is pretty nice but doesn't provide proper font-locking.
I started to develop =colored-authinfo-mode= to provide a better colorization for authinfo files.

#+begin_src emacs-lisp
  (use-package colored-authinfo-mode
    :straight (colored-authinfo-mode :repo "seblemaguer/colored-authinfo-mode" :type git :host github)
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("\\.authinfo\\(?:\\.gpg\\)\\'" . colored-authinfo-mode))
#+end_src

*** DONE Apache
CLOSED: [2021-01-04 Mon 06:41]
Nothing fancy here, we just add the support for =apache-mode= for several files which are known to be configuration for Apache.
Because the configuration of Apache requires root permissions, I assign the category SUDO to this package.
#+begin_src emacs-lisp
  (use-package apache-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "SUDO")
    :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'"
           "access\\.conf\\'" "sites-\\(available\\|enabled\\)/"))
#+end_src

*** DONE SSH configuration
CLOSED: [2021-01-04 Mon 06:48]
Nothing fancy here, we just add the support for =ssh-config-mode= for several files which are known to be configuration for SSH.

#+begin_src emacs-lisp
  (use-package ssh-config-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("/\\.ssh/config\\'" "/system/ssh\\'" "/sshd?_config\\'" "/known_hosts\\'" "/authorized_keys2?\\'")
    :hook (ssh-config-mode . turn-on-font-lock)

    :config
    (autoload 'ssh-config-mode "ssh-config-mode" t))
#+end_src

*** DONE YAML
CLOSED: [2021-01-04 Mon 06:53]
YAML is my main configuration format file as it supports references and more importantly comments.
I mainly rely on =yaml-mode= to which I add outline support for a better navigation.
I also use =yaml-tomato= to get the path at the current point which helps the access to a specific subpart of the configuration.

#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode (".yaml$")
    :hook
    (yaml-mode . yaml-mode-outline-hook)

    :init
    (defun yaml-outline-level ()
      "Return the outline level based on the indentation, hardcoded at 2 spaces."
      (s-count-matches "[ ]\\{2\\}" (match-string 0)))

    (defun yaml-mode-outline-hook ()
      (outline-minor-mode)
      (setq outline-regexp "^\\([ ]\\{2\\}\\)*\\([-] \\)?\\([\"][^\"]*[\"]\\|[a-zA-Z0-9_-]*\\): *\\([>|]\\|&[a-zA-Z0-9_-]*\\)?$")
      (setq outline-level 'yaml-outline-level)))

  (use-package yaml-tomato
    :ensure t
    :tags '("LANGUAGE")
    :commands (yaml-tomato-show-current-path yaml-tomato-copy))
#+end_src

*** DONE VIM
CLOSED: [2021-01-04 Mon 06:55]
I am using VIM as an alternative editor for quick editions, so I need to be able to modify its configuration.
To do so, I actually use Emacs and rely on =vimrc-mode=.

#+begin_src emacs-lisp
  (use-package vimrc-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("^\\.vimrc\\'" "/etc/vim/vimrc"))
#+end_src

*** DONE GIT
CLOSED: [2021-01-04 Mon 06:58]
I am using GIT as my main VC.
GIT relies on, at least, three types of configuration files: the general ~config~ , the ~gitignore~ and the ~attributes~ files.
I use a dedicated mode for each type.

#+begin_src emacs-lisp
  (use-package gitattributes-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))

  (use-package gitconfig-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "VC")
    :mode
    ("/\.gitconfig\'"    . gitconfig-mode)
    ("/vcs/gitconfig\'"    . gitconfig-mode))

  (use-package gitignore-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))
#+end_src

*** DONE Mercurial
CLOSED: [2021-01-04 Mon 06:59]
Aside GIT, I sometimes use mercurial. As for GIT, I use a dedicated mode for each type (~hgignore~ and ~hgrc~) of configuration file.

#+begin_src emacs-lisp
  (use-package hgignore-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))

  (use-package hgrc-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))
#+end_src

*** DONE Dockerfile
CLOSED: [2021-01-04 Mon 07:01]
I am a constant user of Docker. 
Consequently, I need a proper node to edit docker build files as I build my own images for my experiences.

#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "SYSTEM"))
#+end_src

*** DONE CRON
CLOSED: [2021-01-04 Mon 07:03]
CRON is a useful tool to plan some executions.
However the default editor is too raw for me.
While I would generally use VIM for such editions, I prefer to use emacs configured using =crontab-mode= to avoid mistakes.

#+begin_src emacs-lisp
  (use-package crontab-mode
    :ensure t
    :tags '("PROGRAMMING" "CONFIGURATION" "SYSTEM"))
#+end_src

** DONE Logging
CLOSED: [2021-01-04 Mon 07:07]
In all of my scripts/software, I rely more on loggers than print.
Therefore, visualizing logs is key and =log-view= is a really flexible mode for this.
While it is configured to open files whose basenames contain ~syslog~ or the extension is composed by ~.log~.
In both cases, backup numbers are as well supported.

#+begin_src emacs-lisp
  (use-package logview
    :ensure t
    :tags '("LANGUAGE")
    :commands logview-mode
    :mode
    ("\\.log\\(?:\\.[0-9]+\\)?\\'" . logview-mode)
    ("syslog\\(?:\\.[0-9]+\\)?\\'" . logview-mode))
#+end_src

** DONE Programming languages [100%]
CLOSED: [2021-01-04 Mon 07:42]
I am using emacs as IDE for multiple languages.
For my research, I am using mainly on python, shell, java and maths-based languages.
I, obviously, write some elisp code as well.
Consequently, this section configure all of these languages.

*** DONE Emacs Lisp
CLOSED: [2021-01-04 Mon 07:38]
The configuration of emacs, to edit (e)lisp files, consists mainly of adding a linter support (~package-lint~) and REPL environment (~elpl~).
I also added a hydra configuration to link properly everything.

#+begin_src emacs-lisp
  (use-package emacs-lisp-mode
    :mode-hydra
    ("Eval"
     (("b" eval-buffer "buffer")
      ("e" eval-defun "defun")
      ("r" eval-region "region"))

     "REPL"
     (("I" elpl "elpl"))

     "Formatting/linting"
     (("p" package-lint "package-lint"))

     "Test"
     (("t" ert "prompt")
      ("T" (ert t) "all")
      ("F" (ert :failed) "failed"))

     "Doc"
     (("d" describe-foo-at-point "thing-at-pt")
      ("f" describe-function "function")
      ("v" describe-variable "variable")
      ("i" info-lookup-symbol "info lookup"))))

  (use-package package-lint
    :ensure t
    :tags '("PROGRAMMING" "ELISP" "COMPILATION"))

  (use-package elpl
    :ensure t
    :tags '("PROGRAMMING" "ELISP" "REPL")
    :commands (elpl))
#+end_src

*** DONE Java based languages
CLOSED: [2021-01-04 Mon 07:19]
I use Java and two dialects based on Java: Groovy and Kotlin.
I strongly rely on LSP, so the configuration consists mainly on loading major mode and configuring the LSP servers.

#+begin_src emacs-lisp
  (use-package lsp-java
    :ensure t
    :tags '("PROGRAMMING" "JAVA" "LSP")
    :hook
    (java-mode . lsp)

    :config
    (setq lsp-java-save-action-organize-imports nil))

  (use-package java-snippets
    :ensure t
    :tags '("PROGRAMMING" "JAVA" "COMPLETION"))

  (use-package groovy-mode
    :ensure t
    :tags '("PROGRAMMING" "JAVA" "GROOVY")
    :mode ("\.groovy$" "\.gradle$")
    :interpreter ("gradle" "groovy")
    :hook
    (groovy-mode .  (lambda () (inf-groovy-keys)))
    (groovy-mode . lsp-deferred)

    :config
    (autoload 'run-groovy "inf-groovy" "Run an inferior Groovy process")
    (autoload 'inf-groovy-keys "inf-groovy" "Set local key defs for inf-groovy in groovy-mode")

    (setq lsp-groovy-server-file "~/environment/local/lib/groovy-language-server-all.jar"))

  ;; Subpackages
  (use-package groovy-imports
    :ensure t
    :tags '("PROGRAMMING" "JAVA" "GROOVY"))

  (use-package kotlin-mode
    :ensure t
    :tags '("PROGRAMMING" "JAVA" "KOTLIN")
    :mode "\\.kts?\\'"
    :hook
    (kotlin-mode . lsp-deferred)

    :config
    (setq kotlin-tab-width 4))
#+end_src

*** DONE Mathematics based languages
CLOSED: [2021-01-04 Mon 07:16]
I am using two main (exclusive?!) mathematic dedicated languages: Matlab and R.
For matlab, I rely on =matlab-mode= for which I tweaked the command to avoid matlab desktop loading.
For R, I rely on =ess= which provides excellent support with a reasonable default configuration.

#+begin_src emacs-lisp
  (use-package matlab-load
    :ensure matlab-mode
    :tags '("PROGRAMMING" "MATH" "MATLAB")
    :defines (matlab-shell-command-switches mlint-programs)
    :no-require t
    :mode ("\\.m$" . matlab-mode)
    :commands (matlab-shell)

    :config
    ;; (eval-after-load 'company
    ;;   '(add-to-list 'company-backends 'company-matlab))

    ;; (eval-after-load 'flycheck
    ;;   '(require 'flycheck-matlab-mlint)))

    ;; Command defines
    (setq matlab-shell-command-switches '("-nodesktop -nosplash")
          mlint-programs '("mlint" "glnxa64/mlint")))


  ;; ESS for R programming
  (use-package ess
    :ensure t
    :tags '("PROGRAMMING" "MATH" "R")
    :config
    (setq ess-default-style 'RRR+))
#+end_src

*** DONE Python
CLOSED: [2021-01-04 Mon 07:42]
Python is my main programming language, so the one I configured the most intensively.
I strongly rely on LSP and the Microsoft ~pyright~ server.
I prefer to use ~ipython~ as the interpreter as it is more powerful.
I also added support =ein= to have a REPL environment.
Finally, I use =sphinx-mode= to deal with the documentation.

#+begin_src emacs-lisp
  (use-package python
    :tags '("PROGRAMMING" "PYTHON")
    :mode
    ("\\.py\\'" . python-mode)
    ("\\.wsgi$" . python-mode)

    :init
    (setq-default indent-tabs-mode nil)

    :config
    (setq python-indent-offset 4
          python-shell-interpreter "ipython"
          python-shell-interpreter-args "--simple-prompt -i"))

  (use-package lsp-pyright
    :ensure t
    :commands (lsp lsp-deferred)
    :tags '("PROGRAMMING" "PYTHON" "LSP")
    :hook (python-mode . (lambda ()
                            (require 'lsp-pyright)
                            (lsp))))

  (use-package ein
    :ensure t
    :tags '("PROGRAMMING" "PYTHON" "REPL")
    :config
    (cond
     ((eq system-type 'darwin) (setq ein:console-args '("--gui=osx" "--matplotlib=osx" "--colors=Linux")))
     ((eq system-type 'gnu/linux) (setq ein:console-args '("--gui=gtk3" "--matplotlib=gtk3" "--colors=Linux"))))

    (setq ein:query-timeout 1000))

  (use-package sphinx-doc
    :ensure t
    :tags '("PROGRAMMING" "PYTHON" "DOCUMENTATION")
    :hook
    (python-mode . (lambda () (sphinx-doc-mode t))))
#+end_src

*** DONE Shell
CLOSED: [2021-01-04 Mon 07:25]
Editing bash/zsh files is relatively straightforward using Emacs' default configuration.
Nonetheless, a proper completion support is lacking and some helpers are always welcomed.
To do so, I use =company-shell= to add shell support using the =company= completion system.
I am using =modern-sh= to enhance the experience (modern syntax highlighting, REPL, ...).

#+begin_src emacs-lisp
  (use-package company-shell
    :ensure t
    :tags '("PROGRAMMING" "SHELL" "COMPLETION")
    :hook
    (shell-mode . company-shell-hook)

    :init
    (defun company-shell-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends (append '(company-shell company-shell-env company-fish-shell) company-backends))))

  (use-package modern-sh
    :ensure t
    :disabled t
    :tags '("PROGRAMMING" "SHELL")
    :hook (sh-mode . embed-modern-sh-mode-toggle)
    :bind
    (:map modern-sh-mode-map
          ("C-<f6>"  . modern-sh-menu))
    :init
    (defun embed-modern-sh-mode-toggle ()
      (when (buffer-file-name)
        (modern-sh-mode))))
#+end_src

* Writing / Reading [100%]
I decided to dissociate programming and writing for more clarity.
Nonetheless, both sections rely on the same principles.
Concerning the writing part, I use mainly org-mode and LaTeX (article and shared documents).
I also use markdown for README and collaborative projects.
Finally, concerning the reading part, I consider only PDF Files.
I use libreoffice/office 365 for official documents which can't be handled in PDF.

** DONE LaTeX [100%]
CLOSED: [2021-01-04 Mon 12:05]
LaTeX is the core languages I am using to write scientific documents and presentations.
My configuration relies mainly on auctex but I had to tweak several part to match my way of dealing with such files.
These tweaks concerns mainly of using =outline= to deal with folding, 
using the ~enquote~ command to do some quotation in latex and prepare a proper pdf compilation/synchronization.

#+begin_src emacs-lisp
  (use-package tex-site
    :ensure auctex
    :tags '("WRITING" "LATEX")
    :after (tex latex)
    :hook
    (LaTeX-mode . turn-off-auto-fill)
    (LaTeX-mode . (lambda () (TeX-fold-mode t)))
    (LaTeX-mode . LaTeX-math-mode)
    (LaTeX-mode . outline-minor-mode)
    (LaTeX-mode . TeX-source-correlate-mode)

    :config
    ;; PDF activated by default
    (TeX-global-PDF-mode 1)

    ;; Diverse
    (setq-default TeX-master nil)
    (setq TeX-parse-self t
          TeX-auto-save t)

    ;; Minor helpers for comment and quotes
    (add-to-list 'LaTeX-verbatim-environments "comment")
    (setq TeX-open-quote "\\enquote{"
          TeX-close-quote "}")

    ;; Indentation
    (setq LaTeX-indent-level 4
          LaTeX-item-indent 0
          TeX-brace-indent-level 4
          TeX-newline-function 'newline-and-indent)

    ;; PDF/Tex correlation
    (setq TeX-source-correlate-method 'synctex)

    ;; Keys
    (define-key LaTeX-mode-map (kbd "C-c C-=") 'align-current))
#+end_src

*** DONE Reftex
CLOSED: [2021-01-04 Mon 11:55]
I am using =reftex= to deal with references.
The configuration consists mainly of pluging it into auctex and expand the citation keywords and commands.

#+begin_src emacs-lisp
  (use-package reftex
    :tags '("WRITING" "LATEX")
    :hook
    (LaTeX-mode . turn-on-reftex)

    :config
    (setq reftex-save-parse-info t
          reftex-enable-partial-scans t
          reftex-use-multiple-selection-buffers t
          reftex-plug-into-AUCTeX t
          reftex-vref-is-default t
          reftex-cite-format
          '((?c    . "\\cite[]{%l}")
            (?t    . "\\textcite{%l}")
            (?a    . "\\autocite[]{%l}")
            (?p    . "\\parencite{%l}")
            (?f    . "\\footcite[][]{%l}")
            (?F    . "\\fullcite[]{%l}")
            (?x    . "[]{%l}")
            (?X    . "{%l}"))

          font-latex-match-reference-keywords
          '(("cite"             "[{")
            ("cites"            "[{}]")
            ("footcite"         "[{")
            ("footcites"        "[{")
            ("parencite"        "[{")
            ("textcite"         "[{")
            ("fullcite"         "[{")
            ("citetitle"        "[{")
            ("citetitles"       "[{")
            ("headlessfullcite" "[{"))

          reftex-cite-prompt-optional-args nil
          reftex-cite-cleanup-optional-args t))
#+end_src

*** DONE Completion
CLOSED: [2021-01-04 Mon 12:00]
For the completion, I need to prepare some proper hook for =company=.
I use two packages =company-auctex= which provides the enhancement of auctex and =company-reftex= which provides a proper completion support for references.

#+begin_src emacs-lisp
  (setq TeX-auto-global (format "%s/auctex/style" user-emacs-directory))

  (use-package company-auctex
    :ensure t
    :tags '("WRITING" "LATEX" "COMPLETION")
    :hook
    (LaTeX-mode . company-auctex-hook)

    :init
    (defun company-auctex-hook ()
      (make-local-variable 'company-backends)
      (company-auctex-init)))

  (use-package company-reftex
    :ensure t
    :tags '("WRITING" "LATEX" "ORG" "COMPLETION")
    :hook
    (LaTeX-mode . company-reftex-hook)
    (org-mode   . company-reftex-hook)

    :init
    (defun company-reftex-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends (append '(company-reftex-labels company-reftex-citations) company-backends))))
#+end_src

*** DONE Compilation
CLOSED: [2021-01-04 Mon 12:03]
For the compilation, I prefer to use =latexmk=. 
It processes everything automatically which removes the burden of having to define the sequence of commands.
I could have used the auctex default sequence, but I prefer to have an homogeneous process with what I do in the shell!

#+begin_src emacs-lisp
  (use-package auctex-latexmk
    :ensure t
    :tags '("WRITING" "LATEX" "COMPILATION")
    :config
  
    ;; Redine TeX-output-mode to get the color !
    (define-derived-mode TeX-output-mode TeX-special-mode "LaTeX Output"
      "Major mode for viewing TeX output.
    \\{TeX-output-mode-map} "
      :syntax-table nil
      (set (make-local-variable 'revert-buffer-function)
           #'TeX-output-revert-buffer)

      (set (make-local-variable 'font-lock-defaults)
           '((("^!.*" . font-lock-warning-face) ; LaTeX error
              ("^-+$" . font-lock-builtin-face) ; latexmk divider
              ("^\\(?:Overfull\\|Underfull\\|Tight\\|Loose\\).*" . font-lock-builtin-face)
              ;; .....
              )))

      ;; special-mode makes it read-only which prevents input from TeX.
      (setq buffer-read-only nil))


    ;; Setup everything
    (setq auctex-latexmk-inherit-TeX-PDF-mode t
          TeX-show-compilation nil)  
    (auctex-latexmk-setup))
#+end_src

*** DONE Preview
CLOSED: [2021-01-04 Mon 12:05]
Complicated equations can be difficult to parse properly at first sight.
I use =xenops= to generate a preview of the equations.
=xenops= is also compatible with org-mode but I use it more with latex.
Nonetheless, I activate it for both major modes.

#+begin_src emacs-lisp
  (use-package xenops
    :ensure t
    :tags '("WRITING" "LATEX" "ORG" "DESKTOP")
    :commands (xenops-mode xenops-doctor)
    :hook
    (latex-mode . xenops-mode)
    (org-mode   . xenops-mode))
#+end_src

** DONE Bibtex
CLOSED: [2021-01-04 Mon 12:15]
To store bibliography entries, BibTex is the way to go.
The global configuration consists mainly on providing a way to generate proper keys.
Finally, I use bibclean-format to have a clean final bibtex file.

#+begin_src emacs-lisp
  (use-package bibtex
    :tags '("WRITING" "BIBTEX")
    :config
    (defun bibtex-generate-autokey ()
      (let* ((bibtex-autokey-names nil)
             (bibtex-autokey-year-length 4)
             (bibtex-autokey-name-separator "\0")
             (names (split-string (bibtex-autokey-get-names) "\0"))
             (year (bibtex-autokey-get-year))
             (name-char (cond ((= (length names) 1) 4)
                              ((= (length names) 2) 2)
                              (t 1)))
             (existing-keys (bibtex-parse-keys))
             key)
        (setq names (s-upper-camel-case (car names)))
        (setq key (format "%s:%s" year names))

        (let ((ret key))
          (loop for c from ?a to ?z
                while (assoc ret existing-keys)
                do (setq ret (format "%s:%c" key c)))
          ret)))

    (setq bibtex-align-at-equal-sign t
          bibtex-autokey-name-year-separator ""
          bibtex-autokey-year-title-separator ""
          bibtex-autokey-titleword-first-ignore '("the" "a" "if" "and" "an")
          bibtex-autokey-titleword-length 100
          bibtex-autokey-titlewords 1))

  (use-package bibclean-format
    :ensure t
    :tags '("WRITING" "BIBTEX")
    :hook
    (bibtex-mode . bibclean-format-on-save-mode)

    :commands (bibclean-format)
    :bind
    (:map bibtex-mode-map
          ("C-c f" . bibclean-format))
    :config
    (setq bibclean-format-args '("--max-width" "0" "--align-equal")))
#+end_src

** DONE TikZ/PGF
CLOSED: [2021-01-04 Mon 12:18]
To generate figures, I use sometimes inkscape but main TikZ/PGF.
While ktikz provides a nice tools, the way it deals with the header is problematic for me.
Furthermore, it is not integrated in emacs :D
Therefore, I developed a mode.
However, it relies on a side script ~compilePGF~ being in the PATH!

#+begin_src emacs-lisp
  (use-package tikz-mode
    :ensure straight
    :straight (tikz-mode :type git :host github :repo "seblemaguer/tikz-mode")
      :tags '("WRITING" "BIBTEX" "DESKTOP"))
#+end_src

** DONE Markdown
CLOSED: [2021-01-04 Mon 12:22]
Markdown is the main language used to write READMEs in collaborative projects.
While I prefer it org-mode, I still have to use it for collaborative purposes.
Consequently, I have to get a proper configuration.
Luckily, =markdown-mode= and =markdown-mode+= provide more than enough.
I just added =grip-mode= to have a proper preview of the file.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :tags '("WRITING" "MARKDOWN")
    :mode ("\\.md$"))

  (use-package markdown-mode+
    :ensure t
    :tags '("WRITING" "MARKDOWN")
    :after markdown-mode)

  (use-package grip-mode
    :ensure t
    :tags '("WRITING" "MARKDOWN" "DESKTOP")
    :commands (grip-mode)
    :bind (:map markdown-mode-command-map
                ("g" . grip-mode)))
#+end_src

** DONE Writing helpers
CLOSED: [2021-01-04 Mon 13:05]
As I am prone to constantly using the same writing ways, I need some helpers to get out the loop.
I am using =academic-phrases= to provided starting points and =mw-thesaurus= to find synonyms and/or related words.

#+begin_src emacs-lisp
  (use-package academic-phrases
    :ensure t
    :tags '("WRITING" "HELPERS" "CONNECTED")
    :commands (academic-phrases))

  (use-package mw-thesaurus
    :ensure straight
    :straight (mw-thesaurus :type git :fetcher github :repo "agzam/mw-thesaurus.el")
    :tags '("WRITING" "HELPERS" "CONNECTED")
    :commands (mw-thesaurus-lookup-at-point))
#+end_src

** DONE Grammar checking
CLOSED: [2021-01-04 Mon 13:06]
To help to deal with my poor English, I am using grammarly to check my text.
The package =grammarly= bring its functionnality into emacs which is a saver for me.

#+begin_src emacs-lisp
  (use-package grammarly
    :ensure t
    :tags '("WRITING" "CONNECTED"))
#+end_src

** DONE Translation 
CLOSED: [2021-01-04 Mon 13:08]
As I have the luck to deal with multiple languages (french, english and bulgarian), I need to have a quick access to some translations.
WordReference is my first choice as I find it quite complete and accurate.
As a fallback, I am using google-translate via the package =go-translate=.

#+begin_src emacs-lisp
  (use-package wordreference
    :load-path default-plugin-dir
    :tags '("WRITING" "HELPERS" "TRANSLATION" "CONNECTED")
    :commands (wordreference wordreference-at-point))

  (use-package go-translate
    :ensure t
    :tags '("WRITING" "HELPERS" "TRANSLATION" "CONNECTED")
    :bind (("\C-ct" . go-translate)
           ("\C-cT" . go-translate-popup))
    :config
    (setq go-translate-local-language "en"
          go-translate-target-language "fr"
          go-translate-extra-directions '(("bg" . "en")
                                          ("en" . "bg")
                                          ("en" . "fr"))
          go-translate-buffer-follow-p t))
#+end_src

** DONE PDF
CLOSED: [2021-01-04 Mon 12:57]
Visualizing PDF files in Emacs is quite useful.
I am using =pdf-tools= which provides a lot of functionalities.
The configuration consists mainly of providing proper keyboard based controls using =hydra=.
I am also using =pdf-view-restore= to keep track of where I was before closing emacs.

#+begin_src emacs-lisp
  (use-package pdf-tools
    :ensure t
    :tags '("DOCUMENT" "DESKTOP")
    :functions
    (pdf-history-backward
     pdf-history-forward
     pdf-links-action-perfom
     pdf-links-isearch-link
     pdf-view-enlarge
     pdf-view-shrink
     pdf-view-scale-reset
     pdf-view-fit-height-to-window
     pdf-view-fit-width-to-window
     pdf-view-fit-page-to-window
     pdf-view-next-page-command
     pdf-view-previous-page-command
     pdf-view-dark-minor-mode)

    :hook
    (pdf-view-mode . (lambda ()
                       (pdf-misc-size-indication-minor-mode)
                       (pdf-links-minor-mode)
                       (pdf-isearch-minor-mode)
                       (cua-mode 0)))

    :bind
    (:map pdf-view-mode-map
          ("/" . pdf-tools-hydra/body)
          ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
          ("<C-s>" . isearch-forward)
          ("g"  . pdf-view-first-page)
          ("G"  . pdf-view-last-page)
          ("l"  . image-forward-hscroll)
          ("h"  . image-backward-hscroll)
          ("j"  . pdf-view-next-page)
          ("k"  . pdf-view-previous-page)
          ("e"  . pdf-view-goto-page)
          ("u"  . pdf-view-revert-buffer)
          ("al" . pdf-annot-list-annotations)
          ("ad" . pdf-annot-delete)
          ("aa" . pdf-annot-attachment-dired)
          ("am" . pdf-annot-add-markup-annotation)
          ("at" . pdf-annot-add-text-annotation)
          ("y"  . pdf-view-kill-ring-save)
          ("i"  . pdf-misc-display-metadata)
          ("s"  . pdf-occur)
          ("b"  . pdf-view-set-slice-from-bounding-box)
          ("r"  . pdf-view-reset-slice))

    :pretty-hydra
    ((:color blue :hint nil)
     ("Move"
      (("g" pdf-view-first-page "First")
       ("G" pdf-view-last-page "Last")
       ("p" pdf-view-previous-page-command "Previous" :color red)
       ("n" pdf-view-next-page-command "Next ":color red)
       ("e" pdf-view-goto-page "Page")
       ("h" image-backward-hscroll "Scroll left" :color red)
       ("l" image-forward-hscroll "Scroll right" :color red))

      "History"
      (("B" pdf-history-backward "Backward" :color red)
       ("N" pdf-history-forward "Forward" :color red))

      "Scale/Fit"
      (("+" pdf-view-enlarge "Enlarge" :color red)
       ("-" pdf-view-shrink "Shrink" :color red)
       ("0" pdf-view-scale-reset "Reset")
       ("H" pdf-view-fit-height-to-window "Fit height")
       ("W" pdf-view-fit-width-to-window "Fit width")
       ("P" pdf-view-fit-page-to-window "Fit page")
       ("b" pdf-view-set-slice-from-bounding-box "Set slice from bounding box")
       ("r" pdf-view-reset-slice "Reset slice"))

      "Annotations"
      (("al" pdf-annot-list-annotations "List")
       ("am" pdf-annot-add-markup-annotation "Markup")
       ("at" pdf-annot-add-text-annotation "Text")
       ("ad" pdf-annot-delete "Delete")
       ("aa" pdf-annot-attachment-dired "Dired")
       ("y"  pdf-view-kill-ring-save "Yank"))

      "Search/Link"
      (("s" pdf-occur "Search")
       ("o" pdf-outline "Outline")
       ("F" pdf-links-action-perfom "Link")
       ("f" pdf-links-isearch-link "Search link"))

      "Do"
      (("d" pdf-view-dark-minor-mode "Dark mode")
       ("i" pdf-misc-display-metadata "Info")
       ("u" pdf-view-revert-buffer "Revert buffer"))))

    :magic ("%PDF" . pdf-view-mode)

    :config
    ;; Install what need to be installed !
    (pdf-tools-install t t t)

    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)

    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)

    ;; more fine-grained zooming
    (setq pdf-view-resize-factor 1.1))

  (use-package pdf-view-restore
    :ensure t
    :after pdf-tools
    :tags '("DOCUMENT" "DESKTOP")
    :hook
    (pdf-view-mode-hook . pdf-view-restore-mode))
#+end_src

*** Grepping
#+begin_src emacs-lisp
  (use-package pdfgrep
    :ensure t
      :tags '("DOCUMENT" "DESKTOP")
    :config
    (pdfgrep-mode))
#+end_src

* Version Control / Project Management [20%]
My code project management is articulated around three key points: GIT, github/gist and =projectile=.
GIT is used as the version control manager; 
github for the non-sensitive repositories; 
gist for snippets and helpers; 
=projectile= to provide project helpers.

** DONE Git
CLOSED: [2021-01-04 Mon 15:40]
My configuration for GIT relies mainly on =magit=.
Aside the standard key/hydra configuration, 
I copied the external opening from https://gist.github.com/dotemacs/9a0433341e75e01461c9
and the pretty configuration is adapted from https://ekaschalk.github.io/post/pretty-magit/

My whole process relies on the commits following this pattern
#+begin_example
[package] operation: short message

optional further description
#+end_example

where:
 - package :: corresponds to subpart of the repository (so mainly packages, modules, or meta and git related informations).
 - operation :: is ~add~, ~update~, ~fix~, ~clean~ or ~doc~
 - short message :: is a short description
 - optional further description :: is used to complete the short description. It is optional and I don't use it so often; only for complicated tweaks

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :tags '("VC" "GIT")
    :commands (magit magit-hydra/body magit-get-current-branch)
    :pretty-hydra
    ((:color blue)
     ("Status/Info"
      (("d" magit-diff-range "Diff")
       ("l" magit-log-all "Log all")
       ("s" magit-status "Status")
       ("t" git-timemachine "Time machine")) ;; FIXME: works only if git-timemachine installed

      "Remote"
      (("f" magit-pull-branch "Pull")
       ("p" magit-push-other "Push"))

      "Operations"
      (("c" magit-commit-create "Commit")
       ("<" project-hydra/body "back"))))

    :bind
    (:map magit-mode-map
          ("o" . magit-open-repo))

    :config

    ;; Ignore recent commit
    (setq magit-status-sections-hook
          '(magit-insert-status-headers
            magit-insert-merge-log
            magit-insert-rebase-sequence
            magit-insert-am-sequence
            magit-insert-sequencer-sequence
            magit-insert-bisect-output
            magit-insert-bisect-rest
            magit-insert-bisect-log
            magit-insert-untracked-files
            magit-insert-unstaged-changes
            magit-insert-staged-changes
            magit-insert-stashes
            magit-insert-unpulled-from-upstream
            magit-insert-unpulled-from-pushremote
            magit-insert-unpushed-to-upstream
            magit-insert-unpushed-to-pushremote))

    ;; Update visualization
    (setq pretty-magit-alist nil
          pretty-magit-prompt nil)

    (defmacro pretty-magit (WORD ICON PROPS &optional NO-PROMPT?)
      "Replace sanitized WORD with ICON, PROPS and by default add to prompts."
      `(prog1
           (add-to-list 'pretty-magit-alist
                        (list (rx bow (group ,WORD (eval (if ,NO-PROMPT? "" ":"))))
                              ,ICON ',PROPS))
         (unless ,NO-PROMPT?
           (add-to-list 'pretty-magit-prompt (concat ,WORD ":")))))

    ;; Operations
    (pretty-magit "add:"      ?  (:foreground "#375E97" :height 1.2) t)
    (pretty-magit "update:"   ?↑   (:foreground "#375E97" :height 1.2) t)
    (pretty-magit "fix:"      ?  (:foreground "#FB6542" :height 1.2) t)
    (pretty-magit "clean:"    ?  (:foreground "#FFBB00" :height 1.2) t)
    (pretty-magit "doc:"      ?  (:foreground "#3F681C" :height 1.2) t)

    ;; Meta information
    (pretty-magit "master"    ?  (:box nil :height 1.2)             t)
    (pretty-magit "origin"    ?  (:box nil :height 1.2)             t)
    (pretty-magit "upstream"  ?  (:box nil :height 1.2)             t)

    (defun add-magit-faces ()
      "Add face properties and compose symbols for buffer from pretty-magit."
      (interactive)
      (with-silent-modifications
        (--each pretty-magit-alist
          (-let (((rgx icon props) it))
            (save-excursion
              (goto-char (point-min))
              (while (search-forward-regexp rgx nil t)
                (compose-region
                 (match-beginning 1) (match-end 1) icon)
                (when props
                  (add-face-text-property
                   (match-beginning 1) (match-end 1) props))))))))

    (advice-add 'magit-status :after 'add-magit-faces)
    (advice-add 'magit-refresh-buffer :after 'add-magit-faces)

    ;; Opening repo externally
    (defun parse-url (url)
      "convert a git remote location as a HTTP URL"
      (if (string-match "^http" url)
          url
        (replace-regexp-in-string "\\(.*\\)@\\(.*\\):\\(.*\\)\\(\\.git?\\)"
                                  "https://\\2/\\3"
                                  url)))
    (defun magit-open-repo ()
      "open remote repo URL"
      (interactive)
      (let ((url (magit-get "remote" "origin" "url")))
        (progn
          (browse-url (parse-url url))
          (message "opening repo %s" url)))))

  (use-package magit-tbdiff
    :ensure t
    :tags '("VC" "GIT")
    :after magit)
#+end_src

*** DONE Git helpers
CLOSED: [2021-01-04 Mon 15:39]
In order to be more efficient with git, I also need some helpers.
I use =gitignore-snippets= to provide starting gitignore content;
=git-timemachine= to navigate changes of a dedicated file;
=git-msg-prefix= to be provide a starting for the commit message and
=git-patch= to send a patch via email (if necessary obviously.)

#+begin_src emacs-lisp
  (use-package gitignore-snippets
    :ensure t
    :tags '("VC" "GIT"))

  (use-package git-msg-prefix
    :ensure t
    :tags '("VC" "GIT")
    :hook
    (git-commit-mode . git-msg-prefix)
    :config
    (setq git-msg-prefix-log-flags " --since='1 week ago' "
          git-msg-prefix-regex "^\\([^:]*: \\)"))

  (use-package git-timemachine
    :ensure t
    :commands (git-timemachine-toggle)
    :tags '("VC" "GIT"))

  (use-package gitpatch
    :ensure t
    :tags '("VC" "GIT" "CONNECTED")
    :config
    (setq gitpatch-mail-attach-patch-key "C-c i"))
#+end_src
** TODO Github [0%]
#+begin_src emacs-lisp
  (use-package forge
    :ensure t
    :demand t
    :tags '("VC")
    :after magit
    :custom-face
    (forge-topic-closed ((t (:strike-through t :inherit magit-dimmed)))))

  (use-package github-explorer
    :ensure t
    :tags '("VC"))

  (use-package github-review
    :ensure t)
#+end_src

** TODO Gist
#+begin_src emacs-lisp
  (use-package gist
    :ensure t
    :tags '("VC")
    :mode-hydra
    (gist-list-mode
     (:color red)
     ("Basic"
      (("F" gist-fetch-current "Fetch")
       ("+" gist-add-buffer "Add buffer")
       ("-" gist-remove-file "Remove file")
       ("g" gist-list-reload "List reload")
       ("k" gist-kill-current "Kill current"))

      "Information"
      (("e" gist-edit-current-description "Edit description")
       ("y" gist-print-current-url "Print URL"))

      "Starring"
      (("^" gist-unstar "Unstar")
       ("*" gist-star "Start"))

      "Remote"
      (("b" gist-browse-current-url "Browse current URL")
       ("f" gist-fork "Fork")))))
#+end_src
** TODO Continuous integration
#+begin_src emacs-lisp
  (use-package travis
    :ensure t
    :tags '("VC")
    :commands (show-my-travis-projects)
    :config

    (require 'travis-utils)

    (defun travis--get-github-token ()
      "Retrieve the Travis token ID."
      (my:auth-source-get-passwd :host "travis-ci.org" :user "seblemaguer"))

    (defun show-my-travis-projects ()
      (interactive)
      (travis-show-projects "seblemaguer")))
#+end_src

** TODO Project management
The commands are based on http://endlessparentheses.com/improving-projectile-with-extra-commands.html?source=rss
#+begin_src emacs-lisp
  (use-package projectile
    :ensure t
    :tags '("PROJECT")
    :config

    ;; Global configuration
    (setq projectile-switch-project-action 'neotree-projectile-action
          projectile-enable-caching t
          projectile-create-missing-test-files t
          projectile-switch-project-action #'projectile-commander
          projectile-ignored-project-function 'file-remote-p)

    ;; Defining some helpers
    (def-projectile-commander-method ?s
      "Open a *shell* buffer for the project."
      ;; This requires a snapshot version of Projectile.
      (projectile-run-shell))

    (def-projectile-commander-method ?c
      "Run `compile' in the project."
      (projectile-compile-project nil))

    (def-projectile-commander-method ?\C-?
      "Go back to project selection."
      (projectile-switch-project))

    ;; Keys
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)

    ;; Activate globally
    (projectile-mode)

    ;; Needed to avoid tramp hanging in buffer listing
    (defadvice projectile-project-root (around ignore-remote first activate)
      (unless (file-remote-p default-directory) ad-do-it))
    )
#+end_src

* Shell [0%]
** TODO Global
The key configuration is mainly coming from https://github.com/jcf/emacs.d the rest is coming from http://www.modernemacs.com/post/custom-eshell/ with some adaptation

#+begin_src emacs-lisp
  (use-package eshell
    :demand
    :tags '("SHELL")
    :hook
    (eshell-mode .  (lambda ()
                      (define-key eshell-mode-map
                        [remap eshell-pcomplete]
                        'helm-esh-pcomplete)
                      (define-key eshell-mode-map
                        (kbd "M-p")
                        'helm-eshell-history)
                      (eshell/export "NODE_NO_READLINE=1")))
    (eshell-exit . (lambda () (setq esh-prompt-num 0)))

    :functions (eshell/pwd)

    :config
    ;; Define helpers for prompts
    (defmacro with-face (STR &rest PROPS)
      "Return STR propertized with PROPS."
      `(propertize ,STR 'face (list ,@PROPS)))

    (defmacro esh-section (NAME ICON FORM &rest PROPS)
      "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
      `(setq ,NAME
             (lambda () (when ,FORM
                          (-> ,ICON
                              (concat esh-section-delim ,FORM)
                              (with-face ,@PROPS))))))

    (defun esh-acc (acc x)
      "Accumulator for evaluating and concatenating esh-sections."
      (--if-let (funcall x)
          (if (s-blank? acc)
              it
            (concat acc esh-sep it))
        acc))

    (defun esh-prompt-func ()
      "Build `eshell-prompt-function'"
      (concat esh-header
              (-reduce-from 'esh-acc "" eshell-funcs)
              "\n"
              eshell-prompt-string))

    (esh-section esh-dir
                 "\xf07c"  ;  (faicon folder)
                 (abbreviate-file-name (eshell/pwd))
                 '(:foreground "blue" :weight ultra-bold :underline t))

    (esh-section esh-git
                 "\xe907"  ;  (git icon)
                 (magit-get-current-branch)
                 '(:foreground "red"))

    (esh-section esh-clock
                 "\xf017"  ;  (clock icon)
                 (format-time-string "%H:%M" (current-time))
                 '(:foreground "forest green"))

    ;; Below I implement a "prompt number" section
    (setq esh-prompt-num 0)
    (advice-add 'eshell-send-input :before
                (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

    (esh-section esh-num
                 "\xf0c9"  ;  (list icon)
                 (number-to-string esh-prompt-num)
                 '(:foreground "brown"))

    (setq esh-sep " | " ; "  "  or " | " ;; Separator between esh-sections
          esh-section-delim " " ;; Separator between an esh-section icon and form
          esh-header "\n " ;; Eshell prompt header

          ;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
          ;; your login, these can be the same.
          eshell-prompt-regexp "[^└]└─> "
          eshell-prompt-string "└─> "

          eshell-funcs (list esh-dir esh-git esh-clock esh-num) ;; Choose which eshell-funcs to enable
          eshell-prompt-function 'esh-prompt-func ;; Enable the new eshell prompt
          )

    ;; ;; If I ever want my own eshell/foo commands overwrite real commands ...
    ;; (setq eshell-prefer-lisp-functions t)

    ;; Helpers
    (defun eshell/clear ()
      "Clear the eshell buffer."
      (let ((inhibit-read-only t))
        (erase-buffer)
        (eshell-send-input)))

    (defun clipboard/set (astring)
      "Copy a string to clipboard"
      (with-temp-buffer
        (insert astring)
        (clipboard-kill-region (point-min) (point-max))))

    (defun eshell/copy-pwd ()
      "Copy current directory to clipboard "
      (clipboard/set (eshell/pwd)))

    (defun eshell/copy-fpath (fname)
      "Copy file name with full path to clipboard "
      (let ((fpath (concat (eshell/pwd) "/" fname)))
        (clipboard/set fpath)
        (concat "Copied path: " fpath)))
    )
#+end_src

** TODO Status in the fringe
#+begin_src emacs-lisp
  (use-package eshell-fringe-status
    :ensure t
    :tags '("SHELL")
    :hook
    (eshell-mode . eshell-fringe-status-mode))
#+end_src

** TODO Fish completion
#+begin_src emacs-lisp
  (use-package fish-completion
    :ensure t
    :tags '("SHELL")
    :config
    (global-fish-completion-mode))
#+end_src

** TODO Some toggling
#+begin_src emacs-lisp
  (use-package eshell-toggle
    :straight
    (eshell-toggle :repo "4DA/eshell-toggle" :type git :host github :version original)
    :tags '("SHELL")

    :functions (eshell-toggle-init-eshell)
    :custom
    (eshell-toggle-size-fraction 3)
    (eshell-toggle-use-projectile-root t)
    (eshell-toggle-run-command nil)
    (eshell-toggle-init-function #'eshell-toggle-init-eshell)

    :bind
    ("<f6>" . eshell-toggle))
#+end_src

** TODO Outline-mode helpers
#+begin_src emacs-lisp
  (use-package eshell-outline
    :ensure t
    :hook (eshell-mode . eshell-outline-mode))
#+end_src

** TODO Syntax highlighting
#+begin_src emacs-lisp
(use-package eshell-syntax-highlighting
  :ensure t
  :after esh-mode
  :tags '("SHELL")
  :config
  ;; Enable in all Eshell buffers.
  (eshell-syntax-highlighting-global-mode +1))
#+end_src

* File manager [0%]
** TODO Dired [0%]
*** TODO Run associated application - define helpers
First, globally association achieve thanks to *xdg-open*.  Also, by making some minor adaptations, I
defined some helpers to play video/audio using emms directly. It is mainly adapted from here:
https://github.com/kuanyui/.emacs.d/blob/master/rc/rc-emms.el
#+begin_src emacs-lisp
  (defun dired-open-native ()
    "Open marked files (or the file the cursor is on) from dired."
    (interactive)
    (let* ((files (dired-get-marked-files t current-prefix-arg))
           (n (length files)))
      (when (or (<= n 3)
                (y-or-n-p (format "Open %d files?" n)))
        (dolist (file files)
          (call-process "xdg-open" nil 0 nil file)))))

                                          ; The use of "gnome-open" here should probably be parameterized.
  (defun dired-open-current-directory-in-GUI-file-manager ()
    "Open the current directory in native GUI file namanger
  For those times when dired just wont do.
  "
    (interactive)
    (save-window-excursion
      (dired-do-async-shell-command
       "xdg-open .")))

  (defun emms-clear-playlist-if-any ()
    "Clear emms playlist (coming from: https://www.emacswiki.org/emacs/SimpleEmmsUserInterface )."
    (when emms-playlist-buffer
      (with-current-buffer emms-playlist-buffer)
        (emms-playlist-clear)))

  (defun file-audio-or-video-p (file-path)
    "Detect if the FILE-PATH is pointing to a video/audio file or not."
    (let* ((safe-path (replace-regexp-in-string "\"" "\\\"" (expand-file-name file-path)))
           (mime (shell-command-to-string (format "file --mime --brief \"%s\"" safe-path)))
           (type (car (split-string mime "/"))))
      (if (member type '(video audio))
          type
        nil)))

  ;; Disable video output to prevent a stupid new window.
  (defun dired-emms-play ()
    "Play current file from the dired buffer using emms"
    (interactive)
    (let ((file-path (dired-get-filename)))
      (if (or (member (file-name-extension file-path)
                      '("ogg" "mp3" "wav" "mpg" "mpeg" "wmv" "wma" "3gpp"
                        "mov" "avi" "divx" "ogm" "ogv" "asf" "mkv"
                        "rm" "rmvb" "mp4" "flac" "vrob" "m4a" "ape"
                        "flv" "webm"))
              (file-audio-or-video-p file-path))

          (progn
            (emms-play-dired)
            (emms-clear-playlist-if-any))))

    (dired-next-line 1))
#+end_src

*** TODO Main configuration
Hydra mapping for dired taken from https://github.com/abo-abo/hydra/wiki/Dired and adapted.

#+begin_src emacs-lisp
  (use-package dired
    :tags '("FILE_MANAGEMENT")
    :functions
    (diredp-hide-subdir-nomove
     diredp-ediff
     dired-ediff-files
     diredp-compress-this-file)

    :mode-hydra
    (dired-mode
     (:color red)
     ("Basic"
      (("+" dired-create-directory "Create directory")
       ("C" dired-do-copy "Copy")
       ("D" dired-do-delete "Delete")
       ("R" dired-do-rename "Rename/Move")
       ("r" dired-do-rsync "Rsync")
       ("v" dired-view-file "View the file")
       ("O" dired-display-file "Display the file")
       ("S" dired-do-symlink "Symbolic link"))

      "Search"
      (("A" dired-do-find-regexp "Find")
       ("Q" dired-do-find-regexp-and-replace "Find and replace")
       ("F" dired-do-find-marked-files "Find and mark")
       ("o" dired-find-file-other-window "Find in an other window"))

      "Permissions"
      (("G" dired-do-chgrp "Change group")
       ("M" dired-do-chmod "Change permissions"))

      "Marking"
      (("m" dired-mark "Mark")
       ("t" dired-toggle-marks "Toggle mark")
       ("u" dired-unmark "Unmark")
       ("U" dired-unmark-all-marks "Unmark all"))

      "Diff"
      (("=" diredp-ediff "Ediff")
       ("e" dired-ediff-files "Ediff files"))

      "Display"
      (("(" dired-hide-details-mode "Show details" :toggle t)
       (")" dired-git-info-mode "Git info" :toggle t)
       ("s" dired-sort-toggle-or-edit "Sort")
       ("$" diredp-hide-subdir-nomove "Hide subdir")
       ("g" revert-buffer "Redisplay"))))

    :bind
    (:map dired-mode-map
          ("C-o" . dired-omit-mode)
          ("<C-return>" . dired-open-native)
          ("e" . dired-open-externally)
          ("p" . dired-emms-play)
          ("E" . ora-ediff-files))

    :init
    (defun ora-ediff-files ()
      (interactive)
      (let ((files (dired-get-marked-files))
            (wnd (current-window-configuration)))
        (if (<= (length files) 2)
            (let ((file1 (car files))
                  (file2 (if (cdr files)
                             (cadr files)
                           (read-file-name
                            "file: "
                            (dired-dwim-target-directory)))))
              (if (file-newer-than-file-p file1 file2)
                  (ediff-files file2 file1)
                (ediff-files file1 file2))
              (add-hook 'ediff-after-quit-hook-internal
                        (lambda ()
                          (setq ediff-after-quit-hook-internal nil)
                          (set-window-configuration wnd))))
          (error "no more than 2 files should be marked"))))

    (setq-default dired-omit-files "^\\.\\([a-zA-Z0-9].*\\)?$"
                  dired-omit-mode t)

    :config

    ;; Adapt ls for mac
    (when (eq system-type 'darwin)
      (use-package ls-lisp
        :defines ls-lisp-use-insert-directory-program
        :config
        (setq ls-lisp-use-insert-directory-program t
              insert-directory-program "/usr/local/bin/gls")))

    ;; Omitting
    (put 'dired-find-alternate-file 'disabled nil)

    (setq dired-dwim-target t

          ;; Compression
          auto-compression-mode t

          ;; Recursive
          dired-recursive-deletes 'top
          dired-recursive-copies 'always

          ;; Details information
          dired-listing-switches "--group-directories-first -alh"
          dired-details-hidden-string "[...]")
    )

  (use-package ls-lisp
    :config
    ;; Adapt ls lisp format
    (if (boundp 'ls-lisp-ignore-case)
        (setq ls-lisp-ignore-case t))
    (if (boundp 'ls-lisp-dirs-first)
        (setq ls-lisp-dirs-first t))
    (if (boundp 'ls-lisp-use-localized-time-format)
        (setq ls-lisp-use-localized-time-format t))
    (if (boundp 'ls-lisp-format-time-list)
        (setq ls-lisp-format-time-list '("%Y-%m-%d %H:%M" "%Y-%m-%d %H:%M"))))
#+end_src

*** TODO peep-dired
#+begin_src emacs-lisp
  (use-package peep-dired
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :config
    (define-key dired-mode-map (kbd "P") 'peep-dired))
#+end_src

*** TODO dired-narrow
#+begin_src emacs-lisp
  (use-package dired-narrow
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :config
    (define-key dired-mode-map (kbd "/") 'dired-narrow))
#+end_src

*** TODO dired-single
#+begin_src emacs-lisp
  (use-package dired-single
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :config
    (define-key dired-mode-map [return] 'dired-single-buffer)
    (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse))
#+end_src


*** TODO dired-filter
#+begin_src emacs-lisp
  (use-package dired-filter
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :hook
    (dired-mode . dired-filter-group-mode)

    :init
    (setq dired-filter-revert 'never
          dired-filter-group-saved-groups
          '(("default"
             ("previous"
              (regexp . "^\\.\\.$"))
             ("Directory"
              (directory))
             ("Git"
              (directory . ".git")
              (file . ".gitignore"))
             ("PDF"
              (extension . "pdf"))
             ("LaTeX"
              (extension "tex" "bib"))
             ("Source"
              (extension "c" "cpp" "hs" "rb" "py" "r" "cs" "el" "lisp" "html" "js" "css"))
             ("Doc"
              (extension "md" "rst" "txt"))
             ("Org"
              (extension . "org"))
             ("Archives"
              (extension "zip" "rar" "gz" "bz2" "tar"))
             ("Images"
              (extension "jpg" "JPG" "webp" "png" "PNG" "jpeg" "JPEG" "bmp" "BMP" "TIFF" "tiff" "gif" "GIF"))))))
#+end_src

*** TODO dired-subtree
#+begin_src emacs-lisp
  (use-package dired-subtree
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :bind (:map dired-mode-map
                ("i" . dired-subtree-insert)
                (";" . dired-subtree-remove)))
#+end_src

*** TODO dired-git-info
#+begin_src emacs-lisp
  (use-package dired-git-info
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :bind (:map dired-mode-map
                (")"  . dired-git-info-mode)))
#+end_src

#+end_src

*** TODO Images
#+begin_src emacs-lisp
  (use-package image-dired+
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :config
    (setq auto-image-file-mode t)
    (eval-after-load 'image-dired+ '(image-diredx-async-mode 1)))
#+end_src

*** TODO Async
#+begin_src emacs-lisp
  (use-package async
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :after dired
    :config

    (when (require 'dired-aux)
      (progn
        (require 'dired-async))
      (dired-async-mode 1)))
#+end_src

*** TODO Dired / Rsync
#+begin_src emacs-lisp
  (use-package dired-rsync
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :functions dired-do-rsync
    :config
    (bind-key "C-c C-r" 'dired-rsync dired-mode-map))
#+end_src

** TODO Images [0%]
*** TODO Visualisation
#+begin_src emacs-lisp
  (use-package image+
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :pretty-hydra
    ((:color red)
     ("Zoom"
      (("+" imagex-sticky-zoom-in "zoom in")
       ("-" imagex-sticky-zoom-out "zoom out")
       ("M" imagex-sticky-maximize "maximize"))

      "Rotation"
      (("r" imagex-sticky-rotate-right "rotate right")
       ("l" imagex-sticky-rotate-left "rotate left"))

      "I/O"
      (("O" imagex-sticky-restore-original "restore original")
       ("S" imagex-sticky-save-image "save file"))
      ))

    :hook
    (image-mode . (lambda () (require 'image+) (imagex-sticky-mode)))

    :bind (:map image-mode-map
		("/" . image+-hydra/body)))
#+end_src

*** TODO Manipulation
#+begin_src emacs-lisp
  (use-package blimp
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :hook
    (image-mode . blimp-mode))
#+end_src

** TODO Diff [0%]
*** TODO Global
#+begin_src emacs-lisp
  (use-package ediff
    :tags '("FILE_MANAGEMENT")
    :config
    (autoload 'diff-mode "diff-mode" "Diff major mode" t)
    (setq diff-switches "-u"
          ediff-auto-refine-limit (* 2 14000)
          ediff-window-setup-function 'ediff-setup-windows-plain
          ediff-split-window-function
          (lambda (&optional arg)
            (if (> (frame-width) 160)
                (split-window-horizontally arg)
              (split-window-vertically arg)))))
#+end_src

*** TODO Helpers for region diff
#+begin_src emacs-lisp
  (defun diff-region ()
    "Select a region to compare"
    (interactive)
    (when (use-region-p) ; there is a region
      (let (buf)
        (setq buf (get-buffer-create "*Diff-regionA*"))
        (save-current-buffer
          (set-buffer buf)
          (erase-buffer))
        (append-to-buffer buf (region-beginning) (region-end)))
      )
    (message "Now select other region to compare and run `diff-region-now`"))

  (defun diff-region-now ()
    "Compare current region with region already selected by `diff-region`"
    (interactive)
    (when (use-region-p)
      (let (bufa bufb)
        (setq bufa (get-buffer-create "*Diff-regionA*"))
        (setq bufb (get-buffer-create "*Diff-regionB*"))
        (save-current-buffer
          (set-buffer bufb)
          (erase-buffer))
        (append-to-buffer bufb (region-beginning) (region-end))
        (ediff-buffers bufa bufb))
      ))
#+end_src

** TODO Tramp
#+begin_src emacs-lisp
  (use-package tramp
    :defer t
    :tags '("FILE_MANAGEMENT")
    :custom (tramp-default-method "ssh"
             password-cache-expiry 60
             tramp-verbose 1
             tramp-auto-save-directory temporary-file-directory)
          ;; ;; Debug
          ;; tramp-verbose 9
          ;; tramp-debug-buffer t)
  )
#+end_src

** TODO Trash
#+begin_src emacs-lisp
  ;; Ask confirmation only once and move to trash
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)

  (defun empty-trash()
    "Command to empty the trash (for now gnome/linux specific)"
    (interactive)
    (shell-command "rm -rf ~/.local/share/Trash/*"))

  (defun open-trash-dir()
    "Command to open the trash dir"
    (interactive)
    (find-file "~/.local/share/Trash/files"))
#+end_src

** TODO Treemacs [0%]
*** TODO Global
#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :bind (:map global-map
                ([f8]        . treemacs))
    :functions (treemacs-follow-mode treemacs-filewatch-mode)

    :config
    (setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
          treemacs-deferred-git-apply-delay      0.5
          treemacs-display-in-side-window        t
          treemacs-eldoc-display                 t
          treemacs-file-event-delay              5000
          treemacs-file-follow-delay             0.2
          treemacs-follow-after-init             t
          treemacs-git-integration               t
          treemacs-git-command-pipe              ""
          treemacs-goto-tag-strategy             'refetch-index
          treemacs-indentation                   2
          treemacs-indentation-string            " "
          treemacs-is-never-other-window         nil
          treemacs-max-git-entries               5000
          treemacs-missing-project-action        'ask
          treemacs-no-png-images                 nil
          treemacs-no-delete-other-windows       t
          treemacs-project-follow-cleanup        nil
          treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
          treemacs-position                      'left
          treemacs-recenter-distance             0.1
          treemacs-recenter-after-file-follow    nil
          treemacs-recenter-after-tag-follow     nil
          treemacs-recenter-after-project-jump   'always
          treemacs-recenter-after-project-expand 'on-distance
          treemacs-show-cursor                   nil
          treemacs-show-hidden-files             t
          treemacs-silent-filewatch              nil
          treemacs-silent-refresh                nil
          treemacs-sorting                       'alphabetic-desc
          treemacs-space-between-root-nodes      t
          treemacs-tag-follow-cleanup            t
          treemacs-tag-follow-delay              1.5
          treemacs-width                         35)

    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t))
#+end_src

*** TODO Projectile
#+begin_src emacs-lisp
  (use-package treemacs-projectile
    :ensure t
    :tags '("FILE_MANAGEMENT")
    :functions treemacs-projectile-create-header
    :after treemacs projectile
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header))
#+end_src

*** TODO Magit
#+begin_src emacs-lisp
  (use-package treemacs-magit
    :tags '("FILE_MANAGEMENT")
    :after treemacs magit
    :ensure t)
#+end_src

*** TODO Icons
#+begin_src emacs-lisp
  (use-package treemacs-icons-dired
    :tags '("FILE_MANAGEMENT")
    :ensure t
    :commands (treemacs-icons-dired-mode)
    :hook
    (dired-mode . treemacs-icons-dired--enable-highlight-correction)
    (dired-mode . treemacs--select-icon-set )
    (dired-mode . treemacs-icons-dired-mode))
#+end_src

* Online [0%]
** TODO RSS [0%]
*** TODO Global
#+begin_src emacs-lisp
  (use-package elfeed
    :ensure t
    :tags '("REQUIRES_CONNECTION" "RSS")
    :commands (elfeed elfeed-update)
    :no-require t
    :bind (([f9] . elfeed))

    :config
    ;; Change the storage directory
    (setq elfeed-db-directory "~/pCloudDrive/emacs/elfeed"

          ;; Formatting dates
          elfeed-search-date-format '("%Y-%m-%d %H:%M" 17 :left)))
#+end_src

*** TODO Org connection
#+begin_src emacs-lisp
  (use-package elfeed-org
    :ensure t
    :tags '("REQUIRES_CONNECTION" "RSS")
    :hook (after-init . loading-elfeed)
    :commands (elfeed-org)
    :init
    (defun loading-elfeed ()
      (when (file-exists-p "~/pCloudDrive/org/perso/emacs/rss.org")
        (progn
          (elfeed-org)
          (setq rmh-elfeed-org-files (list "~/pCloudDrive/org/perso/emacs/rss.org"))
          (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)))))
#+end_src

*** TODO Youtube specificities
#+begin_src emacs-lisp
  (use-package youtube-dl
    :straight (youtube-dl :repo "skeeto/youtube-dl-emacs" :type git :host github)
    :tags '("CONNECTED")
    :bind ("C-x y" . youtube-dl-list)
    :config
    (setq youtube-dl-directory "~/Downloads")

    ;; FIXME: should be moved !
    (defun expose (function &rest args)
      "Return an interactive version of FUNCTION, 'exposing' it to the user."
      (lambda ()
        (interactive)
        (apply function args)))

    (defun elfeed-show-youtube-dl ()
      "Download the current entry with youtube-dl."
      (interactive)
      (pop-to-buffer (youtube-dl (elfeed-entry-link elfeed-show-entry))))

    (cl-defun elfeed-search-youtube-dl (&key slow)
      "Download the current entry with youtube-dl."
      (interactive)
      (let ((entries (elfeed-search-selected)))
        (dolist (entry entries)
          (if (null (youtube-dl (elfeed-entry-link entry)
                                :title (elfeed-entry-title entry)
                                :slow slow))
              (message "Entry is not a YouTube link!")
            (message "Downloading %s" (elfeed-entry-title entry)))
          (elfeed-untag entry 'unread)
          (elfeed-search-update-entry entry)
          (unless (use-region-p) (forward-line)))))

    (defalias 'elfeed-search-youtube-dl-slow
      (expose #'elfeed-search-youtube-dl :slow t))

    (define-key elfeed-show-mode-map "d" 'elfeed-show-youtube-dl)
    (define-key elfeed-search-mode-map "d" 'elfeed-search-youtube-dl)
    (define-key elfeed-search-mode-map "D" 'elfeed-search-youtube-dl-slow)
    (define-key elfeed-search-mode-map "L" 'youtube-dl-list))
#+end_src
*** TODO Dashboard
#+begin_src emacs-lisp
  (use-package elfeed-dashboard
    :ensure t
    :tags '("REQUIRES_CONNECTION" "RSS")
    :commands (elfeed-dashboard)
    :bind
    (([f9] . elfeed-dashboard))

    :custom
    (elfeed-dashboard-file "~/.emacs.d/third_parties/dashboards/elfeed.org")

    :config
    ;; to update feed counts automatically
    (advice-add 'elfeed-search-quit-window :after #'elfeed-dashboard-update-links))
#+end_src

*** TODO Notification part
#+begin_src emacs-lisp
  (use-package sauron-elfeed
    :tags '("REQUIRES_CONNECTION" "RSS")
    :commands (elfeed-update-background-start sauron-elfeed-start)
    :hook (after-init . sauron-elfeed-start)
    :config
    (cl-loop for feed in elfeed-feeds
             do (when (member 'mustread (cdr feed))
                  (puthash (car feed) 3 sauron-elfeed-prio-hash))))

#+end_src

** TODO Mail [0%]
*** TODO TTLS
  #+begin_src emacs-lisp
    (use-package starttls
      :tags '("CONNECTED")
      :if (< emacs-major-version 27)
      :config
      (setq starttls-use-gnutls t
            starttls-gnutls-program "gnutls-cli"
            starttls-extra-arguments '("--insecure")
            auth-sources '("~/.authinfo.gpg")))

  #+end_src

*** TODO Message composition
#+begin_src emacs-lisp
  (use-package message
    :tags '("REQUIRES_CONNECTION" "MAIL")
    :hook
    (message-setup . (lambda () (footnote-mode t)))

    :config
    (setq message-auto-save-directory nil
          message-citation-line-function 'message-insert-formatted-citation-line
          message-citation-line-format  "\n\n-----------------------\nOn %a, %b %d %Y (%-H:%M %Z), %N wrote:\n"
          message-sendmail-f-is-evil nil
          message-kill-buffer-on-exit t
          message-signature-file (format "%s/third_parties/mail/signature" user-emacs-directory)
          message-fill-column 100)
    )
#+end_src

*** TODO Composing/Sending [0%]
**** TODO SMTP configuration
  #+begin_src emacs-lisp
    (use-package smtpmail-multi
      :ensure t
      :tags '("REQUIRES_CONNECTION" "MAIL")
      :config
      ;; Get account informations from private file
      (when (fboundp 'set-smtpmail-multi-accounts)
        (set-smtpmail-multi-accounts))

      ;; Define default environment
      (setq user-full-name "Sébastien Le Maguer"
            smtpmail-multi-default-account 'tcd
            message-send-mail-function 'smtpmail-multi-send-it
            mail-host-address "tcd.ie"

            ;; Debug part
            smtpmail-debug-info nil
            smtpmail-debug-verbose nil)
      )
  #+end_src

**** TODO HTML Composing
#+begin_src emacs-lisp
  (use-package org-mime
    :ensure t
    :commands (mu4e-compose-new)
    :hook
    (org-ctrl-c-ctrl-c . htmlize-and-send)

    :config
    (defun htmlize-and-send ()
      "When in an org-mu4e-compose-org-mode message, htmlize and send it."
      (interactive)
      (when (member 'org~mu4e-mime-switch-headers-or-body post-command-hook)
        (org-mime-htmlize)
        (message-send-and-exit))))
#+end_src

**** TODO Checking attachment
#+begin_src emacs-lisp
  (use-package message-attachment-reminder
    :ensure t
    :commands (message-attachment-reminder-warn-if-no-attachments)
    :hook
    (message-send . message-attachment-reminder-warn-if-no-attachments))
#+end_src

*** TODO Mu4e [0%]
**** TODO Global
#+begin_src emacs-lisp
  (use-package mu4e
    :tags '("REQUIRES_CONNECTION" "MAIL")
    :commands (mu4e)
    :load-path "~/environment/local/share/emacs/site-lisp/mu4e"
    :pretty-hydra
    ((:color blue :hint nil)
     ("General"
      (("n" mu4e-headers-next "Next")
       ("p" mu4e-headers-previous "Previous")
       ("[" mu4e-select-next-unread "Next unred")
       ("]" mu4e-select-previous-unread "Previous unred")
       ("y" mu4e-select-other-view "Switch view")
       ("R" mu4e-compose-reply "Reply")
       ("C" mu4e-compose-new "Compose")
       ("F" mu4e-compose-forward "Forward")
       ("o" my/org-capture-mu4e "Org capture"))                  ; differs from built-in

      "Search"
      (("s" mu4e-headers-search "Search")
       ("S" mu4e-headers-search-edit "Edit prev. query")
       ("/" mu4e-headers-search-narrow "Narrow search")
       ("b" mu4e-headers-search-bookmark "Search bookmark")
       ("B" mu4e-headers-search-bookmark-edit "Edit bookmark")
       ("{" mu4e-headers-query-prev "Previous query")              ; differs from built-in
       ("}" mu4e-headers-query-next "Next query")              ; differs from built-in
       ("C-+" mu4e-headers-split-view-grow "Show more")
       ("C--" mu4e-headers-split-view-shrink "Show less"))

      "Mark"
      (("!" mu4e-headers-mark-for-read "Read")
       ("?" mu4e-headers-mark-for-unread "Unread")
       ("r" mu4e-headers-mark-for-refile "Refile")
       ("u" mu4e-headers-mark-for-unmark "Unmark")
       ("U" mu4e-mark-unmark-all "Unmark *")
       ("d" mu4e-headers-mark-for-trash "Trash")
       ("D" mu4e-headers-mark-for-delete "Delete")
       ("m" mu4e-headers-mark-for-move "Move")
       ("a" mu4e-headers-action "Action")                  ; not really a mark per-se
       ("A" mu4e-headers-mark-for-action "Mark for action")         ; differs from built-in
       ("*" mu4e-headers-mark-for-something "*thing")

       ("#" mu4e-mark-resolve-deferred-marks "Deferred")
       ("%" mu4e-headers-mark-pattern "Pattern")
       ("&" mu4e-headers-mark-custom "Custom")
       ("+" mu4e-headers-mark-for-flag "Flag")
       ("-" mu4e-headers-mark-for-unflag "Unflag")
       ("t" mu4e-headers-mark-subthread "Subthread")
       ("T" mu4e-headers-mark-thread "Thread"))

      "Miscellany"
      (("q" mu4e~headers-quit-buffer "Quit")
       ("H" mu4e-display-manual "Help")
       ("|" mu4e-view-pipe "Through shell")                       ; does not seem built-in any longer
       ("`" mu4e-update-mail-and-index "Update")           ; differs from built-in
       (";" mu4e-context-switch "Switch context")
       ("j" mu4e~headers-jump-to-maildir "Jump to maildir"))

      "Switches"
      (("O" mu4e-headers-change-sorting "Sorting")
       ("P" mu4e-headers-toggle-threading "Threading")
       ("Q" mu4e-headers-toggle-full-search "Full searching")
       ("V" mu4e-headers-toggle-skip-duplicates "Skip dups")
       ("W" mu4e-headers-toggle-include-related "Include related"))))

    :bind
    (([f2] . mu4e)

     :map mu4e-headers-mode-map
     ("|" . mu4e-view-pipe)
     ("." . mu4e-hydra/body)

     :map mu4e-main-mode-map
     ("u" . mu4e-update-mail-and-index)

     :map message-mode-map
     ("C-c C-a" . mail-add-attachment))

    :hook
    (mu4e-compose-mode . format-hook-message)

    :custom
    ;; File management
    (mu4e-maildir "~/mail")
    (mu4e-attachment-dir "~/Downloads")
    (mu4e-change-filenames-when-moving t)

    ;; User interaction
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-compose-forward-as-attachment t)
    (mu4e-hide-index-messages t)
    (mu4e-compose-context-policy 'ask-if-none)
    (mu4e-confirm-quit nil)
    (mu4e-compose-dont-reply-to-self t)
    (mu4e-update-interval nil)

    ;; Gui
    (mu4e-view-show-addresses t)
    (mu4e-view-show-images t)
    (mu4e-view-use-gnus t)
    (mu4e-use-fancy-chars t)

    ;; headers
    (mu4e-headers-date-format "%a %d %b %Y")
    (mu4e-headers-time-format "%H:%M:%S")
    (mu4e-headers-fields      '((:human-date    .  18)
                                (:size          .   6)
                                (:flags         .   6)
                                (:mailing-list  . 10)
                                (:from          .  22)
                                (:subject       .  nil)))

    :config
    (defun mu4e-eaf-wrapper (msg)
      "Wrapper to be able to add `eaf-open-mail-as-html' in `mu4e-view-actions'."
      (eaf-open-mail-as-html))

    (add-to-list 'mu4e-view-actions
                 '("ViewHTML" . mu4e-eaf-wrapper) t)

    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    (defun format-hook-message ()
      "Specify some formatting rules for email message writing."
      ;; (set-fill-column 100)
      (auto-fill-mode 0)
      (visual-fill-column-mode)
      (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
      (visual-line-mode))

    (defun mu4e~headers-line-apply-flag-face (msg line)
      line)

    (defun mu4e~headers-field-apply-basic-properties (msg field val width)
      (case field
        (:subject
         (propertize
          (concat
           (mu4e~headers-thread-prefix (mu4e-message-field msg :thread))
           (truncate-string-to-width val 600))
          'face
          (let ((flags (mu4e-message-field msg :flags)))
            (cond
             ((memq 'trashed flags) 'mu4e-trashed-face)
             ((memq 'draft flags) 'mu4e-draft-face)
             ((or (memq 'unread flags) (memq 'new flags))
              'mu4e-unread-face)
             ((memq 'flagged flags) 'mu4e-flagged-face)
             ((memq 'replied flags) 'mu4e-replied-face)
             ((memq 'passed flags) 'mu4e-forwarded-face)
             (t 'mu4e-header-face)))))
        (:thread-subject
         (propertize
          (mu4e~headers-thread-subject msg)
          'face 'font-lock-doc-face))
        ((:maildir :path :message-id) val)
        ((:to :from :cc :bcc)
         (propertize
          (mu4e~headers-contact-str val)
          'face 'font-lock-function-name-face))
        (:from-or-to (mu4e~headers-from-or-to msg))
        (:date
         (propertize
          (format-time-string mu4e-headers-date-format val)
          'face 'font-lock-string-face))
        (:mailing-list (mu4e~headers-mailing-list val))
        (:human-date
         (propertize
          (mu4e~headers-human-date msg)
          'help-echo (format-time-string
                      mu4e-headers-long-date-format
                      (mu4e-msg-field msg :date))
          'face 'font-lock-string-face))
        (:flags
         (propertize (mu4e~headers-flags-str val)
                     'help-echo (format "%S" val)
                     'face 'font-lock-type-face))
        (:tags
         (propertize
          (mapconcat 'identity val ", ")
          'face 'font-lock-builtin-face))
        (:size (mu4e-display-size val))
        (t (mu4e~headers-custom-field msg field))))
    )
#+end_src

**** TODO Context (mailboxes separation)
#+begin_src emacs-lisp
  (use-package mu4e-context
    :after mu4e
    :tags '("REQUIRES_CONNECTION" "MAIL")
    :config
    ;; Define the contexts (configuration defined in a private file)
    (when (fboundp 'set-mu4e-contexts)
      (set-mu4e-contexts))

    ;; Adapt the environment
    (setq mu4e-context-policy 'pick-first
          ;; mu4e-compose-context-policy nil

          mu4e-user-mail-address-list (delq nil
                                            (mapcar (lambda (context)
                                                      (when (mu4e-context-vars context)
                                                        (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                                                    mu4e-contexts))))
#+end_src

**** TODO Notification
#+begin_src emacs-lisp
  (use-package mu4e-alert
    :ensure t
    :after (sauron-mode-line)
    :tags '("REQUIRES_CONNECTION" "MAIL" "NOTIFICATION")
    :config
    ;; Just notify the counting
    (setq mu4e-alert-email-notification-types '(count))

    ;; Set the style to sauron
    (mu4e-alert-set-default-style 'sauron-mode-line-style)

    ;; Enable everything!
    (mu4e-alert-enable-notifications)
    (mu4e-alert-enable-mode-line-display))
#+end_src

**** TODO Integration with org-mode
#+begin_src emacs-lisp
  (use-package org-mu4e
    :after mu4e
    :tags '("REQUIRES_CONNECTION" "MAIL"))
#+end_src

** TODO Chat [0%]
*** TODO IRC [0%]
**** TODO Global
#+begin_src emacs-lisp
  (use-package erc
    :ensure t
    :tags '("CONNECTED" "CHAT" "ERC")
    :commands (erc)
    :hook
    (erc-mode . erc-format-buffer)

    :preface
    (defun my-irc-password (server)
      "Return the password for the `SERVER'."
      (my:auth-source-get-passwd :host server))

    (defun erc-format-buffer ()
      "Function to be hooked with any erc buffer to apply a dedicated format"
      (erc-truncate-mode t)
      (erc-fill-disable)
      (set (make-local-variable 'scroll-conservatively) 1000)
      (visual-line-mode))

    :custom
    (erc-autojoin-channels-alist '(
                                   ;; ("freenode.net" "#emacs" "#latex" "#org-mode")
                                   ("gitter.im"
                                    "#linux-surface/support" "#linux-surface/community"
                                    "#magit/magit" "#scimax/community" "#emacs-lsp/lsp-mode")))
    (erc-autojoin-timing 'ident)
    (erc-prompt-for-nickserv-password nil)

    ;; Reconnection
    (erc-server-reconnect-attempts 5)
    (erc-server-reconnect-timeout 3)
    (erc-lurker-threshold-time 43200)

    ;; Exclusion
    (erc-hide-list '("JOIN" "PART" "QUIT"))
    (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
    (erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
                               "324" "329" "332" "333" "353" "477"))

    ;; Formatting
    (erc-interpret-mirc-color t)
    (erc-timestamp-format "[%H:%M] ")
    (erc-fill-prefix "      ")
    (erc-insert-timestamp-function 'erc-insert-timestamp-left)

    :config
    (erc-track-minor-mode 1)
    (erc-track-mode 1)
    (erc-services-mode 1)

    ;; Reload plugins
    (erc-update-modules)
    )
#+end_src

**** TODO Some useful plugins
#+begin_src emacs-lisp
  (use-package erc-gitter
    :straight (erc-gitter :type git :host github :repo "jleechpe/erc-gitter")
    :tags '("CONNECTED" "CHAT" "ERC"))

  (use-package erc-colorize
    :ensure t
    :tags '("CONNECTED" "CHAT" "ERC"))

  (use-package erc-hl-nicks
    :ensure t
    :tags '("CONNECTED" "CHAT" "ERC"))

  (use-package erc-youtube
    :ensure t
    :tags '("CONNECTED" "CHAT" "ERC"))

  (use-package erc-image
    :ensure t
    :tags '("CONNECTED" "CHAT" "ERC"))
#+end_src

**** TODO Notification activation
#+begin_src emacs-lisp
  (use-package sauron-erc
    :ensure sauron
    :tags '("CONNECT" "CHAT" "ERC" "NOTIFICATION")
    :commands (sauron-erc-start)
    :custom
    (sauron-prio-erc-default           1)
    (sauron-prio-erc-privmsg-root      1)
    (sauron-prio-erc-privmsg-default   1)
    (sauron-prio-erc-privmsg-for-me    2)
    (sauron-prio-erc-privmsg-mentioned 2))
#+end_src

*** TODO Slack [0%]
**** TODO Global
#+begin_src emacs-lisp
  (use-package slack
    :ensure t
    :tags '("CONNECTED")
    :commands (slack-start)
    :no-require t
    :defines (url-http-method url-http-data url-http-extra-headers url-callback-function url-callback-arguments oauth--token-data)

    :custom
    (slack-profile-image-file-directory (format "%s/slack/profile_pictures" user-emacs-directory))
    (slack-image-file-directory         (format "%s/slack/images" user-emacs-directory))
    (slack-buffer-emojify               t)

    :hook
    (slack-mode . slack-set-timestamp-margin)
    (slack-mode . company-slack-hook)

    :config

    (defun company-slack-hook ()
      (make-local-variable 'company-backends)
      (setq company-backends (copy-tree company-backends))
      (set 'company-backends (append '(company-slack-backend) company-backends)))

    ;; Create directory in case of
    (make-directory slack-profile-image-file-directory t)
    (make-directory slack-image-file-directory t)

    ;; Register the teams (configuration defined in a private file)
    (when (fboundp 'slack-register-teams)
      (slack-register-teams))

    ;; Define formatting time!
    (defun slack-set-timestamp-margin ()
      "Hook function to define the timestamp in the margins"
      (interactive)
      (setq lui-time-stamp-position 'right-margin
            lui-time-stamp-format "[%H:%M - %a %d %b %Y ]"
            right-margin-width (length (format-time-string lui-time-stamp-format))))
    )
#+end_src

**** TODO Helm-slack
#+begin_src emacs-lisp
  (use-package helm-slack
    :straight (helm-slack :type git :host github :repo "yuya373/helm-slack")
    :tags '("CONNECTED")
    :after (slack helm))
#+end_src

*** TODO Global helpers
#+begin_src emacs-lisp
  (defun communication-start ()
    "Routine to start all chats."
    (interactive)

    ;; ERC
    (erc-start)

    ;; Slack
    (slack-start)

    ;; Matrix
    (matrix-connect))

  (defun communication-shutdown ()
    "Routine to shutdown all chats"
    (interactive)

    ;; Erc
    (dolist (erc-buf list-erc-servers)
      (when (get-buffer erc-buf)
        (with-current-buffer erc-buf
          (erc-quit-server "time to go back to the real life"))))

    ;; Slack
    (slack-ws-close)

    ;; Matrix
    (matrix-client-disconnect)

    ;; Clean buffers
    (dolist (buf (buffer-list))
      (cond ((string-prefix-p "*Slack " (buffer-name buf))
             (kill-buffer buf))
            ((string= (with-current-buffer buf major-mode) "erc-mode")
             (kill-buffer buf))
            )))

  (defun communication-start-or-switch ()
    (interactive)
    (if (get-buffer (car list-erc-servers))
        (erc-track-switch-buffer 1)
      (communication-start)))

  (global-set-key (kbd "S-<f2>") 'communication-start-or-switch)
  (global-set-key (kbd "C-<f2>") 'communication-shutdown)
#+end_src

** TODO XXX [0%]
*** TODO Stackexchange
#+begin_src emacs-lisp
  (use-package sx
    :ensure t
    :tags '("CONNECTED")
    :functions (sx-open-link)
    :config
    (bind-keys :prefix "C-c s"
               :prefix-map my-sx-map
               :prefix-docstring "Global keymap for SX."
               ("q" . sx-tab-all-questions)
               ("i" . sx-inbox)
               ("o" . sx-open-link)
               ("u" . sx-tab-unanswered-my-tags)
               ("a" . sx-ask)
               ("s" . sx-search)))
#+end_src

*** TODO Reddit
#+begin_src emacs-lisp
  (use-package md4rd
    :ensure t
    :tags '("CONNECTED")
    :pretty-hydra
    ((:color blue :hint none)
     ("Basic"
      (("o" md4rd-open "Open")
       ("t" md4rd-widget-toggle-line "Toggle line"))

      "Voting"
      (("u" md4rd-upvote "Upvote")
       ("d" md4rd-downvote "Downvote"))

      "Expanding"
      (("e" md4rd-widget-expand-all "Expand all")
       ("c" md4rd-widget-collapse-all "Collapse all"))))

    :bind (:map md4rd-mode-map
                ("u" . md4rd-upvote)
                ("d" . md4rd-downvote)
                ("o" . md4rd-open)
                ("t" . md4rd-widget-toggle-line)
                ("e" . md4rd-widget-expand-all)
                ("c" . md4rd-widget-collapse-all)
                ("TAB" . widget-forward)
                ("<backtab>" . widget-backward)
                ("/" . md4rd-hydra/body))

    :config
    (setq md4rd-subs-active '(lisp+Common_Lisp emacs)))
#+end_src

** TODO Release
#+begin_src emacs-lisp
  (use-package metal-archives-shopping-list
    :ensure t
    :tags '("REQUIRES_CONNECTION" "USER")
    :commands (metal-archives-shopping-list-update
               metal-archives-retrieve-next-releases
               metal-archives-load-artists-map)
    :hook
    ;; (kill-emacs . metal-archives-shopping-list-update)
    (after-init . metal-archives-load-artists-map)

    :custom
    (metal-archives-shopping-list-target-file "~/pCloudDrive/org/perso/music/shopping_list.org")
    (metal-archives-shopping-list-root-node "CD")

    :init
    (add-to-list 'org-agenda-files metal-archives-shopping-list-target-file)

    :config
    (setq metal-archives-favorite-handle 'metal-archives-shopping-list-add-release-and-alert))
#+end_src

* Music
I am playing music in Emacs using EMMS.
The default configuration is already satisfying but I prefered to tweak a couple of part to make it more useable.
The first thing I changed is to use ~mpv~ as a player as I am already it as a default on my system.
I also tweaked the cache and some rendering part as I have a lot of files to navigate through.
Finally, I activated the browser and assigned the multimedia keys to be understood directly by EMMS.

#+begin_src emacs-lisp
  (use-package emms
    :ensure t
    :tags '("MULTIMEDIA" "MUSIC")
    :commands (emms emms-browse-by-artist)
    :bind
    (("<f5>"            . emms-browse-by-artist)
     ("S-<f5>"          . emms-playlist-mode-go)
     ("<XF86AudioPlay>" . emms-pause)
     ("<XF86AudioStop>" . emms-stop)
     ("<XF86AudioPrev>" . emms-previous)
     ("<XF86AudioNext>" . emms-next))

    :config
    (emms-all)

    ;; Use mpv player
    (setq emms-player-list '(emms-player-mpv))

    ;; A minor macos adaptation
    (when (eq system-type 'darwin)
      (setq emms-source-file-gnu-find "/usr/local/bin/gfind"))

    ;; Some behaviour definition
    (setq later-do-interval 0.0001
          emms-directory "~/.emacs.d/emms"
          emms-playlist-buffer-name "*Music*"
          emms-source-file-default-directory (expand-file-name "~/Music")
          emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
          emms-show-format "NP: %s"
          emms-playlist-default-major-mode 'emms-playlist-mode
          emms-repeat-playlist t
          emms-mode-line-mode-line-function nil  ;; Don't want any info in the mode line
          emms-mode-line-titlebar-function 'emms-mode-line-playlist-current) ;; Put info in the titlebar

    ;; Visualisation activation/deactivation
    (emms-mode-line nil)
    (setq emms-playing-time-display-format " [♪ %s]")
    ;; (emms-playing-time-disable-display)

    ;; Enable cache
    (when (fboundp 'emms-cache)
      (emms-cache 1))

    ;; Adapt track description format
    (defun track-description (track)
      "Return a description of the current TRACK."
      (if (and (emms-track-get track 'info-artist)
               (emms-track-get track 'info-title))
          (let ((pmin (emms-track-get track 'info-playing-time-min))
                (psec (emms-track-get track 'info-playing-time-sec))
                (ptot (emms-track-get track 'info-playing-time))
                (art  (emms-track-get track 'info-artist))
                (tit  (emms-track-get track 'info-title))
                (alb  (emms-track-get track 'info-album)))
            (cond ((and pmin psec) (format "%s - %s - %s [%02d:%02d]" art alb tit pmin psec))
                  (ptot (format  "%s - %s - %s [%02d:%02d]" art alb tit (/ ptot 60) (% ptot 60)))
                  (t (emms-track-simple-description track))))
        (emms-track-simple-description track)))
    (setq emms-track-description-function 'track-description)

    ;; taken from http://emacs.stackexchange.com/questions/21747/emms-how-can-i-have-a-progress-bar?rq=1
    (defun emms-indicate-seek (_sec)
      "Show the progress bar when seek."
      (let* ((total-playing-time (emms-track-get
                                  (emms-playlist-current-selected-track)
                                  'info-playing-time))
             (elapsed/total (/ (* 100 emms-playing-time) total-playing-time)))
        (with-temp-message (format "[%-100s] %2d%% ([%02d:%02d]/[%02d:%02d])"
                                   (make-string elapsed/total ?=)
                                   elapsed/total
                                   (/ emms-playing-time 60) (% emms-playing-time 60)
                                   (/ total-playing-time 60) (% total-playing-time 60))
          (sit-for 2))))
    (add-hook 'emms-player-seeked-functions #'emms-indicate-seek 'append))

  (use-package emms-info-libtag
    :after emms
    :tags '("MULTIMEDIA" "MUSIC")
    :config

    (setq emms-info-asynchronously nil
          emms-info-functions '(emms-info-libtag)))

  (use-package emms-browser
    :after emms
    :tags '("MULTIMEDIA" "MUSIC")
    :hook
    (emms-browser-show-display . (lambda () (hl-line-mode 1)))

    :config
    (emms-browser-make-filter "all-files" (emms-browser-filter-only-type 'file))

    (setq emms-browser-info-artist-format "%i☢ %n"
          emms-browser-info-album-format "%i%cS [%y] %n"
          emms-browser-info-title-format "%i♪ %T. %t [%d]"
          emms-browser-playlist-info-album-format "%cS %a - %A : "
          emms-browser-playlist-info-title-format "%T. %t [%d]"))
#+end_src

* Emacs and the rest of the world [0%]
** TODO Emacs and the desktop environment [0%]
*** TODO Desktop environment control
Thanks to desktop environement, I can control the keyboard and the screen brightness.

#+begin_src emacs-lisp
  (use-package desktop-environment
    :ensure t
    :tags '("DESKTOP")
    :config
    (setq desktop-environment-brightness-normal-increment "-inc 10"
          desktop-environment-brightness-normal-decrement "-dec 10"
          desktop-environment-brightness-small-increment "-inc 5"
          desktop-environment-brightness-small-decrement "-dec 5"
          desktop-environment-brightness-get-command "xbacklight -get"
          desktop-environment-brightness-set-command "xbacklight")
    (desktop-environment-mode))
#+end_src

*** TODO Clipboard
#+begin_src emacs-lisp
  (use-package cliphist
    :ensure t
    :tags '("SYSTEM"))
#+end_src

*** TODO Emacs and firefox
:PROPERTIES:
:FROM: https://github.com/GhostText/GhostText
:END:

#+begin_src emacs-lisp
    (use-package atomic-chrome
      :ensure t
      :tags '("DESKTOP" "GUI")
      :hook
      (after-init . atomic-chrome-start-server)

      :commands
      (atomic-chrome-start-server)

      :init
      (setq atomic-chrome-server-ghost-text-port 4666
            atomic-chrome-default-major-mode 'org-mode)

      :bind
      (("s-c C-c" . atomic-chrome-close-current-buffer)
       :map  atomic-chrome-edit-mode-map
       ("C-c C-c" . nil)))
#+end_src

** TODO Emacs and the system [0%]
*** TODO Bluetooth
#+begin_src emacs-lisp
  (use-package bluetooth
    :ensure t
    :tags '("SYSTEM" "DESKTOP"))
#+end_src

*** TODO Docker
#+begin_src emacs-lisp
  (use-package docker
    :ensure t
    :commands (docker)
    :tags '("SYSTEM"))

  (use-package docker-api
    :ensure t
    :tags '("SYSTEM"))
#+end_src

*** TODO Conda
#+begin_src emacs-lisp
  (use-package conda
    :ensure t
    :tags '("LANGUAGE")
    :init
    (setq conda-anaconda-home (expand-file-name "~/environment/local/miniconda3"))

    (defun conda-hook ()
      "Conda activation hook for python mode."
      (setq conda-message-on-environment-switch nil)
      (conda-env-autoactivate-mode t))

    :hook
    (python-mode . conda-hook)

    :config
    ;; If you want interactive shell support, include:
    (conda-env-initialize-interactive-shells)

    ;; If you want eshell support, include:
    (conda-env-initialize-eshell))
#+end_src

*** TODO Get system control information
#+begin_src emacs-lisp
  (use-package sysctl
    :ensure t
    :tags '("SYSTEM")
    :commands (sysctl))
#+end_src

*** TODO Execute with shell environment
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :tags '("SYSTEM")
    :config
    (setq exec-path-from-shell-arguments nil)
    (exec-path-from-shell-initialize))
#+end_src

** TODO Emacs and the servers [0%]
*** TODO Tramp
*** TODO Docker
#+begin_src emacs-lisp
  (use-package docker-tramp
    :ensure t
    :tags '("SYSTEM"))
#+end_src

*** TODO Slurm
#+begin_src emacs-lisp
  (use-package slurm-mode
    :straight (slurm :type git :host github
                     :repo "ffevotte/slurm.el" 
                     :fork (:host github
                                  :repo "seblemaguer/slurm.el"
                                  :branch "explicit-username")))
  
#+end_src

** TODO EAF
#+begin_src emacs-lisp
  (use-package eaf
    :tags '("HELPER" "GUI")
    :load-path "~/environment/src/20-tools/emacs/emacs-application-framework/emacs-application-framework")
#+end_src

* Visual [0%]
** TODO Theme
#+begin_src emacs-lisp
  (use-package flatfluc-theme
    :ensure t
    :tags '("VISUAL")
    :config
    (load-theme 'flatfluc t))
#+end_src
** TODO Mode-line
#+begin_src emacs-lisp
  (use-package nano-base-colors
    :straight (nano-base-colors :type git
                                :host github
                                :repo "rougier/nano-emacs"
                                :files ("nano-base-colors.el")))

  (use-package nano-faces
    :straight (nano-faces :type git
                          :host github
                          :repo "rougier/nano-emacs"
                          :files ("nano-faces.el")))



  ;;
  ;; Nano mode line format:
  ;;
  ;; [ status | name (primary)               secondary | item1 | item2 ]
  ;;
  ;; -------------------------------------------------------------------
  (require 'subr-x)


  ;; -------------------------------------------------------------------
  (defun vc-branch ()
    (if vc-mode
        (let ((backend (vc-backend buffer-file-name)))
          (concat "#" (substring-no-properties vc-mode
                                               (+ (if (eq backend 'Hg) 2 3) 2))))  nil))


  ;; From https://amitp.blogspot.com/2011/08/emacs-custom-mode-line.html
  ;; ---------------------------------------------------------------------
  (defun shorten-directory (dir max-length)
    "Show up to `max-length' characters of a directory name `dir'."
    (let ((path (reverse (split-string (abbreviate-file-name dir) "/")))
          (output ""))
      (when (and path (equal "" (car path)))
        (setq path (cdr path)))
      (while (and path (< (length output) (- max-length 4)))
        (setq output (concat (car path) "/" output))
        (setq path (cdr path)))
      (when path
        (setq output (concat "…/" output)))
      output))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-make-action (symbol function)
    (let ((map (make-sparse-keymap)))
      (define-key map [header-line mouse-1] function)
      (propertize (format " %s " symbol)
                  'keymap map
                  'face       'nano-face-header-default
                  'pointer 'hand
                  ;; Bug on OSX when mouse-face is defined
                  ;; -> Unable to load color "#FFFFFF"
                  ;; 'mouse-face 'nano-face-header-highlight
                  )))

  (defun nano-modeline-default-actions ()
    (let* ((window    (get-buffer-window (current-buffer)))
           (term-mode (not (display-graphic-p)))
           (dedicated (window-dedicated-p window)))
      (cond ;;(term-mode '())
       (dedicated '(("•" . nano-modeline-action-unset-dedicated)))
       (t         '(("<" . nano-modeline-action-prev-buffer)
                    (">" . nano-modeline-action-next-buffer))))))

  (defun nano-modeline-action-prev-buffer ()
    (interactive)
    (previous-buffer))

  (defun nano-modeline-action-next-buffer ()
    (interactive)
    (next-buffer))

  (defun nano-modeline-action-unset-dedicated ()
    (interactive)
    (set-window-dedicated-p (get-buffer-window (current-buffer)) nil))

  (defun nano-modeline-compose (status name primary secondary &optional actions)
    "Compose a string with provided information"
    (let* ((char-width    (window-font-width nil 'header-line))
           (window        (get-buffer-window (current-buffer)))
           (actions       (or actions (nano-modeline-default-actions)))
           (actions-length (apply '+ (mapcar 'length (mapcar 'car actions))))
           (filler        (make-string
                           (max 0 (- char-width 2 (length actions))) ?\ ))
           (space-up       +0.15)
           (space-down     -0.20)
           (gui            (display-graphic-p))
           (prefix (cond ((string= status "RO")
                          (propertize " RO " 'face 'nano-face-header-popout))
                         ((string= status "**")
                          (propertize " ** " 'face 'nano-face-header-critical))
                         ((string= status "RW")
                          (propertize " RW " 'face 'nano-face-header-faded))
                         (t (propertize status 'face 'nano-face-header-popout))))
           (left (concat
                  (propertize " "  'face 'nano-face-header-default
                              'display `(raise ,space-up))
                  (propertize name 'face 'nano-face-header-strong)
                  (propertize " "  'face 'nano-face-header-default
                              'display `(raise ,space-down))
                  (propertize primary 'face 'nano-face-header-default)))
           (right (concat secondary " "))
           (available-width (- (window-total-width) 1
                               (* 2 (length actions)) actions-length
                               (length prefix) (length left) (length right)
                               (/ (window-right-divider-width) char-width)))
           (available-width (max 1 available-width)))
      (concat prefix
              (if gui
                  (propertize " " 'face 'nano-face-header-separator))
              left
              (propertize (make-string available-width ?\ ) 'face 'nano-face-header-default)
              ;; (if gui
              ;;     (propertize filler 'face 'nano-face-header-filler)
              ;;   (propertize " " 'face 'nano-face-header-filler))
              (propertize right 'face 'nano-face-header-default)
              (if gui 
                  (propertize " "   'face 'nano-face-header-separator))
              (mapconcat (lambda (action)
                           (nano-modeline-make-action (car action) (cdr action)))
                         actions
                         (if gui
                             (propertize " " 'face 'nano-face-header-separator)
                           "")))))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-mu4e-dashboard-mode-p ()
    (bound-and-true-p mu4e-dashboard-mode))

  (defun nano-modeline-mu4e-dashboard-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Mail"
                           (nano-modeline-mu4e-context)
                           ""))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-elfeed-search-mode-p ()
    (derived-mode-p 'elfeed-search-mode))

  (defun nano-modeline-elfeed-search-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Elfeed"
                           (concat "(" (elfeed-search--header)  ")")
                           ""))

  ;; Elfeed (regular header)
  (with-eval-after-load 'elfeed
    (defun elfeed-setup-header ()
      (setq header-line-format (default-value 'header-line-format)))
    (setq elfeed-search-header-function #'elfeed-setup-header))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-elfeed-show-mode-p ()
    (derived-mode-p 'elfeed-show-mode))

  (defun nano-modeline-elfeed-show-mode ()
    (let* ((title        (elfeed-entry-title elfeed-show-entry))
           (tags         (elfeed-entry-tags elfeed-show-entry))
           (tags-str     (mapconcat #'symbol-name tags ", "))
           (date         (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (feed         (elfeed-entry-feed elfeed-show-entry))
           (feed-title   (plist-get (elfeed-feed-meta feed) :title))
           (entry-author (elfeed-meta elfeed-show-entry :author)))
      (nano-modeline-compose (nano-modeline-status)
                             (s-truncate 40 title "…")
                             (concat "(" tags-str ")")
                             feed-title)))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-calendar-mode-p ()
    (derived-mode-p 'calendar-mode))

  (defun nano-modeline-calendar-mode () "")

  ;; Calendar (no header, only overline)
  (with-eval-after-load 'calendar
    (defun calendar-setup-header ()
      (setq header-line-format "")
      (face-remap-add-relative
       'header-line `(:overline ,(face-foreground 'default)
                                :height 0.5
                                :background ,(face-background 'default))))
    (add-hook 'calendar-initial-window-hook #'calendar-setup-header)

    ;; From https://emacs.stackexchange.com/questions/45650
    (add-to-list 'display-buffer-alist
                 `(,(rx string-start "*Calendar*" string-end)
                   (display-buffer-below-selected))))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-org-capture-mode-p ()
    (bound-and-true-p org-capture-mode))

  (defun nano-modeline-org-capture-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Capture"
                           "(org)"
                           ""
                           '(("CAPTURE" . org-capture-finalize))))

  (with-eval-after-load 'org-capture
    (defun org-capture-turn-off-header-line ()
      (setq-local header-line-format (default-value 'header-line-format))
      ;; (fit-window-to-buffer nil nil 8)
      ;; (face-remap-add-relative 'header-line '(:background "#ffffff"))
      (message nil))
    (add-hook 'org-capture-mode-hook
              #'org-capture-turn-off-header-line))

  ;; ---------------------------------------------------------------------
  (setq Info-use-header-line nil)
  (defun nano-modeline-info-breadcrumbs ()
    (let ((nodes (Info-toc-nodes Info-current-file))
          (cnode Info-current-node)
          (node Info-current-node)
          (crumbs ())
          (depth Info-breadcrumbs-depth)
          line)
      (while  (> depth 0)
        (setq node (nth 1 (assoc node nodes)))
        (if node (push node crumbs))
        (setq depth (1- depth)))
      (setq crumbs (cons "Top" (if (member (pop crumbs) '(nil "Top"))
                                   crumbs (cons nil crumbs))))
      (forward-line 1)
      (dolist (node crumbs)
        (let ((text
               (if (not (equal node "Top")) node
                 (format "%s"
                         (if (stringp Info-current-file)
                             (file-name-sans-extension
                              (file-name-nondirectory Info-current-file))
                           Info-current-file)))))
          (setq line (concat line (if (null line) "" " > ")
                             (if (null node) "..." text)))))
      (if (and cnode (not (equal cnode "Top")))
          (setq line (concat line (if (null line) "" " > ") cnode)))
      line))

  (defun nano-modeline-info-mode-p ()
    (derived-mode-p 'Info-mode))

  (defun nano-modeline-info-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Info"
                           (concat "("
                                   (nano-modeline-info-breadcrumbs)
                                   ")")
                           ""))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-org-agenda-mode-p ()
    (derived-mode-p 'org-agenda-mode))

  (defun nano-modeline-org-agenda-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Agenda"
                           ""
                           (format-time-string "%H:%M")))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-term-mode-p ()
    (derived-mode-p 'term-mode))

  (defun nano-modeline-term-mode ()
    (nano-modeline-compose " >_ "
                           "Terminal"
                           (concat "(" shell-file-name ")")
                           (shorten-directory default-directory 32)))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-mu4e-main-mode-p ()
    (derived-mode-p 'mu4e-main-mode))

  (defun nano-modeline-mu4e-main-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Mail"
                           (nano-modeline-mu4e-context)
                           (format-time-string "%A %d %B %Y, %H:%M")))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-mu4e-headers-mode-p ()
    (derived-mode-p 'mu4e-headers-mode))

  (defun nano-modeline-mu4e-headers-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           (mu4e~quote-for-modeline mu4e~headers-last-query)
                           ""
                           ""))

  (with-eval-after-load 'mu4e
    (defun mu4e~header-line-format () (nano-modeline)))

  ;; ---------------------------------------------------------------------
  (setq mu4e-modeline-max-width 72)

  (defun nano-modeline-mu4e-view-mode-p ()
    (derived-mode-p 'mu4e-view-mode))

  (defun nano-modeline-mu4e-view-mode ()
    (let* ((msg     (mu4e-message-at-point))
           (subject (mu4e-message-field msg :subject))
           (from    (mu4e~headers-contact-str (mu4e-message-field msg :from)))
           (date     (mu4e-message-field msg :date)))
      (nano-modeline-compose (nano-modeline-status)
                             (s-truncate 40 subject "…")
                             ""
                             from)))

  (add-hook 'mu4e-view-mode-hook
            (lambda () (setq header-line-format "%-")
              (face-remap-add-relative 'header-line
                                       '(:background "#ffffff" :height 1.0))))


  ;; ---------------------------------------------------------------------
  (defun nano-modeline-nano-help-mode-p ()
    (derived-mode-p 'nano-help-mode))

  (defun nano-modeline-nano-help-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "GNU Emacs / N Λ N O"
                           "(help)"
                           ""))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-message-mode-p ()
    (derived-mode-p 'message-mode))

  (defun nano-modeline-message-mode ()
    (nano-modeline-compose (nano-modeline-status)
                           "Message" "(draft)" ""
                           '(( "SEND" . message-send))))


  ;; ---------------------------------------------------------------------
  (setq org-mode-line-string nil)
  (with-eval-after-load 'org-clock
    (add-hook 'org-clock-out-hook
              '(lambda () (setq org-mode-line-string nil)
                 (force-mode-line-update))))

  (defun nano-modeline-org-clock-mode-p ()
    org-mode-line-string)

  (defun nano-modeline-org-clock-mode ()
    (let ((buffer-name (format-mode-line "%b"))
          (mode-name   (format-mode-line "%m"))
          (branch      (vc-branch))
          (position    (format-mode-line "%l:%c")))
      (nano-modeline-compose (nano-modeline-status)
                             buffer-name 
                             (concat "(" mode-name
                                     (if branch (concat ", "
                                                        (propertize branch 'face 'italic)))
                                     ")" )
                             org-mode-line-string)))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-docview-mode-p ()
    (derived-mode-p 'doc-view-mode))

  (defun nano-modeline-docview-mode ()
    (let ((buffer-name (format-mode-line "%b"))
          (mode-name   (format-mode-line "%m"))
          (branch      (vc-branch))
          (page-number (concat
                        (number-to-string (doc-view-current-page)) "/"
                        (or (ignore-errors
                              (number-to-string (doc-view-last-page-number)))
                            "???"))))
      (nano-modeline-compose
       (nano-modeline-status)
       buffer-name
       (concat "(" mode-name
               (if branch (concat ", "
                                  (propertize branch 'face 'italic)))
               ")" )
       page-number)))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-pdf-view-mode-p ()
    (derived-mode-p 'pdf-view-mode))

  (defun nano-modeline-pdf-view-mode ()
    (let ((buffer-name (format-mode-line "%b"))
          (mode-name   (format-mode-line "%m"))
          (branch      (vc-branch))
          (page-number (concat
                        (number-to-string (pdf-view-current-page)) "/"
                        (or (ignore-errors
                              (number-to-string (pdf-cache-number-of-pages)))
                            "???"))))
      (nano-modeline-compose
       "RW"
       buffer-name
       (concat "(" mode-name
               (if branch (concat ", "
                                  (propertize branch 'face 'italic)))
               ")" )
       page-number)))

  ;; ---------------------------------------------------------------------
  (defun buffer-menu-mode-header-line ()
    (face-remap-add-relative
     'header-line `(:background ,(face-background 'nano-face-subtle))))
  (add-hook 'Buffer-menu-mode-hook
            #'buffer-menu-mode-header-line)

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-completion-list-mode-p ()
    (derived-mode-p 'completion-list-mode))

  (defun nano-modeline-completion-list-mode ()
    (let ((buffer-name (format-mode-line "%b"))
          (mode-name   (format-mode-line "%m"))
          (position    (format-mode-line "%l:%c")))
      (nano-modeline-compose (nano-modeline-status)
                             buffer-name "" position)))

  ;; ---------------------------------------------------------------------

  (defun nano-modeline-default-mode ()
    (let ((buffer-name (format-mode-line "%b"))
          (mode-name   (format-mode-line "%m"))
          (branch      (vc-branch))
          (position    (format-mode-line "%l:%c")))
      (nano-modeline-compose (nano-modeline-status)
                             buffer-name
                             (concat "(" mode-name
                                     (if branch (concat ", "
                                                        (propertize branch 'face 'italic)))
                                     ")" )
                             position)))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-status ()
    "Return buffer status: read-only (RO), modified (**) or read-write (RW)"

    (let ((read-only   buffer-read-only)
          (modified    (and buffer-file-name (buffer-modified-p))))
      (cond (modified  "**") (read-only "RO") (t "RW"))))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-mu4e-context ()
    "Return the current mu4e context as a non propertized string."

    (if (> (length (mu4e-context-label)) 0)
        (concat "(" (substring-no-properties (mu4e-context-label) 1 -1) ")")
      "(none)"))


  ;; ---------------------------------------------------------------------
  (defun nano-modeline ()
    "Install a header line whose content is dependend on the major mode"
    (interactive)
    (setq-default header-line-format
                  '((:eval
                     (cond ((nano-modeline-elfeed-search-mode-p)   (nano-modeline-elfeed-search-mode))
                           ((nano-modeline-elfeed-show-mode-p)     (nano-modeline-elfeed-show-mode))
                           ((nano-modeline-info-mode-p)            (nano-modeline-info-mode))
                           ((nano-modeline-calendar-mode-p)        (nano-modeline-calendar-mode))
                           ((nano-modeline-org-capture-mode-p)     (nano-modeline-org-capture-mode))
                           ((nano-modeline-org-agenda-mode-p)      (nano-modeline-org-agenda-mode))
                           ((nano-modeline-org-clock-mode-p)       (nano-modeline-org-clock-mode))
                           ((nano-modeline-term-mode-p)            (nano-modeline-term-mode))
                           ((nano-modeline-mu4e-dashboard-mode-p)  (nano-modeline-mu4e-dashboard-mode))
                           ((nano-modeline-mu4e-main-mode-p)       (nano-modeline-mu4e-main-mode))
                           ((nano-modeline-mu4e-headers-mode-p)    (nano-modeline-mu4e-headers-mode))
                           ;;         ((nano-modeline-mu4e-view-mode-p)       (nano-modeline-mu4e-view-mode))
                           ((nano-modeline-pdf-view-mode-p)        (nano-modeline-pdf-view-mode))
                           ((nano-modeline-docview-mode-p)         (nano-modeline-docview-mode))
                           ((nano-modeline-completion-list-mode-p) (nano-modeline-completion-list-mode))
                           ((nano-modeline-message-mode-p)         (nano-modeline-message-mode))
                           ((nano-modeline-nano-help-mode-p)       (nano-modeline-nano-help-mode))
                           (t                                      (nano-modeline-default-mode)))))))

  ;; ---------------------------------------------------------------------
  (defun nano-modeline-update-windows ()
    "Modify the mode line depending on the presence of a window below."

    (dolist (window (window-list))
      (with-selected-window window
        (if (or (one-window-p t)
                (eq (window-in-direction 'below) (minibuffer-window))
                (not (window-in-direction 'below)))
            (with-current-buffer (window-buffer window)
              (setq mode-line-format (list "%-")))
          (with-current-buffer (window-buffer window)
            (setq mode-line-format nil)))
        ;;      (if (window-in-direction 'above)
        ;;	      (face-remap-add-relative 'header-line '(:overline "#777777"))
        ;;	    (face-remap-add-relative 'header-line '(:overline nil)))
        )))
  (add-hook 'window-configuration-change-hook 'nano-modeline-update-windows)

  (setq eshell-status-in-modeline nil)
  (setq-default mode-line-format (list "%-"))
  (nano-modeline)
#+end_src

** TODO Layout [0%]
#+begin_src emacs-lisp
  (setq default-frame-alist
        (append (list
                 '(font . "Roboto Mono:style=Light:size=28")
                 ;; '(min-height . 1)  '(height     . 45)
                 ;; '(min-width  . 1)  '(width      . 81)
                 '(vertical-scroll-bars . nil)
                 ;; '(internal-border-width . 24)
                 '(left-fringe    . 30)
                 '(right-fringe   . 30)
                 '(tool-bar-lines . 0)
                 '(menu-bar-lines . 0))))

  ;; Fall back font for glyph missing in Roboto
  (defface fallback '((t :family "Fira Code"
                         :inherit 'nano-face-faded)) "Fallback")
  (set-display-table-slot standard-display-table 'truncation
                          (make-glyph-code ?… 'fallback))
  (set-display-table-slot standard-display-table 'wrap
                          (make-glyph-code ?↩ 'fallback))

  ;; Fix bug on OSX in term mode & zsh (spurious % after each command)
  (add-hook 'term-mode-hook
            (lambda () (setq buffer-display-table (make-display-table))))

  ;; Ignore anoying startup thingies
  (setq inhibit-startup-screen t
        inhibit-startup-message t
        inhibit-startup-echo-area-message t
        initial-scratch-message nil)

  ;; Clean the screen to maximize the editing space
  (tool-bar-mode 0)
  (tooltip-mode 0)
  (menu-bar-mode 0)
  (global-hl-line-mode 1)

  (setq x-underline-at-descent-line t)

  ;; Vertical window divider
  (setq window-divider-default-right-width 12)
  (setq window-divider-default-places 'right-only)
  (window-divider-mode 1)

#+end_src

** TODO Font
#+begin_src emacs-lisp
  (defun set-icon-fonts (CODE-FONT-ALIST)
    "Utility to associate many unicode points with specified fonts."
    (--each CODE-FONT-ALIST
      (-let (((font . codes) it))
        (--each codes
          (set-fontset-font t `(,it . ,it) font)))))

  (defun load-default-fonts ()
    ;; The icons you see are not the correct icons until this is evaluated!
    (set-icon-fonts
     '(("fontawesome"
        ;;                         
        #xf07c #xf0c9 #xf0c4 #xf0cb #xf017 #xf101)

       ("all-the-icons"
        ;;    
        #xe907 #xe928)

       ("github-octicons"
        ;;                        
        #xf091 #xf059 #xf076 #xf075 #xf016 #xf00a)

       ("Symbola"
        ;; 𝕊    ⨂      ∅      ⟻    ⟼     ⊙      𝕋       𝔽
        #x1d54a #x2a02 #x2205 #x27fb #x27fc #x2299 #x1d54b #x1d53d
        ;; 𝔹    𝔇       𝔗
        #x1d539 #x1d507 #x1d517))))

  (defun load-fonts (frame)
    (select-frame frame)
    (load-default-fonts))

  (when (fboundp 'set-fontset-font)
    (if (daemonp)
        (add-hook 'after-make-frame-functions #'load-fonts)
      (load-default-fonts)))
#+end_src

** TODO Helpers [0%]
*** TODO Flashing
#+begin_src emacs-lisp
  (use-package goggles
    :ensure t
    :tags '("VISUAL")
    :config
    (goggles-mode)
    (setq-default goggles-pulse t))
#+end_src

*** TODO Scrolling
#+begin_src emacs-lisp
  (use-package scrollkeeper
    :straight (scrollkeeper :type git :host github :repo "alphapapa/scrollkeeper.el")
    :tags '("VISUAL")
    :general ([remap scroll-up-command] #'scrollkeeper-contents-up
              [remap scroll-down-command] #'scrollkeeper-contents-down))
#+end_src

*** TODO Diff
#+begin_src emacs-lisp
  (use-package diff-hl
    :ensure t
    :tags '("VISUAL")

    :hook ((after-init . global-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode))

    :init (setq diff-hl-draw-borders t)
    :config

    ;; Highlight on-the-fly
    (diff-hl-flydiff-mode 1)

    ;; Integration with magit
    (with-eval-after-load 'magit
      (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)))

  (use-package abridge-diff
    :ensure t
    :after magit ;; optional, if you'd like to use with magit
    :tags '("VISUAL")
    :init (abridge-diff-mode 1))
#+end_src
*** TODO Parenthesis
#+begin_src emacs-lisp
  (use-package smartparens
    :ensure t
    :tags '("VISUAL")
    :config

    ;; Activate smartparens globally
    (smartparens-global-mode t)
    (show-smartparens-global-mode t)

    ;; Activate smartparens in minibuffer
    (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode)

    ;; Do not pair simple quotes
    (sp-pair "'" nil :actions :rem))

  (use-package rainbow-delimiters
    :ensure t
    :tags '("VISUAL")
    :hook
    (prog-mode . rainbow-delimiters-mode))
#+end_src

*** TODO Paging
#+begin_src emacs-lisp
  (use-package page-break-lines
    :ensure t
    :tags '("VISUAL")
    :diminish page-break-lines-mode
    :config
    (global-page-break-lines-mode t))
#+end_src

*** TODO Emoji
#+begin_src emacs-lisp
  (use-package emojify
    :ensure t
    :tags '("VISUAL")
    :functions (emojify-set-emoji-data)
    :hook (erc-mode . emojify-mode)
    :config

    (setq emojify-user-emojis
          '(("(heart)" . (("name" . "Heart")
                          ("image" . "~/.emacs.d/emojis/emojione-v2.2.6-22/2665.png")
                          ("style" . "github")))))

    ;; If emojify is already loaded refresh emoji data
    (when (featurep 'emojify)
      (emojify-set-emoji-data)))
#+end_src

* Key bindings [0%]
In this section, we define the bindings used globally.
We can consider the following categories:
  - The functional bindings :: which allows the user to access to a functionality from anywhere (e.g. opening the version-control manager)
  - The remapped bindings :: which are homogeneizing or extending existing bindings in multiple modes

An helper to remind these bindings is also provided.

** TODO Functional bindings [0%]
This section defines the functional bindings.
Hydra is used as the provider for these bindings.
For now, we consider the following two ones: *main helpers* and *version control*

*** TODO Main Helper
The main helper, mapped to *<f1>* contains the global operations which are interesting to access globally:
 - org-mode capturing and sniffing webpage
 - zooming
 - bookmarking and listing the bookmarks
 - Mail management: listing the synchronization process managed by *prodigy* and creating a new may

#+begin_src emacs-lisp
  (defun text-scale-reset ()
    "Reset the text scale to its original level (0)."
    (interactive)
    (text-scale-set 0))

  (pretty-hydra-define main-hydra
    (:color teal :hint nil :title "Main")
    ("Org related"
     (("g" org-web-tools-read-url-as-org "Get WEB URL"))

     "Help"
     (("f" describe-function "Describe function")
      ("v" describe-variable "Describe variable"))

     "Zooming"
     (("+" text-scale-increase "Zoom in"  :color pink)
      ("-" text-scale-decrease "Zoom out" :color pink)
      ("0" text-scale-reset "Reset zoom"))

     "Bookmark"
     (("b" list-bookmarks "List bookmarks")
      ("B" bookmark-set "Bookmark file"))

     "Mail related"
     (("m" mu4e-compose-new "New mail")
      ("p" prodigy "Open Prodigy"))

     "Backups"
     (("s" snapshot-timeline "List backups")
      ("S" snapshot-timemachine "Backup timemachine"))))

  (global-set-key (kbd "<f1>") 'main-hydra/body)
#+end_src

*** TODO Project/Version control
The following functional binding is the entry point to deal with code project management.
It is mapped to *<f4>*
It deals with:
  - project management using *projectile*
  - version control using *magit*
  - fixme
  - flychecks
  - travis

#+begin_src emacs-lisp
  (pretty-hydra-define project-hydra
    (:color teal :hint nil :title "Project")
    ("Projects"
     (("d"   org-dashboard-display "ORG Dashboard")
      ("p"   projectile-hydra/body "Projectile"))

     "Version Control"
     (("m"   magit-hydra/body "Magit")
      ("t"   show-my-travis-projects "Travis"))

     "Checking/Notes"
     (("f"   fic-view-listing "Fixme listing")
      ("F"   flycheck-hydra/body "Flycheck"))
     ))

  (global-set-key (kbd "<f4>") 'project-hydra/body)
#+end_src

*** TODO Toggling
:PROPERTIES:
:FROM:     https://github.com/jerrypnz/major-mode-hydra.el
:END:
#+begin_src emacs-lisp
  ;; (defvar jp-toggles--title (with-faicon "toggle-on" "Toggles" 1 -0.05))
  (defvar jp-toggles--title "Toggles")

  (pretty-hydra-define jp-toggles
    (:color amaranth :quit-key "q" :title jp-toggles--title)
    ("Basic"
     (("n" linum-mode "line number" :toggle t)
      ("w" whitespace-mode "whitespace" :toggle t)
      ("W" whitespace-cleanup-mode "whitespace cleanup" :toggle t)
      ("r" rainbow-mode "rainbow" :toggle t)
      ("L" page-break-lines-mode "page break lines" :toggle t))

     "Highlight"
     (("s" symbol-overlay-mode "symbol" :toggle t)
      ("l" hl-line-mode "line" :toggle t)
      ("x" highlight-sexp-mode "sexp" :toggle t)
      ("t" hl-todo-mode "todo" :toggle t))

     "Coding"
     (("p" smartparens-mode "smartparens" :toggle t)
      ("P" smartparens-strict-mode "smartparens strict" :toggle t)
      ("S" show-smartparens-mode "show smartparens" :toggle t)
      ("f" flycheck-mode "flycheck" :toggle t))

     "Emacs"
     (("D" toggle-debug-on-error "debug on error" :toggle (default-value 'debug-on-error))
      ("X" toggle-debug-on-quit "debug on quit" :toggle (default-value 'debug-on-quit)))))

  (global-set-key (kbd "<f3>") 'jp-toggles/body)
#+end_src

** TODO Remapped bindings [0%]
The following bindings are remapped to be homogeneous accross the different modes.
It concerns

*** TODO Compilation
#+begin_src emacs-lisp
  (defhydra hydra-next-error (global-map "C-x")
      "
  Compilation errors:
  _j_: next error        _h_: first error    _q_uit
  _k_: previous error    _l_: last error
  "
      ("`" next-error     nil)
      ("j" next-error     nil :bind nil)
      ("k" previous-error nil :bind nil)
      ("h" first-error    nil :bind nil)
      ("l" (condition-case err
               (while t
                 (next-error))
             (user-error nil))
       nil :bind nil)
      ("q" nil            nil :color blue))
#+end_src

*** TODO Commenting
I prefer to use a _C-c C-c_ to compile and therefore, the bindings to comment a section of the code should be remapped.
I select _C-c C-;_ to comment and _C-c C-:_ to uncomment.
Adding a toggle support for the commenting would be a good idea too

#+begin_src emacs-lisp
  (use-package cc-mode
    :bind
    (;; Global
     ("C-c C-;" .  comment-region)
     ("C-c C-:" .  uncomment-region)

     :map c-mode-base-map
          ("C-c C-;" .  comment-region)
          ("C-c C-:" .  uncomment-region)
     :map c++-mode-map
          ("C-c C-;" .  comment-region)
          ("C-c C-:" .  uncomment-region))
  )
#+end_src

*** TODO Buffers
#+begin_src emacs-lisp
  (global-set-key (kbd "M-G") 'what-line)
#+end_src

*** TODO Windows
#+begin_src emacs-lisp
  (global-set-key (kbd "C-c =") 'compare-windows)
#+end_src

*** TODO Files
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-d") 'dired)

  (global-set-key [(control c) ?1] 'find-name-dired)
  (global-set-key [(control c) ?2] 'find-grep-dired)
  (global-set-key [(control c) ?3] 'grep-find)
#+end_src

*** TODO Mac key remapping
#+begin_src emacs-lisp
  (global-set-key (kbd "<end>") 'move-end-of-line)
  (global-set-key (kbd "<home>") 'move-beginning-of-line)
#+end_src

** TODO Reminder for bindings
#+begin_src emacs-lisp
  (use-package remind-bindings
    :ensure t
    :tags '("HELPER")
    :hook (after-init . remind-bindings-initialise)
    :bind (("<f10>" . 'remind-bindings-togglebuffer)   ;; toggle buffer
           ("C-<f10>" . 'remind-bindings-specific-mode))) ;; buffer-specific only
#+end_src

* Provide
It is not super necessary but it makes travis happy

#+begin_src emacs-lisp
  (provide 'init)
#+end_src
