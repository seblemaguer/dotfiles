#+TITLE: Emacs configuration file
#+AUTHOR: Sébastien Le Maguer
#+EMAIL: lemagues@tcd.ie
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  fr
#+OPTIONS:   H:5 num:t toc:t prop:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://seblemaguer.github.io/css/main.css" />

#+PROPERTY: header-args:emacs-lisp  :mkdirp yes :lexical t :exports code
#+PROPERTY: header-args:emacs-lisp+ :tangle ~/.emacs.d/init.el
#+PROPERTY: header-args:emacs-lisp+ :mkdirp yes :noweb no-export

This is my emacs configuration file. It is under version control and available, among other
configurations, at this repository: https://github.com/seblemaguer/dotfiles

* Command line management
This part is dedicated to support some configuration using the command line by defining some options.
For now, only the option =--no-connection= is defined in order enforce the loading without packages requiring internet.

#+begin_src emacs-lisp
  (defvar no-connection nil
    "Flag indicating if we are operating without any internet connection")

  ;; Theming Command line options (this will cancel warning messages)
  (add-to-list 'command-switch-alist '("--no-connection"   . (lambda (args))))
  (add-to-list 'command-switch-alist '("--start-profiler"   . (lambda (args))))

  ;; If required, start profiler
  (when (member "--start-profiler" command-line-args)
    (profiler-start 'cpu))

  (when (member "--debug-init" command-line-args)
    (toggle-debug-on-error))

  ;; Indicates we are operating in no-connection mode
  (when (member "--no-connection" command-line-args)
    (setq no-connection t))
#+end_src

* TODO Definition of no-web helper routines

I found the strategy of defining tables to store keybindings proposed by [[https://config.phundrak.com/][phundrak]] pretty interesting.
It has two main advantages.
First, it allows to ensure a better consistency.
Second, it provides a neatty way to generate a refcard of my personal bindings.

I also extending this to support not only default keybindings but also hydra.
As a result, we have now three routines:
  - keybindings-gen :: generate the elisp for the keybindings from a given table
  - hydra-keybindings-gen :: generate the elisp for the *hydra* keybindings from a given table
  - hydra-keybindings-gen-with-opt :: same as previously but dedicated to take into account options specificied for hydra


#+NAME: keybindings-gen
#+header: :tangle no :exports code :results value :cache yes
#+begin_src emacs-lisp :var table=comment-keybindings prefix=""
  (mapconcat (lambda (line)
               (let* ((key      (car line))
                      (function (cadr line))
                      (comment  (caddr line)))
                 (if (string-prefix-p "[" key)
                     (format "(%s . %s)" key function)
                     (format "(\"%s\" . %s)" key function))))
             table
             "\n")
#+end_src


#+NAME: hydra-keybindings-gen
#+header: :tangle no :exports code :results value :cache yes
#+begin_src emacs-lisp :var table=comment-keybindings prefix=""
  (mapconcat (lambda (line)
               (let* ((key      (car line))
                      (function (cadr line))
                      (label    (caddr line)))
                 (if (string= "" label)
                     (format "(\"%s\" %s)" key function)
                     (format "(\"%s\" %s \"%s\")" key function label))))
             table
             "\n")
#+end_src


#+NAME: hydra-keybindings-gen-with-opt
#+header: :tangle no :exports code :results value :cache yes
#+begin_src emacs-lisp :var table=comment-keybindings prefix=""
  (mapconcat (lambda (line)
               (let* ((key      (car line))
                      (function (cadr line))
                      (label    (caddr line))
                      (options  (cadddr line)))
                 (if (string= "" label)
                   (if (string= "" options)
                     (format "(\"%s\" %s)" key function)
                     (format "(\"%s\" %s %s)" key function options))
                   (if (string= "" options)
                     (format "(\"%s\" %s \"%s\")" key function label)
                     (format "(\"%s\" %s \"%s\" %s)" key function label options)))
                   ))
             table
             "\n")
#+end_src

* Server
Before anything happens, we start the server to avoid conflict if there is a problem during the
loading phase.

#+begin_src emacs-lisp
  (server-start)
#+end_src

We also provide a helper to shutdown properly the server.

#+begin_src emacs-lisp
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+end_src

* TODO Core [90%]
This section focuses on providing helpers and utilities required for the rest of the configuration.

** DONE Fundamentals [100%]
CLOSED: [2021-01-03 Sun 10:46]
This section define the fundamental variables and helpers which are recurrently used in the configuration.

*** DONE Deal with warning issues in "nativecomp"
CLOSED: [2021-06-24 Thu 12:42]
Emacs 28 supports native compilation, but it creates a lot of warnings.
I preferred to disable the report while waiting for a better solution.

#+BEGIN_SRC emacs-lisp
  (when (>= emacs-major-version 28)
    (setq comp-async-report-warnings-errors nil
          native-comp-async-report-warnings-errors nil))
#+END_SRC

*** DONE Define some important variables
CLOSED: [2021-01-03 Sun 10:39]
The section defines the variables =default-plugin-dir= and set the =custom-file=.
Some default values related to emacs' core behaviour, like the garbage collector, are also set here.

#+begin_src emacs-lisp
  ;; Define cloud variables
  (defvar cloud-org-root-dir "~/shared/org-roam/"
    "The root directory of org-mode specific files which should be saved on the cloud.")

  ;; Define root directory and add the plugins
  (defvar default-plugin-dir (concat user-emacs-directory "plugins")
    "The plugins directory")

  (defvar org-agenda-default-files nil
    "Agenda files which are not managed by org-roam/vulpea")

  ;; Don't screw up my files with custom
  (setq custom-file (concat user-emacs-directory "custom.el"))
  (load custom-file 'noerror)

  ;; Silence!!!!!!
  (setq save-abbrevs 'silently
        ad-redefinition-action 'accept

        ;; Garbage collection (see https://github.com/jethrokuan/.emacs.d/blob/master/config.org)
        gc-cons-threshold 100000000
        large-file-warning-threshold 100000000)
#+end_src

*** DONE Identification helper
CLOSED: [2021-01-03 Sun 10:41]
In order to keep the authentification as private as possible, two primitives are defined here;
one to get the user (=my:auth-source-get-user=) and on to get the password (=my:auth-source-get-passwd=).

#+begin_src emacs-lisp
  (require 'cl-lib)
  (require 'auth-source)
  (cl-defun my:auth-source-get-user (&rest spec &allow-other-keys)
    "Helper to get the user given the SPEC from authsource."
    (let ((founds (apply 'auth-source-search spec)))
      (when founds
	(plist-get (nth 0 founds) :user))))

  (cl-defun my:auth-source-get-passwd (&rest spec &allow-other-keys)
    "Helper to get the password given the SPEC from authsource."
    (let ((founds (apply 'auth-source-search spec)))
      (when founds
	(funcall (plist-get (nth 0 founds) :secret)))))
#+end_src

*** DONE Dealing with tangling this file
CLOSED: [2021-01-03 Sun 10:46]
:PROPERTIES:
:FROM:     https://www.reddit.com/r/emacs/comments/6t37yg/org_mode_dot_emacs/
:END:
This section defines two functions:
one to generate the emacs init file from =~/.emacs.d/README.org= and one to byte-compile the emacs init file.

#+begin_src emacs-lisp
  (defun tangle-main-config ()
    "Tangle ~/.emacs.d/README.org to ~/.emacs.d/init.el."
    (interactive)

    ;; Tangle to init.el
    (with-current-buffer (find-file (concat user-emacs-directory "README.org"))
      (org-babel-tangle))

    ;; Tangle to Private variables
    (with-current-buffer (find-file (concat cloud-org-root-dir "perso/configuration/private.org"))
      (org-babel-tangle))

    ;; byte-compile plugins
    (byte-recompile-directory (expand-file-name default-plugin-dir) 0))
#+end_src

** DONE Package management [100%]
My configuration relies on a lot (too-many?) of packages.
It relies primarly on =use-package= and some extensions.
The process of how to deal with the packages is the following:
  - by default, if possible, let's use =melpa=
  - if the package is not on melpa, let's use =straight=
  - if the package is on melpa but requires extra development, let's use =straight=

Furthermore, each package is tagged with several keywors to have a "machine-dependent" loading scheme.

*** DONE Straight
CLOSED: [2021-01-03 Sun 10:52]
In this section, we are configuring =straight=.
=Straight= supports =use-package= by default.
Therefore, there is no extra-configuration for this to do.

 #+begin_src emacs-lisp
   ;; Save up some time
   (setq straight-check-for-modifications nil)

   (defvar bootstrap-version)
   (let ((bootstrap-file
          (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
         (bootstrap-version 5))
     (unless (file-exists-p bootstrap-file)
       (with-current-buffer
           (url-retrieve-synchronously
            "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
            'silent 'inhibit-cookies)
         (goto-char (point-max))
         (eval-print-last-sexp)))
     (load bootstrap-file nil 'nomessage))

   (unless (string= (getenv "TRAVIS") "true")
     (setq straight-vc-git-default-protocol 'ssh))
 #+end_src

*** DONE Load use-package
CLOSED: [2021-01-03 Sun 10:51]
Now that straight is configured, we can tell it to install =use-package=.
From there, =use-package= will be used as the entry function to configure a new package.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (setq straight-use-package-by-default t)
  ;; (setq use-package-verbose t)
#+end_src

*** DONE Tagging
CLOSED: [2021-01-03 Sun 10:58]
I am using keywords/tags to define a loading scheme for each of the machine where emacs is installed.
Each package, from now on, has one or multiple keywords associated using the key =:tags=.
Each computer has a series of tags which are required to be loaded.
The specification respects the following syntax:
  - list of strings which are
  - a tag prefixed by =!= explicitely reject packages whose have this tag associated with
  - ="ALL"= is a joker indicating =all the tags!= $\rightarrow$ no filtering

#+begin_src emacs-lisp
  (use-package use-package-tags
    :straight (use-package-tags :type git :host github :repo "seblemaguer/use-package-tags")
    :config

    (when no-connection
        (setq use-package-tags-default-tag-list '("!CONNECTED")))

    (setq use-package-tags-enabled
          `(("surface"                      . ("ALL" "!MAIL"))
            (,work-hostname                 . ("ALL"))
            ("mackenzie"                    . ("!MAIL" "!RSS" "!USER" "!GUI" "!MULTIMEDIA" "!CHAT" "!DESKTOP"))
            (,use-package-tags-default-host . ("CORE" "!USER" "!DESKTOP")))))
#+end_src

*** DONE Hydra
CLOSED: [2021-01-03 Sun 11:01]
I use hydra a lot so it is easier to add its support directly in the use-package configuration part.
The combination pretty-hydra/major-mode-hydra provides an easy and powerful way to declare hydra.
While alternatives exist, I find this combination more straightforward and cleaner when it is used in combination with =use-package=.

#+NAME: major-mode-hydra-entry-keybindings
| Key   | Function         | Description |
|-------+------------------+-------------|
| M-SPC | major-mode-hydra |             |

#+begin_src emacs-lisp
  (use-package pretty-hydra
    :tags '("CORE"))

  (use-package major-mode-hydra
    :demand t
    :tags '("CORE")
    :bind (
      <<keybindings-gen(table=major-mode-hydra-entry-keybindings)>>
    ))
#+end_src

*** Transient
#+begin_src emacs-lisp :lexical no
  (use-package transient
    :tags '("CORE"))
#+end_src

*** Documentation
#+begin_src emacs-lisp
  (use-package dash-docs
    :ensure t)
#+end_src

** DONE Load private part
CLOSED: [2021-01-03 Sun 11:11]
Some parts can't be totally hidden using the =my:auth-source-get-*= helpers.
These sensitive configuration parts are store in a dedicated file (identified by the variable =privade-file=) which is loaded here.

#+begin_src emacs-lisp
  (defvar private-file (concat user-emacs-directory "private-variables.el")
    "Path to the file which stores my configuration.")

  (when (file-exists-p private-file)
    (load private-file))
#+end_src

** DONE Notifications [100%]
CLOSED: [2021-01-03 Sun 11:14]
Emacs is my entry point for almost everything.
Therefore, it is also useful to have the notifications handled directly in Emacs.
To do so, I rely on the couple sauron/alert.
Alert is the entry point for raising notifications while sauron is used to log the notifications.

This combination allows me to use the modeline as an indicator of the priority of the notification.
By doing so, I can be aware of a notification but choose to ignore it if I am focusing on something else.
If another notification of at most the same priority is raised, it will be logged but there won't be any visible cue.
However, if a notification of an higher priority is raised, the color of the modeline will be updated to reflect the priority of the notification.

*** DONE Sauron
CLOSED: [2021-01-03 Sun 11:13]
Sauron is the pivot of the notification system.
However, I need to use my own fork for two reasons:
the upstream has some priority issues with ERC; I would like to ignore some events emitted by the *org-agenda*.

#+begin_src emacs-lisp
  (use-package alert
    :tags '("CORE" "NOTIFICATION"))

  (use-package sauron
    :straight (sauron :type git :host github :repo "djcb/sauron"
                      :fork (:host github
                                   :repo "seblemaguer/sauron"
                                   :branch "functional"))
    :tags '("CORE" "NOTIFICATION")
    :commands (sauron-start-hidden sauron-add-event)

    :config
    (defun sauron-keep-priority (msg props)
      "Function to define which event should keep the same priority
    and not be raised even if it is recent. The criterion is based on
    MSG and PROPS."
      (or
       (string= (plist-get props :sender) "root")
       (string= (plist-get props :event) "join")
       (string= (plist-get props :event) "quit")))

    (setq sauron-separate-frame nil ;; The notification is on the same window ?
          sauron-sticky-frame t
          sauron-max-line-length nil ;; No max. length for the line
          sauron-modules '(sauron-org sauron-appt) ;; reduced the default modules
          sauron-column-alist '(( timestamp  .  20)
                                ( origin     .  20)
                                ( priority   .   4)
                                ( message    . nil))
          sauron-org-exclude-todo-states (list "IN PROCESS" "EXEC-STARTED" "PAUSED" "DELEGATED" "WAITING")
          sauron-prio-org-minutes-left-list '((15 4))
          sauron-insensitivity-handler 'sauron-keep-priority))
#+end_src

*** DONE Sauron/Alert/Modeline integration
CLOSED: [2021-01-03 Sun 11:14]
By using my plugin =sauron-mode-line=, I link Alert and Sauron.
By this way, all the Alert notifications are automatically transmitted to Sauron.
If a Sauron event is raised, it is transmitted to Alert to adapt the modeline bar.
This plugin is in charge to managing the communication and avoid any cycle.

#+NAME: sauron-keybindings
| Key    | Function                          | Description |
|--------+-----------------------------------+-------------|
| <f7>   | sauron-mode-line-toggle-hide-show |             |
| C-<f7> | sauron-mode-line-clear            |             |

#+begin_src emacs-lisp
  (use-package sauron-mode-line
    :straight nil
    :load-path default-plugin-dir
    :tags '("CORE" "NOTIFICATION")
    :custom
    (sauron-event-added-functions 'sauron-mode-line-notifier-from-sauron)

    :commands (sauron-mode-line-start-hidden)
    :hook (after-init . sauron-mode-line-start-hidden)
    :bind (
      <<keybindings-gen(table=sauron-keybindings)>>
     ))
#+end_src

** DONE Documentation [100%]
Emacs is dense and provides a lot of features.
Too many to remember everything.
This part is there to help to navigate the documentation more easily.

*** DONE Key bindinds
CLOSED: [2021-01-03 Sun 11:18]
=helm-descbinds= is a useful package which provides a way to list all the shortcuts available in the current buffer.

#+NAME: helm-descbinds-entry-keybindings
| Key   | Function       | Description |
|-------+----------------+-------------|
| C-h b | helm-descbinds |             |

#+begin_src emacs-lisp
  (use-package helm-descbinds
    :tags '("CORE" "DOCUMENTATION")
    :commands (helm-descbinds)
    :bind (
      <<keybindings-gen(table=helm-descbinds-entry-keybindings)>>
    ))
#+end_src

*** DONE Helpful
CLOSED: [2021-01-03 Sun 11:19]
=helpful= is a powerful package to access to the documentation of a key/symbol/...
It also supports references and back-references.
I am using it as the entry point of any documentation I want to access.

#+NAME: help-keybindings
| Key   | Function         | Description |
|-------+------------------+-------------|
| C-h k | helpful-key      |             |
| C-h a | helpful-symbol   |             |
| C-h h | helpful-at-point |             |

#+begin_src emacs-lisp
  (use-package helpful
    :tags '("CORE" "DOCUMENTATION")
    :commands (helpful-key helpful-symbol helpful-at-point)
    :bind (
      <<keybindings-gen(table=help-keybindings)>>
     ))
#+end_src

*** DONE Man
CLOSED: [2021-03-01 Mon 09:28]
Man is critical for document on unix.
I simply configured emacs to add my own environment man directories.

#+begin_src emacs-lisp
  (use-package man
    :tags '("CORE" "DOCUMENTATION")
    :config
    (setq Man-notify-method 'pushy
          woman-manpath `("/usr/share/man/" "/usr/local/man/" ;; System
                          ,(format "%s/local/man" user-emacs-directory) ;; Private environment
                          ,(format "~/environment/local/share/man")
                          )))
#+end_src

*** DONE Dash/Docsets
CLOSED: [2022-07-26 Tue 09:48]
Dash (https://www.kapeli.com/dash) provides a set of full documentation to download.
=consult-dash= provides an easy way to query them.

#+NAME: consult-dash-entry-keybindings
| Key   | Functon      | Description |
|-------+--------------+-------------|
| M-s d | consult-dash |             |

#+begin_src emacs-lisp
  (use-package consult-dash
    :tags '("CORE" "DOCUMENTATION" "COMPLETION")
    :bind (
      <<keybindings-gen(table=consult-dash-entry-keybindings)>>
    )

    :custom
    (dash-docs-docsets-path "~/shared/docset")
    (dash-docs-browser-func 'eww)

    :config
    (consult-customize consult-dash :initial (thing-at-point 'symbol))
    (when (functionp 'consult-dash)
      (setq-local consult-dash-docsets '("Python 3" "Pandas" "NumPy" "SciPy" "Matplotlib"))))
#+end_src

*** DONE Recoll
CLOSED: [2022-10-13 Thu 18:11]
=consult-recoll= provides an interface to =recoll= which is handy to "grep" from a db of documents.

#+NAME: consult-recoll-entry-keybindings
| Key   | Functon        | Description |
|-------+----------------+-------------|
| M-g t | consult-recoll |             |

#+begin_src emacs-lisp
  (when (executable-find "recoll")
    (use-package consult-recoll
      :tags '("CORE" "DOCUMENTATION" "COMPLETION")
      :bind (
        <<keybindings-gen(table=consult-recoll-entry-keybindings)>>
      )))
#+end_src

And the associated configuration is:

#+begin_src conf :tangle ~/.recoll/recoll.conf :mkdirp yes
  # The system-wide configuration files for recoll are located in:
  #   /usr/share/recoll/examples

  topdirs = ~
  skippedPaths = ~/.cache ~/environment ~/tmp/music /media ~/configuration/emacs.d
  skippedNames+ = .* melpa docset *.wav *.flac
  noContentSuffixes+ =
#+end_src

** DONE Buffer listing
CLOSED: [2021-01-03 Sun 11:24]
Buffer listing is the fundamental navigation tool.
After playing with =ibuffer= and other helpers, I settled using =bufler=.
This choice has been made due its the simplicity and its recursive nature.
=bufler= is used in conjunction with =prism= is assumed to be loaded later.

#+NAME: buffler-entry-keybindings
| Key     | Functon | Description |
|---------+---------+-------------|
| C-x C-b | bufler  |             |

#+begin_src emacs-lisp
  (use-package bufler
    :tags '("CORE" "BUFFER")
    :bind (
      <<keybindings-gen(table=buffler-entry-keybindings)>>
    )

    :custom
    (bufler-reverse nil)
    (bufler-face-prefix "prism-level-")
    (bufler-vc-state t)
    (bufler-list-group-separators '((0 . "\n")))
    (bufler-initial-face-depth 1)
    (bufler-filter-buffer-modes nil)
    (bufler-groups (bufler-defgroups
                     (group (group-or "Help/Info"
                                      (mode-match "*Help*" "^help\\(ful\\)?-.*")
                                      (mode-match "*Info*" (rx bos "info-"))
                                      (mode-match "*Apropos*" (rx bos "apropos-"))))

                     (group (group-or "Mail"
                                      (mode-match "*Mu4e*" (rx bos "mu4e-"))))

                     (group (group-or "Chatty"
                                      (mode-match "IRC" (rx bos "circe-"))
                                      (name-match "Slack" (rx bos "*Slack"))
                                      (mode-match "Telegram" (rx bos "telega-"))
                                      (mode-match "Matrix" (rx bos "ement-")))

                            (group (mode-match "IRC" (rx bos "circe"))
                                   (group (name-match "Query" (rx bos "circe-query")))
                                   (group (mode-match "Channels" (rx bos "circe-channel")))
                                   (group (name-match "Servers" (rx bos "circe-server"))))

                            (group (mode-match "Telegram" (rx bos "telega"))
                                   (group (mode-match "Channels" (rx bos "telega-chat")))
                                   (group (group-not "Other" (mode-match "unknown" (rx bos "telega-chat")))))

                            (group (name-match "Slack" (rx bos "*Slack"))
                                   (group (group-not "Message" (name-match "Logging" "\\*Slack[^-]*Log -")))
                                   (group (name-match "Logging" "*Slack[^-]*Log -")))


                            (group (mode-match "Matrix" (rx bos "ement-"))))

                     (group (mode-match "EMMS" (rx bos "emms-")))

                     (group (group-or "RSS"
                                      (mode-match "*Elfeed*" (rx bos "elfeed-"))
                                      (name-match "*Elfeed*" (rx bos "*elfeed"))
                                      (name-match "rss.org" (rx bos "rss.org"))))

                     (group (group-or "Todo"
                                      (name-match "Todo" "todo.org")
                                      (name-match "Shopping List" "shopping_list.org")))

                     ;; Subgroup collecting all special buffers (i.e. ones that are not
                     ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
                     ;; through to other groups, so they end up grouped with their project buffers).
                     (group (group-and "*Special*"
                                       (lambda (buffer)
                                         (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                                              buffer)
                                                     (funcall (mode-match "Dired" (rx bos "dired"))
                                                              buffer)
                                                     (funcall (auto-file) buffer))
                                           "*Special*")))

                            ;; Subgroup collecting these "special special" buffers separately for convenience.
                            (group (name-match "**Special**"
                                               (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace") "*")))

                            ;; For my- calendars
                            (group (name-match "*Calendar*" "^[*]?[Cc]alendar.*$"))

                            ;; Package management
                            (group (name-match "*Packages*" (rx bos (or "*Paradox" "*Packages*"))))

                            ;; Processes in background
                            (group (name-match "*Prodigy*" (rx bos "*prodigy-")))

                            ;; Subgroup collecting all other Magit buffers, grouped by directory.
                            (group (mode-match "*Magit* (non-status)" (rx bos (or "magit" "forge") "-"))
                                   (auto-directory))

                            ;; Subgroup for Helm buffers.
                            (mode-match "*Helm*" (rx bos "helm-"))

                            ;; Remaining special buffers are grouped automatically by mode.
                            (auto-mode))

                     ;; Subgroup collecting org-roam related buffers
                     (group
                      (dir (if (bound-and-true-p cloud-org-root-dir)
                               cloud-org-root-dir
                             "~/org")))

                     ;; Subgroup collecting buffers per projects
                     (group (group-and "*Projectile*"
                                       (lambda (buffer)
                                         (unless (funcall (lambda (buf)
                                                            (with-current-buffer buf
                                                              (string= (projectile-project-name) "-")))
                                                          buffer)
                                           "*Projectile*")))

                            ;; Subgroup collecting buffers in a projectile project.
                            (auto-projectile)
                            (auto-mode))

                     ;; Subgroup collecting buffers in a projectile project.
                     (group
                      (auto-tramp)
                      (auto-mode))

                     ;; Subgroup collecting buffers in a version-control project,
                     ;; grouping them by directory.
                     (auto-mode)
                     (auto-directory))))
#+end_src

** DONE Minibuffer
CLOSED: [2021-01-03 Sun 11:24]
Minibuffer configuration part. Nothing really outstanding, just the classical stuff.

#+begin_src emacs-lisp
  (use-package minibuffer
    :straight nil
    :tags '("CORE" "MINIBUFFER")
    ;; :hook
    ;; (eval-expression-minibuffer-setup .  #'eldoc-mode)
    :config
    (setq read-file-name-completion-ignore-case t
          completion-ignore-case t
          resize-mini-windows t)

    (file-name-shadow-mode 1))
#+end_src

** DONE Large files
CLOSED: [2021-01-03 Sun 11:28]
Large files are difficult to handle properly in emacs.
The best way is to use =vlf=.
However, the entry point is actually =vlf-setup=.
This leads to ensuring the package =vlf= with the use-package header defined to be =vlf-setup=

#+begin_src emacs-lisp
  (use-package vlf-setup
    :straight  vlf
    :tags '("CORE")
    :init (setq vlf-application 'dont-ask))
#+end_src

** DONE Navigation
CLOSED: [2021-03-01 Mon 09:27]
To have a better scrolling/navigation, I rely on two packages =fast-scroll and =goto-last-point=.
=fast-scroll= disables some hooks while scrolling and therefore makes it smoother.
=goto-last-point= enables me to go back to the position before the move happened.

#+NAME: goto-last-point-entry-keybindings
| Key | Functon         | Description |
|-----+-----------------+-------------|
| C-< | goto-last-point |             |

#+begin_src emacs-lisp
  (use-package fast-scroll
    :tags '("CORE" "NAVIGATION")
    :hook
    (fast-scroll-start      . (lambda () (flycheck-mode -1)))
    (fast-scroll-end        . (lambda () (flycheck-mode 1)))

    :config
    (fast-scroll-config)
    (fast-scroll-mode 1))

  (use-package goto-last-point
    ;; NOTE: the original repo is a pain to access with ssh, using the emacsmirror
    :straight (goto-last-point :type git :host github :repo "emacsmirror/goto-last-point")
    :tags '("CORE" "NAVIGATION")
    :hook (after-init . goto-last-point-mode)
    :bind (
      <<keybindings-gen(table=goto-last-point-entry-keybindings)>>
    ))
#+end_src

* DONE Encryption part
CLOSED: [2023-01-01 Sun 12:57]
For the encryptication part, I prefer to have everything in emacs directly.
Therefore, I defined the =pinentry-mode= for both EPGA and EPA to =loopback=.

#+begin_src emacs-lisp
  (use-package pinentry
    :tags '("CORE" "ENCRYPTION")
    :custom
    (epg-pinentry-mode 'loopback)
    :config
    (pinentry-start))

  (use-package epa-file
    :straight nil
    :tags '("CORE" "ENCRYPTION")
    :custom
    (epa-pinentry-mode 'loopback)
    :config
    (epa-file-enable))

  (use-package org-crypt
    :straight nil
    :tags '("CORE" "ENCRYPTION")
    :after org
    :config
    (org-crypt-use-before-save-magic))
#+end_src

* DONE Session [100%]
As I am using emacs as a daemon/client combination,
my daily routine consists of opening emacs at the beginning of work and switching it off on the evening.
Therefore it is difficult to track what needs to be remembered.
This section provides helpers which automatises key part to make the transition between two sessions smoother.

** DONE Recent files
CLOSED: [2021-01-03 Sun 11:31]
Opening recent files is always an easy and fast shortcut. Some files should be ignored though. That
leads to this configuration

#+begin_src emacs-lisp
  (use-package recentf
    :tags '("CORE" "SESSION" "RECENT")
    :hook (after-init . recentf-mode)
    :custom
    (recentf-max-saved-items 100)
    (recentf-max-menu-items 100)

    :config

    ;; Ignore
    (add-to-list 'recentf-exclude "^/\\(?:ssh\\|su\\|sudo\\)?:")

    ;; Emacs
    (add-to-list 'recentf-exclude "~/.orhc-bibtex-cache")
    (add-to-list 'recentf-exclude "~/configuration/emacs\\.d/.*")
    (add-to-list 'recentf-exclude "~/\\.emacs\\.d/.*")

    ;;
    (add-to-list 'recentf-exclude "~/\\.authinfo.gpg")

    ;; elfeed
    (add-to-list 'recentf-exclude "~/\\.elfeed/.*")

    ;; Org/todo/calendars
    (add-to-list 'recentf-exclude ".*todo.org")
    (add-to-list 'recentf-exclude "~/.emacs.d/calendars/.*")

    ;; Org-roam or accessible via org-roam
    (add-to-list 'recentf-exclude (concat cloud-org-root-dir ".*"))
    (add-to-list 'recentf-exclude (concat (expand-file-name cloud-org-root-dir) ".*" ))

    ;; Maildir
    (add-to-list 'recentf-exclude "~/mail/.*" ))
#+end_src

** DONE Backup/save files [100%]
This section is dedicated to deal with backups. The main logic is to exlude some specific files
(either because of they are sensitive, either because they are just results of a process). For the
other ones, I want to have an easy way to navigate in it.

*** DONE Saving bits
CLOSED: [2022-07-25 Mon 07:41]
=super-save= provides a way to save any buffers while emacs is idled.

#+begin_src emacs-lisp
  (use-package super-save
    :tags '("CORE" "SAVE")
    :custom
    (super-save-auto-save-when-idle t)

    :config
    (super-save-mode +1))
#+end_src

*** DONE Backuping bits
CLOSED: [2021-01-03 Sun 11:33]
This the global backup configuration. For that I adapted a little bit the wonderful
snapshot-timemachine package.

#+begin_src emacs-lisp
  (use-package snapshot-timemachine
    :tags '("CORE" "SESSION" "BACKUP")
    :init

    (defun my-make-backup-file-name (FILE)
      (let* ((dirname backup-directory)
             (backup-filename (concat dirname (file-truename FILE))))
        (unless (file-exists-p (file-name-directory  backup-filename))
          (make-directory (file-name-directory backup-filename) t))
        backup-filename))

    ;; Redefine find-backup-filename to avoid the "!" replacement
    (defun find-backup-file-name (fn)
      "Find a file name for a backup file FN, and suggestions for deletions.
    Value is a list whose car is the name for the backup file
    and whose cdr is a list of old versions to consider deleting now.
    If the value is nil, don't make a backup.
    Uses `backup-directory-alist' in the same way as
    `make-backup-file-name--default-function' does."
      (let ((handler (find-file-name-handler fn 'find-backup-file-name)))
        ;; Run a handler for this function so that ange-ftp can refuse to do it.
        (if handler
            (funcall handler 'find-backup-file-name fn)
          (if (or (eq version-control 'never)
                  ;; We don't support numbered backups on plain MS-DOS
                  ;; when long file names are unavailable.
                  (and (eq system-type 'ms-dos)
                       (not (msdos-long-file-names))))
              (list (make-backup-file-name fn))
            (let* ((basic-name (make-backup-file-name fn))
                   (base-versions (concat (file-name-nondirectory basic-name)
                                          ".~"))
                   (backup-extract-version-start (length base-versions))
                   (high-water-mark 0)
                   (number-to-delete 0)
                   possibilities deserve-versions-p versions)
              (condition-case ()
                  (setq possibilities (file-name-all-completions
                                       base-versions
                                       (file-name-directory basic-name))
                        versions (sort (mapcar #'backup-extract-version
                                               possibilities)
                                       #'<)
                        high-water-mark (apply 'max 0 versions)
                        deserve-versions-p (or version-control
                                               (> high-water-mark 0))
                        number-to-delete (- (length versions)
                                            kept-old-versions
                                            kept-new-versions
                                            -1))
                (file-error (setq possibilities nil)))
              (if (not deserve-versions-p)
                  (list (make-backup-file-name fn))
                (cons (format "%s.~%d~" basic-name (1+ high-water-mark))
                      (if (and (> number-to-delete 0)
                               ;; Delete nothing if there is overflow
                               ;; in the number of versions to keep.
                               (>= (+ kept-new-versions kept-old-versions -1) 0))
                          (mapcar (lambda (n)
                                    (format "%s.~%d~" basic-name n))
                                  (let ((v (nthcdr kept-old-versions versions)))
                                    (rplacd (nthcdr (1- number-to-delete) v) ())
                                    v))))))))))

    ;; Default Backup directory
    (defvar backup-directory (concat user-emacs-directory "backups/"))
    (setq backup-directory-alist `((".*" . ,backup-directory)))
    (when (not (file-exists-p backup-directory))
      (make-directory backup-directory t))
    (setq make-backup-file-name-function #'my-make-backup-file-name)
    ;; Auto-save
    (defvar auto-save-directory (concat user-emacs-directory "auto-save/"))
    (setq auto-save-file-name-transforms `((".*" ,auto-save-directory t)))
    (when (not (file-exists-p auto-save-directory))
      (make-directory auto-save-directory t))

    ;; Tramp backup
    (defvar tramp-backup-directory (concat user-emacs-directory "tramp-backups/"))
    (setq tramp-backup-directory-alist `((".*" . ,tramp-backup-directory)))

    (when (not (file-exists-p tramp-backup-directory))
      (make-directory tramp-backup-directory t))

    (setq make-backup-files t               ; backup of a file the first time it is saved.
          backup-by-copying t               ; don't clobber symlinks
          version-control t                 ; version numbers for backup files
          delete-old-versions t             ; delete excess backup files silently
          delete-by-moving-to-trash t
          kept-old-versions 6               ; oldest versions to keep when a new numbered backup is made (default: 2)
          kept-new-versions 9               ; newest versions to keep when a new numbered backup is made (default: 2)
          )

    :config

    (defun snapshot-timemachine-backup-finder (file)
      "Find snapshots of FILE in rsnapshot backups."
      (let* ((file (expand-file-name file))
             (file-dir (file-name-directory file))
             (file-base (file-name-nondirectory file))
             (backup-files (directory-files (concat backup-directory file-dir) t
                                            (format "%s.*" file-base))))
        (seq-map-indexed (lambda (backup-file index)
                           (make-snapshot :id index
                                          :name (format "%d" index)
                                          :file backup-file
                                          :date (nth 5 (file-attributes backup-file))))
                         backup-files)))

    (setq snapshot-timemachine-snapshot-finder #'snapshot-timemachine-backup-finder))
#+end_src

*** DONE Sensitive mode
CLOSED: [2021-01-03 Sun 11:33]
There are some files which are not desired to be backed up. This part goal is to setup this
"avoiding saving" spécificities.

#+begin_src emacs-lisp
  (define-minor-mode sensitive-mode
    "For sensitive files like password lists.
  It disables backup creation and auto saving.

  With no argument, this command toggles the mode.
  Non-null prefix argument turns on the mode.
  Null prefix argument turns off the mode."
    ;; The initial value.
    nil
    ;; The indicator for the mode line.
    " Sensitive"
    ;; The minor mode bindings.
    nil
    (if (symbol-value sensitive-mode)
        (progn
          ;; disable backups
          (set (make-local-variable 'backup-inhibited) t)
          ;; disable auto-save
          (if auto-save-default
              (auto-save-mode -1)))
                                          ;resort to default value of backup-inhibited
      (kill-local-variable 'backup-inhibited)
                                          ;resort to default auto save setting
      (if auto-save-default
          (auto-save-mode 1))))


  (use-package auto-minor-mode
    :tags '("CORE" "SESSION" "MINOR")
    :config
    (add-to-list 'auto-minor-mode-alist '("\\.git/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("emacs\\.d/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("emacs\\.d/emms/.*\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("Calendars/.*.org\\'" . sensitive-mode))
    (add-to-list 'auto-minor-mode-alist '("\\.gpg\\'" . sensitive-mode)))
#+end_src

** DONE Reload file at saved position
CLOSED: [2021-01-03 Sun 11:35]
:PROPERTIES:
:FROM:     https://github.com/munen/emacs.d
:END:
When a file is large, it is easier to restart from the exact position where we stopped.
To do so, I am using the package =saveplace=

#+begin_src emacs-lisp
  (use-package saveplace
    :tags '("CORE" "SESSION")
    :init
    (setq save-place-file (format "%s/saveplace" user-emacs-directory))
    :config
    (save-place-mode 1))
#+end_src

* DONE Org-mode [100%]
=Org-mode= is the core of how I am organizing tasks, writing documents, ...
While it is mainly a programming/writing language, it involves too many subparts and, therefore, has its own section.

** DONE Global
CLOSED: [2021-01-03 Sun 12:42]
This section defines the global configuration for =org-mode=.
First, it actually relies on =org-contrib=, especially for the bibtex support.
Then, it defines the fundamentals of the GTD pipeline by adding some TODO keywords:
  - =CANCELLED= and =POSTPONED= for task which can't be done for whatever reason;
  - =WAITING= for tasks which are blocked by an external event;
  - =PAUSED= for tasks which are manually put to sleep for whatever reason;
  - =EXEC-STARTED= for tasks which are running but doesn't requires any manual operation (i.e. process on the cluster)
  - =DELEGATED= for tasks which are delegated to someone else

Some additional keywords are also defined to deal with more specific events:
  - =RELEASE= points to an album to be released
  - =MAIL= points to an email to be replied to
  - =TO-READ= points to an article, ... to review

Finally, some keywords are there for note purposes:
  - =NOTE= points to a note to be saved
  - =EVENT= points to an event to happen
  - =MANDATORY= points to an event which I have to do but it is recurrent!

#+NAME: org-effort-keybindings
| Key       | Functon           | Description |
|-----------+-------------------+-------------|
| C-c C-x e | my-org-set-effort |             |

#+begin_src emacs-lisp
  (use-package org
    :straight org-contrib
    :tags '("ORG")
    :hook
    (org-after-todo-statistics . org-summary-todo)

    :bind (:map org-mode-map (
      <<keybindings-gen(table=org-effort-keybindings)>>
    ))

    :config

    ;; Global
    (setq org-startup-indented t
          org-startup-folded 'nofold
          org-image-actual-width nil
          org-enforce-todo-dependencies t
          org-cycle-separator-lines 2
          org-blank-before-new-entry '((heading) (plain-list-item . auto))
          org-insert-heading-respect-content nil
          org-reverse-note-order nil
          org-show-following-heading t
          org-show-hierarchy-above t
          org-show-siblings '((default))
          org-id-method 'uuidgen
          org-deadline-warning-days 30
          org-table-export-default-format "orgtbl-to-csv"
          org-src-window-setup 'other-window
          org-clone-delete-id t
          org-cycle-include-plain-lists t
          org-src-fontify-natively t
          org-src-tab-acts-natively t
          org-hide-emphasis-markers t
          org-global-properties '(("Effort_ALL" . "0:15 0:30 0:45 1:00 1:30 2:00 3:00 4:00 5:00 6:00 0:00")
                                  ("STYLE_ALL" . "habit"))

          ;; Todo part
          org-todo-keywords '(;; Baseline sequence
                              (sequence "TODO(t)" "DELEGATED(e)" "EXEC-STARTED(S)" "IN PROCESS(s)"  "MEETING(M)" "WAITING(w)" "PAUSED(p)" "|" "DONE(d)" "CANCELLED(c@/!)" "POSTPONED(o@/!)")

                              ;; Specific "to complete"
                              (sequence "TO-READ(r)" "RELEASE(R)" "MAIL(m)" "|")

                              ;; Note information
                              (sequence "|" "NOTE(N)" "EVENT(E)" "MANDATORY(M)"))

          org-todo-state-tags-triggers '(("CANCELLED" ("CANCELLED" . t))
                                         ("POSTPONED" ("POSTPONED" . t)))

          ;; Priority definition
          org-highest-priority ?A
          org-lowest-priority ?E
          org-default-priority ?C

          ;; Archiving
          org-archive-mark-done t
          org-log-done 'time

          ;; Refiling
          org-refile-targets '((nil . (:maxlevel . 6))
                               (org-agenda-files . (:maxlevel . 6)))
          org-completion-use-ido nil
          org-refile-use-outline-path 'file
          org-outline-path-complete-in-steps nil
          org-refile-allow-creating-parent-nodes 'confirm)

    (defun org-schedule-effort ()
      "Setup schedule time from effort."
      (interactive)
      (save-excursion
        (org-back-to-heading t)
        (let* ((element (org-element-at-point))
               (effort (org-element-property :EFFORT element))
               (scheduled (org-element-property :scheduled element))
               (ts-year-start (org-element-property :year-start scheduled))
               (ts-month-start (org-element-property :month-start scheduled))
               (ts-day-start (org-element-property :day-start scheduled))
               (ts-hour-start (org-element-property :hour-start scheduled))
               (ts-minute-start (org-element-property :minute-start scheduled)) )
          (org-schedule nil (concat
                             (format "%s" ts-year-start)
                             "-"
                             (if (< ts-month-start 10)
                                 (concat "0" (format "%s" ts-month-start))
                               (format "%s" ts-month-start))
                             "-"
                             (if (< ts-day-start 10)
                                 (concat "0" (format "%s" ts-day-start))
                               (format "%s" ts-day-start))
                             " "
                             (if (< ts-hour-start 10)
                                 (concat "0" (format "%s" ts-hour-start))
                               (format "%s" ts-hour-start))
                             ":"
                             (if (< ts-minute-start 10)
                                 (concat "0" (format "%s" ts-minute-start))
                               (format "%s" ts-minute-start))
                             "+"
                             effort))
          )))

    (defun my-org-set-effort ()
      "Wrapper around `org-set-effort' and `org-schedule-effort' to
   enforce the scheduling of the effort."
      (interactive)
      (org-set-effort)

      (save-excursion
        (org-back-to-heading t)
        (let* ((element (org-element-at-point))
               (scheduled (org-element-property :scheduled element))
               (ts-hour-start (org-element-property :hour-start scheduled))
               (ts-minute-start (org-element-property :minute-start scheduled)))
          (when (and ts-hour-start ts-minute-start)
            (org-schedule-effort)))))

    ;; Enforce done marking to propagate
    (defun org-summary-todo (n-done n-not-done)
      "Switch entry to DONE when all subentries are done, to TODO otherwise."
      (let (org-log-done org-log-states)   ; turn off logging
        (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

    (defun html2org-clipboard ()
      "Convert clipboard contents from HTML to Org and then paste (yank)."
      (interactive)
      (kill-new
       (shell-command-to-string "xclip -o -t text/html | pandoc -f html -t json | pandoc -f json -t org | sed 's/ / /g'"))
      (yank))

    ;; Edition
    (setq org-list-allow-alphabetical t
          org-highlight-latex-and-related '(latex)
          org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"
          org-babel-results-keyword "results" ;; Display images directly in the buffer
          org-confirm-babel-evaluate nil
          org-startup-with-inline-images t
          org-return-follows-link  t))
#+end_src

** DONE Source [100%]
CLOSED: [2021-01-03 Sun 13:59]
The source visualisation of org files can be pretty raw.
This section provides configurations to help the navigation and the visualisation of such files.

*** DONE Pretty bullets
CLOSED: [2021-01-03 Sun 12:55]
The key problem in my opinion is how are visualize the headings.
=org-superstar= provides a clearer indentation and visualisation of such headings.
This is fundamental to have an easy navigation in such files which can be really large (see the current one!).

#+begin_src emacs-lisp
  (use-package org-superstar
    :tags '("ORG" "VISUAL")
    :hook (org-mode . org-superstar-mode)
    :config
    (setq org-superstar-headline-bullets-list '("◉" "○" "▷" "✸")
          org-superstar-item-bullet-alist '((?+ . ?•) (?* . ?➤) (?- . ?–))))
#+end_src

*** DONE Babel
CLOSED: [2021-01-03 Sun 13:10]
Babel is the key feature for litterate programming in =org-mode=.
This section provides the configuration for babel by first configuring jupyter.

#+begin_src emacs-lisp
  (use-package company-org-block
    :tags '("ORG" "COMPLETION")
    :custom
    (company-org-block-edit-style 'auto) ;; 'auto, 'prompt, or 'inline

    :hook
    (org-mode . company-org-block-hook)

    :config
    (defun company-org-block-hook ()
      "Hook to add company-org-block support to org-mode."
      (make-local-variable 'company-backends)
      (setq company-backends (copy-tree company-backends))
      (set 'company-backends (append '(company-org-block) company-backends))))

  (use-package ob
    :straight org-contrib
    :tags '("ORG")
    :config

    ;; Define specific modes for specific tools
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (add-to-list 'org-src-lang-modes '("dot"      . graphviz-dot))

    ;; Define the list of languages to load
    (org-babel-do-load-languages 'org-babel-load-languages
                                 '((emacs-lisp . t)
                                   (dot        . t)
                                   (ditaa      . t)
                                   (R          . t)
                                   (ruby       . t)
                                   (gnuplot    . t)
                                   (clojure    . t)
                                   (shell      . t)
                                   (ledger     . t)
                                   (org        . t)
                                   (plantuml   . t)
                                   (latex      . t)
                                   (python     . t)))          ; must be last

    ;; Predefine header considering
    (setq org-babel-default-header-args:sh      '((:results . "output replace"))
          org-babel-default-header-args:bash    '((:results . "output replace"))
          org-babel-default-header-args:shell   '((:results . "output replace"))
          org-babel-default-header-args:python  '((:async . "yes")
                                                  (:session . "py")))

    ;; Define pathes for some tools
    (setq org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar"
          org-ditaa-jar-path "/usr/share/ditaa/ditaa.jar"))
#+end_src

*** DONE ID Generation
CLOSED: [2021-01-03 Sun 13:30]
I don't like how identifier are hashed in org-mode.
To fix this, =org-unique-id= aims to provide an equivalent to the "auctex/reftex" label generation module but for org-mode.

#+begin_src emacs-lisp
  (use-package org-unique-id
    :after org
    :straight (org-unique-id :type git
                             :host github
                             :repo "Phundrak/org-unique-id")
    :init (add-hook 'before-save-hook #'org-unique-id-maybe))
#+end_src

*** DONE Checklist
CLOSED: [2021-01-03 Sun 13:55]
I am using checklist regularly.
Consequently, adding its support in org-mode is a big advantage.
To do so, I am relying the package =org-checklist= which is provided by =org-contrib=.

#+BEGIN_SRC emacs-lisp
  (use-package org-checklist
    :straight org-contrib
    :tags '("ORG"))
#+END_SRC

*** DONE Tranclusion
CLOSED: [2022-04-12 Tue 12:22]
=org-transclusion= provide a fancy interface to include portion of other files into an org file.

#+begin_src emacs-lisp
  (use-package org-transclusion
    :after org)
#+end_src

*** DONE Helpers
CLOSED: [2021-02-27 Sat 08:38]
I am using =org-menu= to provide a helper menu to edit org files.
For whatever reason, it is required to *explicitly* configure =transient=.

#+NAME: org-menu-keybindings
| Key   | Functon  | Description |
|-------+----------+-------------|
| C-c m | org-menu |             |

#+BEGIN_SRC emacs-lisp
  (use-package org-menu
    :straight (org-menu :type git :host github :repo "sheijk/org-menu")
    :tags '("ORG")
    :bind (:map org-mode-map (
      <<keybindings-gen(table=org-menu-keybindings)>>
    )))
#+END_SRC

** DONE Export [100%]
CLOSED: [2021-01-03 Sun 13:47]
This section focuses on configuring the export of org files to some document format.

*** DONE Global
CLOSED: [2021-07-19 Mon 09:24]
This part contains some extra configurations which allows to write clean org documents while still having an efficient rendering.

#+begin_src emacs-lisp
  (use-package ox-extra
    :straight org-contrib
    :tags '("ORG")
    :after ox
    :config
    (ox-extras-activate '(ignore-headlines latex-header-blocks)))
#+end_src

*** DONE HTML
CLOSED: [2021-01-03 Sun 13:44]
In this section, we configure the export for HTML main files and for presentation using =reveal.js=.
Both configurations relies on =htmlize= to deal with the coloring part.
We also defines additional link to support audios and videos.

#+begin_src emacs-lisp
  (use-package htmlize
    :tags '("ORG"))

  (use-package ox-html
    :straight org-contrib
    :after ox
    :requires (htmlize)
    :tags '("ORG")
    :init
    (defun endless/export-audio-link (path desc format)
      "Export org audio links to hmtl."
      (cl-case format
        (html (format "<audio src=\"%s\" controls>%s</audio>" path (or desc "")))))

    (defun endless/export-video-link (path desc format)
      "Export org video links to hmtl."
      (cl-case format
        (html (format "<video controls src=\"%s\">%s</video>" path (or desc "")))))

    :config
    (setq org-html-xml-declaration '(("html" . "")
                                     ("was-html" . "<?xml version=\"1.0\" encoding=\"%s\"?>")
                                     ("php" . "<?php echo \"<?xml version=\\\"1.0\\\" encoding=\\\"%s\\\" ?>\"; ?>"))
          org-export-html-inline-images t
          org-export-with-sub-superscripts nil
          org-export-html-style-extra "<link rel=\"stylesheet\" href=\"org.css\" type=\"text/css\" />"
          org-export-html-style-include-default nil
          org-export-htmlize-output-type 'css ; Do not generate internal css formatting for HTML exports
          )

    (org-link-set-parameters "video" :export #'endless/export-video-link)
    (org-link-set-parameters "audio" :export #'endless/export-audio-link)

    (add-to-list 'org-file-apps '("\\.x?html?\\'" . "/usr/bin/brave %s")))

  (use-package org-re-reveal
    :tags '("ORG"))

  (use-package org-re-reveal-citeproc
    :tags '("ORG")
    :init
    (add-to-list 'org-export-filter-paragraph-functions
                 #'org-re-reveal-citeproc-filter-cite))
#+end_src

*** DONE Latex
CLOSED: [2021-01-03 Sun 13:46]
In this section, the export for latex and beamer are configured.
The key part is that we are using minted to deal with the source.
Therefore, we have to modify the call to the =latexmk= command (which is therefore required).

#+begin_src emacs-lisp
  (use-package ox-latex
    :straight org-contrib
    :tags '("ORG")
    :after ox
    :config
    (setq org-latex-listings t
          org-export-with-LaTeX-fragments t
          org-latex-pdf-process (list "latexmk -shell-escape -bibtex -f -pdf %f")))

  (use-package ox-beamer
    :straight org-contrib
    :tags '("ORG")
    :after ox
    :config
    (defun my-beamer-bold (contents backend info)
      (when (eq backend 'beamer)
        (replace-regexp-in-string "\\`\\\\[A-Za-z0-9]+" "\\\\textbf" contents)))
    (add-to-list 'org-export-filter-bold-functions 'my-beamer-bold))

  (use-package ox-bibtex
    :straight org-contrib
    :tags '("ORG")
    :after ox
    :defer t)
#+end_src

*** DONE Markdown
CLOSED: [2021-01-03 Sun 13:47]
I am using mainly the Github markdown format.
Therefore, I use the package =ox-gfm=

#+begin_src emacs-lisp
  (use-package ox-gfm
      :tags '("ORG")
      :after ox)
#+end_src

** DONE Agenda [100%]
In this section, I configure the agenda part of org-mode.
It is my main source of visualizing the todo tasks.
I rely on the baseline =org-agenda= package and on =org-super-agenda= for a better visualisation.

*** DONE Baseline configuration
CLOSED: [2021-01-03 Sun 14:21]
The baseline configuration is fairly standard.
The only important bits are:
  - the todo file is set to =~/pCloudDrive/org/todo/todo.org=
  - some icons are associated to some categories

#+NAME: org-agenda-entry-keybindings
| Key   | Functon    | Description |
|-------+------------+-------------|
| <f12> | org-agenda |             |

#+NAME: org-agenda-hydra-entry-keybindings
| Key | Function               | Description |
|-----+------------------------+-------------|
| v   | org-agenda-hydra/body  |             |

#+NAME: org-agenda-mode-hydra-keybindings
| Key | Function                  | label     | Description |
|-----+---------------------------+-----------+-------------|
| d   | org-agenda-day-view       | Day       |             |
| w   | org-agenda-week-view      | Week      |             |
| t   | org-agenda-fortnight-view | Fortnight |             |
| m   | org-agenda-month-view     | Month     |             |
| y   | org-agenda-year-view      | Year      |             |


#+begin_src emacs-lisp
  (use-package org-agenda
    :straight org-contrib
    :tags '("ORG" "USER" "CONNECTED")
    :if (file-directory-p cloud-org-root-dir)
    :commands (org-agenda)
    :init
    (defun color-org-header (tag backcolor)
      "Highlight the line in org-agenda in the given BACKCOLOR if TAG is present on the line."
      (interactive)
      (goto-char (point-min))
      (while (re-search-forward tag nil t)
        (add-text-properties (line-beginning-position) (+ (line-end-position) 1)
                             `(face (:background, backcolor)))))

    ;; Agenda is used at startup, it is better
    (setq initial-buffer-choice '(lambda () (get-buffer org-agenda-buffer-name)))

    :mode-hydra
    (org-agenda-mode
     (:color blue)
     ("Time window" (
       <<hydra-keybindings-gen(table=org-agenda-mode-hydra-keybindings)>>
     )))

    :bind (
      <<keybindings-gen(table=org-agenda-entry-keybindings)>>

      :map org-agenda-mode-map (
         <<keybindings-gen(table=org-agenda-entry-keybindings)>>
      )
    )

    :config

    ;; Baseline configuration
    (setq org-deadline-warning-days 7
          org-agenda-include-diary t
          org-agenda-start-with-log-mode t
          org-timeline-show-empty-dates t
          org-agenda-span 'day
          org-agenda-prefix-format '((agenda . " %i %-15:c%?-15t% s")
                                     (todo . " %i %-15:c")
                                     (tags . " %i %-15:c")
                                     (search . " %i %-15:c"))
          org-agenda-overriding-columns-format "%TODO %7EFFORT %10CLOCKSUM %PRIORITY     %100ITEM 100%TAGS"
          org-agenda-custom-commands '(("c" . "My Custom Agendas")
                                       ("cu" "Unscheduled TODO"
                                        ((todo ""
                                               ((org-agenda-overriding-header "\nUnscheduled TODO")
                                                (org-agenda-skip-function
                                                 '(org-agenda-skip-entry-if
                                                   'scheduled
                                                   'regexp ".*\[[0-9]*%\]\\([ ]*[:].*[:]\\)\?$")))))
                                        nil
                                        nil)
                                       ("j" "Planning Table"
                                        agenda ""
                                        ((org-agenda-overriding-header "")
                                         (org-agenda-span 1)
                                         (org-agenda-use-time-grid nil)
                                         (org-agenda-view-columns-initially t)
                                         (org-columns-default-format-for-agenda
                                          "%11AGENDA_TIME(When) %4TODO(Type) %40ITEM(What) %5AGENDA_DURATION(Takes){:}")
                                         ;; do not show wardings, overdue and overscheduled
                                         (org-scheduled-past-days 0)
                                         (org-deadline-past-days 0)
                                         (org-deadline-warning-days 0)

                                         ;; skip finished entries
                                         (org-agenda-skip-deadline-if-done t)
                                         (org-agenda-skip-scheduled-if-done t)))
                                       )

          ;; Define the diary comment syntax as elisp
          diary-comment-start ";;"
          diary-comment-end ""))
#+end_src

*** DONE Super agenda
CLOSED: [2021-01-03 Sun 14:22]
In this section, I confugre =org-super-agenda=.
As I have my own way of being organized, I redefined completely the groups.

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :straight (org-super-agenda :type git :host github :repo "alphapapa/org-super-agenda"
                                :fork (:host github
                                             :repo "seblemaguer/org-super-agenda"
                                             :branch "fix_diary"))
    :tags '("ORG")
    :config

    ;; Create groups
    (setq org-super-agenda-groups
          '((:name "Today"  ; Optionally specify section name
                   :time-grid t)  ; Items that appear on the time grid

            ;; CD part
            (:discard (:and (:category "Release" :tag "noexport")))
            (:discard (:and (:category "Release" :todo "CANCELLED")))
            (:name "Today's releases"
                   :and (:todo "RELEASE" :date today)
                   :order 8)

            (:name "Releases"
                   :and (:category "Release" :not (:todo "WAITING"))
                   :order 8)

            (:name "Ordered Releases"
                   :and (:category "Release" :todo "WAITING")
                   :order 9)


            ;; Important thing
            (:name "Important"
                   :and (:priority "A" :date t :todo "TODO")
                   :order 2)

            ;; Some standby thingy
            (:name "In process"
                   :todo ("PAUSED" "EXEC-STARTED")
                   :order 7)

            ;; Deadlines
            (:name "Overdue"
                   :deadline past
                   :order 3)
            (:name "Due Today"
                   :deadline today
                   :order 3)
            (:name "Due Soon"
                   :deadline future
                   :order 4)

            ;; Schedule
            (:name "Scheduled Today"
                   :and (:scheduled today  :not (:todo "PAUSED") :not (:todo "WAITING") :not (:todo "RELEASE"))
                   :order 1)
            (:name "Scheduled, past but opened"
                   :and (:scheduled past   :not (:todo "PAUSED") :not (:todo "WAITING") :not (:todo "RELEASE"))
                   :order 5)
            (:name "Scheduled in the next couple of days"
                   :and (:scheduled future :not (:todo "PAUSED") :not (:todo "WAITING") :not (:todo "RELEASE"))
                   :order 6)
            ))

    ;; Activate mode
    (org-super-agenda-mode t)
    (org-agenda nil "a"))
#+end_src

*** DONE Sidebar
CLOSED: [2022-02-04 Fri 09:10]
With =org-sidebar= I have easily access to the todos of the *current* org file.

#+begin_src emacs-lisp
  (use-package org-sidebar)
#+end_src

** DONE GTD [100%]
Getting Things Done (GTD) is my main way of dealing with tasks.
My main source of inspiration is proposed in http://doc.norang.ca/org-mode.html but I deviate from it on multiple aspects.

*** DONE Clock management
CLOSED: [2021-01-03 Sun 14:42]
:PROPERTIES:
:FROM:     https://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/
:END:
Based on Sacha Chua blog post, I use the following configuration to clock-in/clock-out.
It deviates from Sacha's blog solely on the states; as I am using my own org states.

#+NAME: org-mru-clock-bindings
| Key         | function                         | Description |
|-------------+----------------------------------+-------------|
| C-c C-x i   | org-mru-clock-in                 |             |
| C-c C-x C-j | org-mru-clock-select-recent-task |             |


#+begin_src emacs-lisp
    (use-package org-mru-clock
      :tags '("ORG")
      :bind* (
        <<keybindings-gen(table=org-mru-clock-bindings)>>
      )
      :init
      (setq org-mru-clock-how-many 100
            org-mru-clock-keep-formatting t
            org-clock-persist t)

      (defadvice org-clock-in (after sacha activate)
        "Set this task's status to 'IN PROCESS'."
        (org-todo "IN PROCESS"))

      (defun sacha/org-clock-in-if-starting ()
        "Clock in when the task is marked IN PROCESS."
        (when (member (buffer-file-name)
                      (mapcar 'file-truename org-agenda-files))
          (when (and (string= org-state "IN PROCESS")
                     (not (string= org-last-state org-state)))
            (org-clock-in))))

      (defun sacha/org-clock-out-if-waiting-or-pausing ()
        "Clock in when the task is marked STARTED."
        (when (member (buffer-file-name)
                      (mapcar 'file-truename org-agenda-files))
          (when (and (or (string= org-state "TODO")
                         (string= org-state "WAITING")
                         (string= org-state "PAUSED")
                         (string= org-state "EXEC-STARTED"))
                     (not (string= org-last-state org-state))
                     (org-clock-is-active))
            (org-clock-out))))

      :hook
      (org-after-todo-state-change . sacha/org-clock-out-if-waiting-or-pausing)
      (org-after-todo-state-change . sacha/org-clock-in-if-starting)

      :config
      (org-clock-persistence-insinuate))

  (use-package org-clock-convenience
    :tags '("ORG")
    :bind (:map org-agenda-mode-map
             ("<S-up>" . org-clock-convenience-timestamp-up)
             ("<S-down>" . org-clock-convenience-timestamp-down)))
#+end_src

**** Webpage overview
#+begin_src emacs-lisp
  (use-package org-analyzer
    :if (file-directory-p cloud-org-root-dir)
    :custom (org-analyzer-org-directory  (concat cloud-org-root-dir "todo"))
    :commands (org-analyzer-start))
#+end_src

*** DONE Archiving
CLOSED: [2021-01-03 Sun 14:44]
:PROPERTIES:
:FROM:     https://github.com/daviderestivo/galactic-emacs/blob/master/lisp/org-archive-subtree.el
:END:
I prefer to keep the tree structure.
This is why I use this configuration.

#+begin_src emacs-lisp
  (use-package org-archive
    :straight org-contrib
    :tags '("ORG")
    :config
    (setq org-archive-default-command 'org-archive-subtree)

    (defadvice org-archive-subtree (around fix-hierarchy activate)
      (let* ((fix-archive-p (and (not current-prefix-arg)
                                 (not (use-region-p))))
             (afile  (car (org-archive--compute-location
                           (or (org-entry-get nil "ARCHIVE" 'inherit) org-archive-location))))
             (buffer (or (find-buffer-visiting afile) (find-file-noselect afile))))
        ad-do-it
        (when fix-archive-p
          (with-current-buffer buffer
            (goto-char (point-max))
            (while (org-up-heading-safe))
            (let* ((olpath (org-entry-get (point) "ARCHIVE_OLPATH"))
                   (path (and olpath (split-string olpath "/")))
                   (level 1)
                   tree-text)
              (when olpath
                (org-mark-subtree)
                (setq tree-text (buffer-substring (region-beginning) (region-end)))
                (let (this-command) (org-cut-subtree))
                (goto-char (point-min))
                (save-restriction
                  (widen)
                  (-each path
                    (lambda (heading)
                      (if (re-search-forward
                           (rx-to-string
                            `(: bol (repeat ,level "*") (1+ " ") ,heading)) nil t)
                          (org-narrow-to-subtree)
                        (goto-char (point-max))
                        (unless (looking-at "^")
                          (insert "\n"))
                        (insert (make-string level ?*)
                                " "
                                heading
                                "\n"))
                      (cl-incf level)))
                  (widen)
                  (org-end-of-subtree t t)
                  (org-paste-subtree level tree-text)))))))))
#+end_src

**** Cleaning helper
:PROPERTIES:
:FROM:     https://www.emacswiki.org/emacs/org-extension.el and https://stackoverflow.com/questions/6997387/how-to-archive-all-the-done-tasks-using-a-single-command
:END:

#+begin_src emacs-lisp
  (defun org-archive-done-tasks-subtree ()
    "Archive done tasks for the current subtree."
    (interactive)
    (org-map-entries
     (lambda ()
       (org-archive-subtree)
       (setq org-map-continue-from (org-element-property :begin (org-element-at-point))))
     "/+DONE" 'tree))

  (defun org-archive-all-done-item ()
    "Archive all item that have with prefix DONE."
    (interactive)
    (save-excursion
      (outline-show-all)
      (goto-char (point-min))
      (if (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
          (progn
            (goto-char (point-min))
            (while (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
              (org-advertized-archive-subtree))
            (message "Archive finished"))
        (message "No need to archive"))))

  (defun org-clean-done-item ()
    "Delete all item that have with prefix DONE."
    (interactive)
    (save-excursion
      (outline-show-all)
      (goto-char (point-min))
      (if (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
          (progn
            (goto-char (point-min))
            (while (search-forward-regexp "^[\\*]+ \\(DONE\\|CANCELLED\\)" nil t)
              (org-cut-subtree))
            (message "Cleaning DONE tasks finished"))
        (message "No need to clean"))))
#+end_src

*** DONE Monitoring
CLOSED: [2021-01-03 Sun 14:45]
I tend to have multiple project running in parallel.
To have an overview of what is going on, I am using =org-dashboard=.

#+begin_src emacs-lisp
  (use-package org-dashboard
    :tags '("ORG")
    :commands (org-dashboard-display))
#+end_src

*** DONE Improving dependencies
CLOSED: [2022-10-09 Sun 10:35]
:PROPERTIES:
:FROM:     https://qua.name/mrb/an-org-babel-based-emacs-configuration
:END:
=org-edna= provides a more flexible way of imposing dependencies between tasks.
Configuration remains minimal for now

#+begin_src emacs-lisp
  (use-package org-edna
    :tags '("ORG")
    :diminish
    :after org
    :config
    (org-edna-mode))
#+end_src

** DONE Accessing
CLOSED: [2021-01-03 Sun 15:24]
This section configures packages to access information from the org files.
=org-ql= is providing commands to query the org files in a SQL manner.
=org-protocol= is a package of =org-contrib= which provides helper to use emacsclient to access to org files.
This package is mainly use to bookmark webpages from firefox.

#+begin_src emacs-lisp
  (use-package org-ql
    :tags '("ORG")
    :commands (org-ql-search org-ql-view org-ql-view-recent-items))

  (use-package org-protocol
    :straight org-contrib
    :tags '("ORG"))
#+end_src

** DONE Capturing [100%]
CLOSED: [2021-01-04 Mon 08:33]
I use the capturing mechanism provded by org mode to add information for further investigations.
=doct= package is used to have a more human-friendly way a describing the templates.
I also use capturing mechanism to save recipes and some interesting websites.

#+begin_src emacs-lisp
  (use-package doct
    :tags '("ORG" "CAPTURE" "DESKTOP")
    :commands (doct))

  (use-package org-capture
    :tags '("ORG" "CAPTURE" "DESKTOP")
    :if (file-directory-p cloud-org-root-dir)
    :straight org-contrib
    :commands (org-capture)
    :config
    (setq org-capture-templates
          (doct `(
             ("Calendar"
              :keys "C"
              :type entry
              :file ,(format "%s/calendars/adapt.org" user-emacs-directory)
              :template-file ,(format "%s/third_parties/org-capture-templates/calendar.org" user-emacs-directory))

             ("TODO"
              :keys "t"
              :type entry
              :file ,(concat cloud-org-root-dir "todo/todo.org")
              :headline "To sort"
              :template-file ,(format "%s/third_parties/org-capture-templates/default.org" user-emacs-directory)
              :empty-lines-before 1)

             ("Mail"
              :keys "m"
              :type entry
              :file ,(concat cloud-org-root-dir "todo/todo.org")
              :headline "Mailing"
              :template-file ,(format "%s/third_parties/org-capture-templates/mail.org" user-emacs-directory))
             ))))
#+end_src

*** DONE Cooking
CLOSED: [2021-01-04 Mon 08:33]
=org-chef= provides an easy way to save recipes.
It supports multiple website so its configuration consists only of providing the template.

#+begin_src emacs-lisp
  (use-package org-chef
    :tags '("ORG" "CAPTURE" "DESKTOP" "CONNECTED")
    :if (file-directory-p cloud-org-root-dir)
    :after (org-capture)
    :config
    (setq org-chef-prefer-json-ld t)

    (setq org-capture-templates
          (doct-add-to org-capture-templates
                       `(("Cookbook"
                          :keys "o"
                          :type entry
                          :file ,(concat cloud-org-root-dir "perso/recipes.org")
                          :template ("* %^{Description}"
                                     "%(org-chef-get-recipe-from-url)")
                          :empty-lines 1))
                       'append)))
#+end_src

*** DONE ORG/Web tools
CLOSED: [2021-01-04 Mon 08:33]
=org-web-tools= is a nice package which allows to sniff a webpage and convert it into org-mode
format. This is really useful to homogeneise documentation.

#+begin_src emacs-lisp
  (use-package org-web-tools
    :after (org)
    :tags '("ORG" "CAPTURE" "DESKTOP" "CONNECTED"))
#+end_src

* DONE Notes taking & academic organizing [100%]
My note taking life is split in 2 categories: global note taking and bibliography/reference management.
The workflow is based on =org-roam= and uses additional packages to enhance the experience.

** DONE Fundamentals
CLOSED: [2022-02-10 Thu 07:08]
In this section, the global note taking part is configured.
It relies on three packages:
=org-roam= which is the core of the workflow,
=org-roam-protocol= to enhance the navigation,
and =org-roam-ui= for a better navigation.
=vulpea= is used to bridge =org-roam= and =org-agenda=.

*** DONE org-roam part
CLOSED: [2022-02-10 Thu 07:04]

#+NAME: org-roam-entry-keybindings
| Key     | Functon             | Description |
|---------+---------------------+-------------|
| C-<f12> | org-roam-hydra/body |             |

#+NAME: org-roam-navigation-bindings
| Key | Function                       | Label | Description |
|-----+--------------------------------+-------+-------------|
| l   | org-roam-buffer-toggle         |       |             |
| f   | org-roam-node-find             |       |             |
| g   | org-roam-ui-open               |       |             |
| b   | consult-org-roam-backlinks     |       |             |
| F   | consult-org-roam-forward-links |       |             |
| s   | consult-org-roam-search        |       |             |
| e   | consult-org-roam-file-find     |       |             |

#+NAME: org-roam-creation-bindings
| Key | Function             | Label | Description |
|-----+----------------------+-------+-------------|
| i   | org-roam-node-insert |       |             |
| c   | org-roam-capture     |       |             |

#+NAME: org-roam-bibliography-bindings
| Key | Function                    | Label | Description |
|-----+-----------------------------+-------+-------------|
| n   | org-noter                   |       |             |
| b   | generate-bibliography-entry |       |             |

#+NAME: org-roam-helpers-bindings
| Key | Function          | Label | Description |
|-----+-------------------+-------+-------------|
| I   | org-id-get-create |       |             |

#+begin_src emacs-lisp
  (use-package org-roam
    :straight (:host github :repo "org-roam/org-roam")
    :tags '("ORG" "USER" "CONNECTED")
    :if (file-directory-p cloud-org-root-dir)
    :commands (org-roam-setup)
    :custom
    (org-roam-directory cloud-org-root-dir)
    (org-roam-file-exclude-regexp '(".stversions/" ".stfolder/"))

    :pretty-hydra
    ((:title "ORG Roam" :color teal :hint nil)
     ("Navigation" (
        <<hydra-keybindings-gen(table=org-roam-navigation-bindings)>>
      )

      "Creation" (
        <<hydra-keybindings-gen(table=org-roam-creation-bindings)>>
      )

      "Bibliography" (
        <<hydra-keybindings-gen(table=org-roam-bibliography-bindings)>>
      )

      "Helpers" (
        <<hydra-keybindings-gen(table=org-roam-helpers-bindings)>>
      )
      ))

    :bind (
      <<keybindings-gen(table=org-roam-entry-keybindings)>>
    )

    :init
    (add-hook 'after-init-hook 'org-roam-setup)
    (setq org-roam-v2-ack t
          browse-url-galeon-program nil
          browse-url-netscape-program nil)

    :config
    (org-roam-db-autosync-mode))

  (use-package org-roam-protocol
    :straight (:host github :repo "org-roam/org-roam" :files ("extensions/org-roam-protocol.el"))
    :tags '("ORG" "USER")
    :after org-roam
    :config
    (cl-defmethod org-roam-node-directories ((node org-roam-node))
      (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
          (format "(%s)" (car (f-split dirs)))
        ""))

    (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
      (let* ((count (caar (org-roam-db-query
                           [:select (funcall count source)
                                    :from links
                                    :where (= dest $s1)
                                    :and (= type "id")]
                           (org-roam-node-id node)))))
        (format "[%d]" count)))

    (setq org-roam-node-display-template "${title:100} ${backlinkscount:4}"))

  (use-package org-roam-ui
    :tags '("ORG" "USER" "DESKTOP")
    :straight (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
    :after (org-roam eaf-browser)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

  (use-package citar-org-roam
    :straight (:type git :host github :repo "emacs-citar/citar-org-roam")
    :after citar org-roam
    :tags '("BIBLIOGRAPHY" "USER" "ORG")
    :no-require
    :config (citar-org-roam-mode))

  (use-package consult-org-roam
    :after org-roam
    :tags '("ORG" "USER" "COMPLETION")
    :commands (consult-org-roam-mode)
    ;; :init
    ;; (consult-org-roam-mode 1)
    :custom
    (consult-org-roam-grep-func #'consult-ripgrep)
    (consult-org-roam-buffer-narrow-key ?r)
    (consult-org-roam-buffer-after-buffers t)

    :config
    (consult-customize consult-org-roam-forward-links
                       :preview-key "M-.")
    )
#+end_src

*** DONE vulpea
CLOSED: [2022-02-10 Thu 07:06]
For now, I don't really know the power of =vulpea= but I use it to bridge =org-roam= and =org-agenda=.

#+begin_src emacs-lisp
  (use-package vulpea
    :if (file-directory-p cloud-org-root-dir)
    :tags '("ORG" "USER" "CONNECTED")
    :after org-roam
    :hook
    (before-save . vulpea-project-update-tag)
    :init
    (advice-add 'org-agenda :before #'vulpea-agenda-files-update)
    (advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
    :commands (vulpea-agenda-files-update)

    :config

    (add-to-list 'org-tags-exclude-from-inheritance "project")

    (defun vulpea-project-p ()
      "Return non-nil if current buffer has any todo entry.

    TODO entries marked as done are ignored, meaning the this
    function returns nil if current buffer contains only completed
    tasks."
      (org-element-map                          ; (2)
          (org-element-parse-buffer 'headline) ; (1)
          'headline
        (lambda (h)
          (eq (org-element-property :todo-type h)
              'todo))
        nil 'first-match))                     ; (3)

    (defun vulpea-project-update-tag ()
      "Update PROJECT tag in the current buffer."
      (when (and (not (active-minibuffer-window))
                 (vulpea-buffer-p))
        (save-excursion
          (goto-char (point-min))
          (let* ((tags (vulpea-buffer-tags-get))
                 (original-tags tags))
            (if (vulpea-project-p)
                (setq tags (cons "project" tags))
              (setq tags (remove "project" tags)))

            ;; cleanup duplicates
            (setq tags (seq-uniq tags))

            ;; update tags if changed
            (when (or (seq-difference tags original-tags)
                      (seq-difference original-tags tags))
              (apply #'vulpea-buffer-tags-set tags))))))

    (defun vulpea-buffer-p ()
      "Return non-nil if the currently visited buffer is a note."
      (and buffer-file-name
           (string-prefix-p
            (expand-file-name (file-name-as-directory org-roam-directory))
            (file-name-directory buffer-file-name))))

    (defun vulpea-project-files ()
      "Return a list of note files containing 'project' tag." ;
      (seq-uniq
       (seq-map
        #'car
        (org-roam-db-query
         [:select [nodes:file]
                  :from tags
                  :left-join nodes
                  :on (= tags:node-id nodes:id)
                  :where (like tag (quote "%\"project\"%"))]))))

    (defun vulpea-agenda-files-update (&rest _)
      "Update the value of `org-agenda-files'."
      (setq org-agenda-files (vulpea-project-files))
      (setq org-agenda-files (append org-agenda-files
                                     org-agenda-default-files))))
#+end_src

** DONE Bibliography management
CLOSED: [2022-02-10 Thu 07:12]
In this section, the configuration is focused on the bibliography handling.
It relies on the following packages:
=ebib= to navigate the global bibliography,
=org-ref= to bridge =org-mode= and the bibtex,
=citar= to enhance the experience orf =org-cite=,
and =org-roam-bibtex= to connect this managemente with =org-roam=.

=org-noter= is used to connect =org-mode= with =pdf-tools=, and =org-media-noter= to connect org-mode with mpv videos
These last packages are key to enable the browsing of the document in parallel to the navigation of the notes.

#+begin_src emacs-lisp
  (defvar slm~bib-files (list (expand-file-name (concat cloud-org-root-dir "bibliography/index.bib")))
    "My bibliography files.")

  (defvar slm~pdf-root-dir (list (expand-file-name (concat cloud-org-root-dir "bibliography/pdfs/")))
    "The root directory containing the PDF files.")
#+end_src

*** DONE ebib
CLOSED: [2022-02-10 Thu 07:09]
#+begin_src emacs-lisp
  (use-package ebib
    :tags '("BIBLIOGRAPHY" "USER")
    :if (file-directory-p cloud-org-root-dir)
    :custom
    (ebib-preload-bib-files slm~bib-files))
#+end_src

*** DONE org-ref
CLOSED: [2022-02-10 Thu 07:09]
#+begin_src emacs-lisp
  (use-package org-ref
    :tags '("BIBLIOGRAPHY" "ORG" "USER")
    :if (file-directory-p cloud-org-root-dir)
    :config
    (setq bibtex-completion-bibliography slm~bib-files
          bibtex-completion-library-path slm~pdf-root-dir
          ;; bibtex-completion-notes-path "~/Dropbox/emacs/bibliography/notes/"
          bibtex-completion-notes-template-multiple-files "* ${author-or-editor}, ${title}, ${journal}, (${year}) :${=type=}: \n\nSee [[cite:&${=key=}]]\n"

          bibtex-completion-additional-search-fields '(keywords)
          bibtex-completion-display-formats
          '((article       . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${journal:40}")
            (inbook        . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} Chapter ${chapter:32}")
            (incollection  . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
            (inproceedings . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*} ${booktitle:40}")
            (t             . "${=has-pdf=:1}${=has-note=:1} ${year:4} ${author:36} ${title:*}"))
          bibtex-completion-pdf-open-function (lambda (fpath)
                                                (call-process "open" nil 0 nil fpath))))
#+end_src

*** DONE citar
CLOSED: [2022-02-10 Thu 07:10]

#+NAME: citar-citation-keybindings
| Key   | Function              | Description |
|-------+-----------------------+-------------|
| C-c ] | citar-insert-citation |             |

#+NAME: citar-minibuffer-keybindings
| Key | Function            | Description |
|-----+---------------------+-------------|
| M-b | citar-insert-preset |             |

#+begin_src emacs-lisp
  (use-package citar
    :if (file-directory-p cloud-org-root-dir)
    :tags '("BIBLIOGRAPHY" "USER" "ORG")
    :commands (citar-insert-citation citar-select-ref)
    :bind (
      <<keybindings-gen(table=citar-citation-keybindings)>>

       :map org-mode-map (
         <<keybindings-gen(table=citar-citation-keybindings)>>
       )

       :map minibuffer-local-map (
         <<keybindings-gen(table=citar-minibuffer-keybindings)>>
       )
    )

    ;; :after (embark)
    :config
    ;; Make the 'citar' bindings available from `embark-act'.
    ;; (add-to-list 'embark-keymap-alist '(bibtex . citar-map))

    :custom
    (citar-bibliography slm~bib-files))
#+end_src

*** DONE org-roam-bibtex
CLOSED: [2022-02-10 Thu 07:10]
#+begin_src emacs-lisp
  (use-package org-roam-bibtex
    :tags '("BIBLIOGRAPHY" "USER" "ORG")
    :hook (org-roam-mode . org-roam-bibtex-mode)
    :commands (org-roam-bibtex-mode)
    :init
    (defun generate-bibliography-entry ()
      "Generate an org mode bibliography entry."
      (interactive)
      (let* ((key (citar-select-ref))
             (title (replace-regexp-in-string
                     "[{}]"
                     ""
                     (cdr (assoc "title" (citar-get-entry key)))))

             (pdf (file-relative-name
                   (read-file-name "Find file: "
                                   (buffer-file-name
                                    (window-buffer (minibuffer-selected-window))))))
             (entry (format "* %s\n:PROPERTIES:\n:ID: %s\n:ROAM_REFS: cite:%s\n:END:\n** Overall notes\n\n** Detailed notes\n:PROPERTIES:\n:INTERLEAVE_PDF: %s\n:END:\n\n" title (org-id-new) key pdf)))
        (insert entry)))

    (setq orb-preformat-keywords '("citekey" "title" "url" "author-or-editor" "keywords" "file")
          orb-process-file-keyword t
          orb-file-field-extensions '("pdf")))
#+end_src

*** DONE org-noter
CLOSED: [2022-02-10 Thu 07:12]
#+begin_src emacs-lisp
  (use-package org-noter
    :tags '("BIBLIOGRAPHY" "USER" "ORG" "DESKTOP")
    :after (:any org pdf-view)
    :custom
    (org-noter-doc-split-fraction '(0.7 . 0.3))
    (org-noter-property-doc-file "INTERLEAVE_PDF")
    (org-noter-property-note-location "INTERLEAVE_PAGE_NOTE"))
#+end_src

*** TODO org-media-noter
- Set the shortcuts

#+begin_src emacs-lisp :lexical no
  (use-package org-media-note
    :straight (org-media-note :type git :host github :repo "yuchen-lea/org-media-note"))

  (use-package org-media-noter
    :straight (org-media-noter :type git :host github :repo "seblemaguer/org-media-noter")
    :tags '("BIBLIOGRAPHY" "USER" "ORG" "DESKTOP")
    :commands (org-media-noter))
#+end_src

* DONE Environment [100%]
In order to have a better editing environment, I configured several fundamental features: undoing, folding, completing and templating.

** DONE Undoing
CLOSED: [2021-01-04 Mon 08:57]
For undoing an operation, I am using =vundo=.
The only configuration here is to activate it globally.

#+NAME: vundo-entry-keybindings
| Key   | Functon | Description |
|-------+---------+-------------|
| C-x u | vundo   |             |

#+begin_src emacs-lisp
  (use-package vundo
    :straight (:type git :host github :repo "casouri/vundo")
    :tags '("UNDOING")
    :bind (
      <<keybindings-gen(table=vundo-entry-keybindings)>>
    )

    :config
    (setq vundo-glyph-alist vundo-unicode-symbols)
    (set-face-attribute 'vundo-default nil :family "Symbola"))
#+end_src

** DONE Folding
CLOSED: [2021-01-04 Mon 09:00]
For the folding, I am relying on =origami= and its connection to lsp: =lsp-origami=

#+NAME: origami-keybindings
| Key | Function                        | Description |
|-----+---------------------------------+-------------|
| s   | origami-open-node               |             |
| O   | origami-open-node-recursively   |             |
| d   | origami-close-node              |             |
| C   | origami-close-node-recursively  |             |
| a   | origami-toggle-node             |             |
| A   | origami-recursively-toggle-node |             |
| R   | origami-open-all-nodes          |             |
| M   | origami-close-all-nodes         |             |
| v   | origami-show-only-node          |             |
| k   | origami-previous-fold           |             |
| j   | origami-forward-fold            |             |
| x   | origami-reset                   |             |

#+begin_src emacs-lisp
  (use-package origami
    :tags '("FOLDING")
    :demand
    :bind (:map origami-mode-map
      <<keybindings-gen(table=origami-keybindings)>>
    )

    :config
    (define-prefix-command 'origami-mode-map)
    (global-set-key (kbd "C-c @") 'origami-mode-map))

  (use-package lsp-origami
    :tags '("FOLDING")
    :hook (lsp-after-open . lsp-origami-try-enable)
    :commands (lsp-origami-try-enable))
#+end_src

** DONE Completing [100%]
Completion is one of the biggest time-saver feature a text editor can have.
I rely on three key completion systems for different purposes:
  - =company= is used for inline completion (mainly to access programming helpers and snippets)
  - =vertico= is used as the standard mini-buffer based completion
  - =helm= is provided for some specific completion tools which are interesting but are not supported by =completing-read=

*** DONE Company
CLOSED: [2021-01-03 Sun 17:42]
In this section, only the global configuration of =company= is provided.
The configuration associated with each language is done separately and is, as much as possible, buffer local.
I also use =company-quickhelp= to provide the description of the current candidate.
I finally use =company-box= to have a better view of the category of the candidates.

#+begin_src emacs-lisp
  (use-package company
    :tags '("COMPLETION")
    :init
    (setq company-backends '(company-capf company-files))

    :config
    ;; Global
    (setq company-idle-delay 1
          company-minimum-prefix-length 1
          company-show-numbers t
          company-tooltip-limit 20)

    ;; Activating globally
    (global-company-mode t))

  (use-package company-quickhelp
    :after company
    :tags '("COMPLETION" "UI")
    :config
    (company-quickhelp-mode 1))


  (use-package company-box
    :after company
    :tags '("COMPLETION" "UI")
    :straight (company-box :repo "seblemaguer/company-box" :type git :host github :branch "functional")
    :hook (company-mode . company-box-mode))
#+end_src

*** DONE Vertico
CLOSED: [2022-02-26 Sat 20:51]
This section provides the configuration of =Vertico=.
Nothing fancy happens here, just its activation and a couple of setups related to emacs specificities.

#+begin_src emacs-lisp
  ;; Enable vertico
  (use-package vertico
    :tags '("COMPLETION")
    :init
    (vertico-mode))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :init
    (savehist-mode))

  ;; A few more useful configurations related to vertico
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    ;; (setq read-extended-command-predicate
    ;;       #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))
#+end_src

*** DONE Helm
CLOSED: [2021-01-03 Sun 17:43]
I use Helm for some specific cases which requires an important visibility space completion.
Once again, nothing fancy here, the configuration to have a better UX.

#+NAME: helm-info-entry-keybindings
| Key   | Functon   | Description |
|-------+-----------+-------------|
| C-h i | helm-info |             |

#+begin_src emacs-lisp
  (use-package helm
    :tags '("COMPLETION")
    :functions helm-show-completion-default-display-function
    :bind (
      <<keybindings-gen(table=helm-info-entry-keybindings)>>
    )

    :config
    (setq helm-scroll-amount 4 ; scroll 4 lines other window using M-<next>/M-<prior>
          helm-quick-update t ; do not display invisible candidates
          helm-idle-delay 0.01 ; be idle for this many seconds, before updating in delayed sources.
          helm-input-idle-delay 0.01 ; be idle for this many seconds, before updating candidate buffer
          helm-show-completion-display-function #'helm-show-completion-default-display-function
          helm-split-window-default-side 'below ;; open helm buffer in another window
          helm-split-window-inside-p t ;; open helm buffer inside current window, not occupy whole other window
          helm-candidate-number-limit 200 ; limit the number of displayed canidates
          helm-move-to-line-cycle-in-source nil ; move to end or beginning of source when reaching top or bottom of source.
          )
    )
#+end_src

*** DONE Extension [100%]
CLOSED: [2021-01-03 Sun 17:52]
While the previous completion system is enough to work on its own, it is possible to enhance the user experince by adding a couple of more tweaks.

**** DONE Orderless
CLOSED: [2021-05-27 Thu 18:31]
=orderless= provides a more flexible way to filter a list of completion candidates.

#+BEGIN_SRC emacs-lisp
  (use-package orderless
    :tags '("COMPLETION")
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+END_SRC

**** DONE Marginalia
CLOSED: [2021-01-03 Sun 17:49]
Marginalia is completing =vertico= by providing annotations to the candidates.
For now, I am using the default configuration.

#+NAME: marginalia-entry-keybindings
| Key   | Functon          | Description |
|-------+------------------+-------------|
| C-M-a | marginalia-cycle |             |

#+begin_src emacs-lisp
  (use-package marginalia
    :tags '("COMPLETION")
    :after vertico
    :bind (
      :map minibuffer-local-map (
        <<keybindings-gen(table=marginalia-entry-keybindings)>>
      )
    )

    ;; The :init configuration is always executed (Not lazy!)
    :init
    (marginalia-mode)
    (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

**** DONE Consult
CLOSED: [2021-01-03 Sun 17:52]
Consult provides a set of commands which are particularly useful.
It is a nice extension to =Vertico= which brings to functionalities close to the ones proposed in =swiper= and =counsel=.

#+NAME: consult-ctrl-c-keybindings
| Key   | Function             | Description |
|-------+----------------------+-------------|
| C-c h | consult-history      |             |
| C-c m | consult-mode-command |             |
| C-c k | consult-kmacro       |             |

#+NAME: consult-ctrl-x-keybindings
| Key     | Function                | Description |
|---------+-------------------------+-------------|
| C-x M-: | consult-complex-command |             |
| C-x b   | consult-buffer          |             |
| C-x p b | consult-project-buffer  |             |
| C-x C-r | consult-recent-file     |             |

#+NAME: consult-yank-keybindings
| Key | Function         | Description |
|-----+------------------+-------------|
| M-y | consult-yank-pop |             |

#+NAME: consult-goto-keybindings
| Key     | Function              | Description |
|---------+-----------------------+-------------|
| M-g e   | consult-compile-error |             |
| M-g f   | consult-flymake       |             |
| M-g g   | consult-goto-line     |             |
| M-g M-g | consult-goto-line     |             |
| M-g o   | consult-outline       |             |
| M-g m   | consult-mark          |             |
| M-g k   | consult-global-mark   |             |
| M-g i   | consult-imenu         |             |
| M-g I   | consult-imenu-multi   |             |

#+NAME: consult-search-keybindings
| Key   | Function            | Description |
|-------+---------------------+-------------|
| M-s D | consult-locate      |             |
| M-s f | consult-find        |             |
| M-s g | consult-grep        |             |
| M-s G | consult-git-grep    |             |
| M-s r | consult-ripgrep     |             |
| M-s l | consult-line        |             |
| M-s L | consult-line-multi  |             |
| M-s m | consult-multi-occur |             |
| M-s k | consult-keep-lines  |             |
| M-s u | consult-focus-lines |             |

#+NAME: consult-isearch-keybindings
| Key   | Function                | Description |
|-------+-------------------------+-------------|
| M-s e | consult-isearch-history |             |

#+NAME: consult-isearch-mode-keybindings
| Key   | Function                | Description                              |
|-------+-------------------------+------------------------------------------|
| M-e   | consult-isearch-history | orig. isearch-edit-string                |
| M-s e | consult-isearch-history | orig. isearch-edit-string                |
| M-s l | consult-line            | needed by consult-line to detect isearch |
| M-s L | consult-line-multi      | needed by consult-line to detect isearch |

#+NAME: consult-flycheck-entry-keybindings
| Key | Functon          | Description |
|-----+------------------+-------------|
| !   | consult-flycheck |             |


#+begin_src emacs-lisp
  (use-package consult
    :tags '("COMPLETION")
    :bind (
      <<keybindings-gen(table=consult-ctrl-c-keybindings)>>
      <<keybindings-gen(table=consult-ctrl-x-keybindings)>>
      <<keybindings-gen(table=consult-yank-keybindings)>>
      <<keybindings-gen(table=consult-goto-keybindings)>>
      <<keybindings-gen(table=consult-search-keybindings)>>
      <<keybindings-gen(table=consult-isearch-keybindings)>>


      :map isearch-mode-map
      <<keybindings-gen(table=consult-isearch-mode-keybindings)>>
     )

    ;; ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; ;; relevant when you use the default completion UI. You may want to also
    ;; ;; enable `consult-preview-at-point-mode` in Embark Collect buffers.
    ;; :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    (setq consult-preview-key "M-.")

    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize consult-theme
                       :preview-key '(:debounce 0.2 any)
                       consult-ripgrep consult-git-grep consult-grep
                       consult-bookmark consult-recent-file consult-xref
                       consult--source-bookmark consult--source-recent-file
                       consult--source-project-recent-file
                       :preview-key "M-.")

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")
    )

  ;; Optionally add the `consult-flycheck' command.
  (use-package consult-flycheck
    :tags '("COMPLETION")
    :after (:all consult flycheck)
    :bind (
      :map flycheck-command-map (
        <<keybindings-gen(table=consult-flycheck-entry-keybindings)>>
      )
    ))
#+end_src

** DONE Templating [100%]
CLOSED: [2021-01-03 Sun 17:58]
I use templates for two cases:
  - starting point as new script/code file
  - accessing to some snippets.

In both cases, I rely on =yasnippet=.

*** DONE Snippets
CLOSED: [2021-01-03 Sun 17:57]
The default configuration of yasnippet consists of activating it and plugging it with company.
Obviously, the package =yasnippet-snippets= is also configured to provide default snippets.
I also use the package =consult-yasnipet= to list the snippets.
Finally, my own snippets are stored in the directory =~/.emacs.d/third_parties/snippets=.

#+begin_src emacs-lisp
  (use-package yasnippet
    :tags '("COMPLETION")
    :init
    (yas-global-mode 1))

  ;; Load snippets
  (use-package yasnippet-snippets
    :tags '("COMPLETION")
    :config

    ;; Add third parties snippets
    (defvar third-parties-snippet-dir (format "%s/third_parties/snippets" user-emacs-directory)
      "Directory containing my own snippets")

    (defun third-parties-snippets-initialize ()
      (add-to-list 'yas-snippet-dirs 'third-parties-snippet-dir t)
      (yas-load-directory third-parties-snippet-dir t))

    (eval-after-load 'yasnippet '(third-parties-snippets-initialize)))

  (use-package yasnippet-snippets
    :tags '("COMPLETION")
    :straight (consult-yasnippet :host github
                                 :repo "mohkale/consult-yasnippet"))
#+end_src

*** DONE File templates
CLOSED: [2021-01-03 Sun 17:58]
This part is using yatemplate (an over-layer of yasnippet) coupled with auto-insert to have a set of
file type dedicated templates. The templates are available in =~/.emacs.d/third_parties/templates= directory.

#+begin_src emacs-lisp
  (use-package yatemplate
    :tags '("COMPLETION")
    :after yasnippet
    :config

    ;; Define template directory
    (setq yatemplate-dir (concat user-emacs-directory "/third_parties/templates"))

    ;; Coupling with auto-insert
    (setq auto-insert-alist nil)
    (yatemplate-fill-alist))
#+end_src

** DONE Action triggering
CLOSED: [2021-05-27 Thu 18:34]
=embark= provides ways to execute an action to an ~emacs object~ (an URL, a region, ....).
It is a convenient package to have a more refined control of my workflow.
=embark= and =consult= also work nicely together, so I use them together.

#+NAME: embark-keybindings
| Key   | Function        | Description |
|-------+-----------------+-------------|
| C-S-a | embark-act      |             |
| C-h B | embark-bindings |             |

#+NAME: embark-minibuffer-keybindings
| Key     | Function                | Description |
|---------+-------------------------+-------------|
| C-c C-o | embark-collect-snapshot |             |
| C-c C-c | embark-act              |             |

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :tags '("HELPERS")
    :commands (which-key-mode)
    :hook (after-init . which-key-mode))

  (use-package which-key-posframe
    :tags '("HELPERS")
    :config
    (which-key-posframe-mode))

  (use-package embark
    :commands (embark-act embark-collect-snapshot)
    :tags '("HELPERS")
    :after (which-key)
    :bind (
      <<keybindings-gen(table=embark-keybindings)>>

      :map minibuffer-local-map
      <<keybindings-gen(table=embark-minibuffer-keybindings)>>
    )

     :config
     (setq embark-action-indicator
        (lambda (map &optional _target)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command)
        embark-become-indicator embark-action-indicator))


    (use-package embark-consult
      :tags '("HELPERS")
      :after (:all embark consult)
      :demand t
      :hook
      (embark-collect-mode . embark-consult-preview-minor-mode))
#+END_SRC

** DONE Buffer management
CLOSED: [2023-02-02 Thu 15:55]
=popper= is a package providing shortcuts for a quick access to some family of buffers.
I am using it mainly to show/hide my terminal faster.

#+NAME: start-term-hydra-keybindings
| Key | Function    | Label        | Description |
|-----+-------------+--------------+-------------|
| p   | run-python  | Python Shell |             |
| t   | multi-vterm | VTerm        |             |

#+NAME: popper-entry-keybindings
| Key    | Function              | Description |
|--------+-----------------------+-------------|
| <f6>   | popper-toggle-latest  |             |
| S-<f6> | popper-cycle          |             |
| C-<f6> | start-term-hydra/body |             |


#+begin_src emacs-lisp :lexical no
  (use-package popper
    :tags '("HELPER")
    :bind (
      <<keybindings-gen(table=popper-entry-keybindings)>>
    )

    :pretty-hydra (start-term-hydra
     (:color teal :hint nil)
     ("Select type of terminal" (
         <<hydra-keybindings-gen(table=start-term-hydra-keybindings)>>
    )))

    :init
    (setq popper-reference-buffers
          '("\\*Messages\\*"
            "Output\\*$"
            "\\*Async Shell Command\\*"
            help-mode
            compilation-mode
            "^\\*vterm.*\\*$"  vterm-mode
            comint-mode
            prodigy-mode))
    (popper-mode +1)
    (popper-echo-mode +1))
#+end_src

* IDE [100%]
While the environment configuration is fundamental for editing,
it is necessary to add more features to simplify coding life.
This section focuses on three components: the compilation, the commenting and the formatting.

** DONE Compilation [100%]
I configured the configuration around two main parts:
refining the default compilation support and add fly-checking support.

*** DONE Baseline compilation
CLOSED: [2022-07-25 Mon 07:38]
I just modify a little bit the default compilation to be a little more "user friendly".
I also rely on =fancy-compilation= to enhance the the output in the compilation buffer.

#+NAME: compilation-hydra-keybindings
| Key | Function                                                     | Label          | Description |
|-----+--------------------------------------------------------------+----------------+-------------|
| n   | next-error                                                   | Next Error     |             |
| k   | previous-error                                               | Previous Error |             |
| h   | first-error                                                  | First Error    |             |
| l   | (condition-case err (while t (next-error)) (user-error nil)) | ]Last Error    |             |

#+begin_src emacs-lisp
  (use-package compile
    :tags '("IDE" "COMPILATION")

    :pretty-hydra
    ((:color teal :hint nil)

     ("Compilation Errors" (
       <<hydra-keybindings-gen(table=compilation-hydra-keybindings)>>
      )
     )
    )

    :init
    (setq compilation-scroll-output t)

    :config

    ;; Auto close if success
    (defun my-compile-autoclose (buffer string)
      "Auto close compile log if there are no errors"
      (when (and (not (string-match-p (buffer-name buffer) "*grep*"))
                 (string-match "finished" string))
        (delete-window (get-buffer-window buffer t))
        (bury-buffer-internal buffer)))
    (add-to-list 'compilation-finish-functions #'my-compile-autoclose)

    (setq compilation-always-kill t
          compilation-ask-about-save nil
          compilation-scroll-output 'first-error)

    ;; the next-error function weirdly stops at "In file included from...". Stop that:
    ;; http://stackoverflow.com/questions/15489319/how-can-i-skip-in-file-included-from-in-emacs-c-compilation-mode
    (setcar (nthcdr 5 (assoc 'gcc-include compilation-error-regexp-alist-alist)) 0))

  (use-package fancy-compilation
    :tags '("IDE" "COMPILATION")
    :commands (fancy-compilation-mode)
    :custom
    (fancy-compilation-override-colors nil)
    :init
    (with-eval-after-load 'compile
      (fancy-compilation-mode)))
#+end_src

*** DONE Flychecking
CLOSED: [2021-01-03 Sun 18:13]
For the fly checking, I use flycheck instead of flymake.
The key part of this configuration is the fact that checking the documentation is disabled.
I also use =flycheck-posframe= to have a quick idea of what is going on at the pointed error/warning/...


#+NAME: flycheck-errors-bindings
| Key | Function                                                  | Label    | Description |
|-----+-----------------------------------------------------------+----------+-------------|
| f   | flycheck-error-list-set-filter                            | Filter   |             |
| j   | flycheck-next-error                                       | Next     |             |
| k   | flycheck-previous-error                                   | Previous |             |
| gg  | flycheck-first-error                                      | First    |             |
| <   | project-hydra/body                                        | back     |             |
| G   | (progn (goto-char (point-max)) (flycheck-previous-error)) | Last     |             |


#+begin_src emacs-lisp
  ;; Disable checking doc
  (use-package flycheck
    :tags '("CORE" "COMPILATION" "IDE")
    :commands (flycheck-error-list-set-filter flycheck-next-error flycheck-previous-error flycheck-first-error)
    :pretty-hydra
    ((:pre (progn (setq hydra-hint-display-type t) (flycheck-list-errors))
           :post (progn (setq hydra-hint-display-type nil) (quit-windows-on "*Flycheck errors*"))
           :color teal :hint nil)

     ("Errors" (
       <<hydra-keybindings-gen(table=flycheck-errors-bindings)>>
      )
    ))

    :config
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

  (use-package flycheck-posframe
    :disabled t
    :tags '("CORE" "UI")
    :after flycheck
    :hook (flycheck-mode . flycheck-posframe-mode)
    :config
    (setq flycheck-posframe-warning-prefix "\u26a0 "))
#+end_src

** DONE Commenting
CLOSED: [2021-01-03 Sun 18:33]
For the commenting, the common denominator is how to deal with FIXMEs.
To do so, I relie on two part: =hl-todo= for the highlighting and occur for the listing.
For language specific configurations, it is done in the language configuration part.

#+begin_src emacs-lisp
  (use-package hl-todo
    :tags '("CORE" "IDE")

    :init
    (defun fic-view-listing ()
      "Use occur to list related FIXME keywords"
      (interactive)
      (occur "\\<\\(FIXME\\|TODO\\|BUG\\|NOTE\\):?"))
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FF0000")
            ("FIXME"  . "#FF0000")
            ("NOTE"   . "#A020F0")
            ("BUG"    . "#FF4500")))
    :config
    (global-hl-todo-mode))
#+end_src

** DONE Formatting
CLOSED: [2021-01-03 Sun 18:26]
In order to format the buffer, it is better to rely on external formatter/linter.
=format-all= proposes support of big bunch of them, so I am using it.

#+begin_src emacs-lisp
  (use-package format-all
    :tags '("IDE" "FORMAT")
    :commands (format-all-buffer format-all-mode))
#+end_src

** DONE Sanitizing
CLOSED: [2021-01-25 Mon 20:21]
This part contains sanitizing helpers before saving the files.
For now it consists of simply removing any trailing whitespace.

#+BEGIN_SRC emacs-lisp
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

* TODO Programming [83%]
Now that the environment is set, it is time to configure the different part to use emacs as a proper developping environment.
To do so, I rely mainly on Language Server Protocol (LSP) and for the debugging I relay on the Debug Adapter Protocol (DAP).

** DONE LSP general configuration
CLOSED: [2021-01-03 Sun 21:28]
The general configuration of LSP is centered around two key parts: the UI and the keys.
I also override some default parameters to make the experience more appealing.


#+NAME: lsp-mode-hydra-entry-keybindings
| Key     | Functon             | Description |
|---------+---------------------+-------------|
| C-h M-h | lsp-mode-hydra/body |             |

#+NAME: lsp-mode-hydra-buffer-keybindings
| Key | Function                | Label         | Description |
|-----+-------------------------+---------------+-------------|
| f   | lsp-format-buffer       | Format        |             |
| m   | lsp-ui-imenu            | IMenu         |             |
| x   | lsp-execute-code-action | Excute action |             |

#+NAME: lsp-mode-hydra-server-keybindings
| Key | Function               | Label    | Description |
|-----+------------------------+----------+-------------|
| M-s | lsp-describe-session   | Describe |             |
| M-r | lsp-restart-workspace  | Restart  |             |
| S   | lsp-shutdown-workspace | Shutdown |             |

#+NAME: lsp-mode-hydra-symbol-keybindings
| Key | Function                        | Label          | Description |
|-----+---------------------------------+----------------+-------------|
| d   | lsp-find-declaration            | Declaration    |             |
| D   | lsp-ui-peek-find-definitions    | Definition     |             |
| R   | lsp-ui-peek-find-references     | References     |             |
| i   | lsp-ui-peek-find-implementation | Implementation |             |
| t   | lsp-find-type-definition        | Type           |             |
| s   | lsp-signature-help              | Signature      |             |
| o   | lsp-describe-thing-at-point     | Documentation  |             |
| r   | lsp-rename                      | Rename         |             |


#+begin_src emacs-lisp
  (use-package lsp-mode
    :tags '("IDE" "PROGRAMMING" "LSP")
    :commands (lsp lsp-deferred)
    :bind (
      :map lsp-mode-map (
        <<keybindings-gen(table=lsp-mode-hydra-entry-keybindings)>>
      )
    )

    :mode-hydra
    (lsp-mode
     (:color red)
     ("Buffer" (
       <<hydra-keybindings-gen(table=lsp-mode-hydra-buffer-keybindings)>>
      )

      "Server"(
       <<hydra-keybindings-gen(table=lsp-mode-hydra-server-keybindings)>>
      )

      "Symbol"(
       <<hydra-keybindings-gen(table=lsp-mode-hydra-symbol-keybindings)>>
      )
    ))

    :init
    (setq lsp-before-save-edits t
          lsp-inhibit-message t
          lsp-eldoc-render-all nil
          lsp-highlight-symbol-at-point nil
          lsp-prefer-flymake nil
          read-process-output-max (* 1024 1024)
          lsp-idle-delay 0.500)
    :config

    (defun lsp-clean-workspace-folders ()
      "Clean the list of workspace folders to restart from scratch. Useful when you had a rush a created a lot of projects and want to restart from scratch."
      (interactive)
      (dolist (cur-workspace-folder (lsp-session-folders (lsp-session)))
        (lsp-workspace-folders-remove cur-workspace-folder))))

  (use-package lsp-ui
    :tags '("IDE")
    :after lsp-mode
    :commands lsp-ui-mode
    :config
    (setq lsp-ui-doc-enable t
          lsp-ui-doc-use-webkit nil
          lsp-ui-doc-delay 10000.0
          lsp-ui-sideline-delay 10000.0
          lsp-ui-doc-include-signature t
          lsp-ui-doc-position 'at-point
          lsp-eldoc-enable-hover nil ; Disable eldoc displays in minibuffer
          lsp-headerline-breadcrumb-enable nil
          lsp-modeline-code-actions-enable nil
          lsp-modeline-diagnostics-enable nil
          lsp-ui-sideline-enable t
          lsp-ui-sideline-show-hover nil
          lsp-ui-sideline-show-diagnostics nil
          lsp-ui-sideline-ignore-duplicate t))
#+end_src

** DONE DAP general configuration
CLOSED: [2021-04-06 Tue 08:13]
The default configuration of =dap-mode= is too "heavy" for me.
I generally need the variables and the REPL buffer.
The rest can be activated manually later.
Finally, I reduced the height of the REPL buffer at the start of the debug session.

#+BEGIN_SRC emacs-lisp
  (use-package dap-mode
    :tags '("IDE" "PROGRAMMING" "LSP")
    :config
    ;; Disable control (I don't like it)
    (dap-ui-controls-mode 0)

    ;; Reduce the features to the repl and the local variable information
    (setq dap-auto-configure-features '(locals repl))

    ;; Redefine the height of the repl buffer
    (setq dap-ui-buffer-configurations
          `((,dap-ui--locals-buffer . ((side . right) (slot . 1) (window-width . 0.20)))
            (,dap-ui--expressions-buffer . ((side . right) (slot . 2) (window-width . 0.20)))
            (,dap-ui--sessions-buffer . ((side . right) (slot . 3) (window-width . 0.20)))
            (,dap-ui--breakpoints-buffer . ((side . left) (slot . 2) (window-width . ,treemacs-width)))
            (,dap-ui--debug-window-buffer . ((side . bottom) (slot . 3) (window-width . 0.20)))
            (,dap-ui--repl-buffer . ((side . bottom) (slot . 1) (window-height . 0.20))))))

#+END_SRC

** DONE Data [100%]
CLOSED: [2021-01-03 Sun 21:49]
This section is dedicated to the configuration of modes to deal with data formats.

*** DONE CSV
CLOSED: [2021-01-03 Sun 21:32]
For CSV file, I rely on =csv-mode= but I add more separators.

 #+begin_src emacs-lisp
   (use-package csv-mode
     :tags '("PROGRAMMING" "DATA")
     :hook
     (csv-mode . csv-align-mode)

     :config
     (setq csv-separators '("," ";" ":" " " "	")))
 #+end_src

*** DONE CUE
CLOSED: [2021-01-03 Sun 21:35]
I use CUE files to guide audio CD I encode.
I developed a dedicated mode for this, so I am using it

#+begin_src emacs-lisp
  (use-package cue-mode
    :straight (cue-mode :repo "seblemaguer/cue-mode" :type git :host github)
    :tags '("PROGRAMMING" "DATA" "RELEASE")
    :mode ("\\.cue$"))
#+end_src

*** DONE JSON
CLOSED: [2021-01-03 Sun 21:47]
I am using JSON both for storing data and for configuration.
The configuration relies on =json-mode= for the main part and =json-reformat= for a better formatting.

#+begin_src emacs-lisp
  (use-package json-mode
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION")
    :mode ("\\.json$"))

  (use-package json-reformat
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION" "FORMATTING"))
#+end_src

*** DONE Praat
CLOSED: [2021-01-03 Sun 21:38]
I use praat, and more especially Textgrid, to annotate speech signals.
Praat-mode helps to have a proper visualization of Textgrids in Empacs.

#+begin_src emacs-lisp
  (use-package praat-mode
    :straight nil
    :load-path default-plugin-dir
    :tags '("PROGRAMMING" "DATA")
    :mode ("\\.[tT][Gg]"))
#+end_src

*** DONE XML
CLOSED: [2021-01-03 Sun 21:49]
XML is, as JSON, used for data formatting and configuration.
However, I had to do extra-configurations to have outline support and a better formatting.

#+begin_src emacs-lisp
  (use-package nxml-mode
    :straight nil
    :load-path default-plugin-dir
    :tags '("PROGRAMMING" "DATA" "CONFIGURATION")
    :mode ("\\.xml$" . nxml-mode)
    :commands (pretty-print-xml-region)
    :init
    ;; Mapping xml to nxml
    (fset 'xml-mode 'nxml-mode)

    :hook
    (nxml-mode . (lambda ()
                   (outline-minor-mode)
                   (setq outline-regexp "^[ \t]*\<[a-zA-Z]+")))
    :config

    ;; Global configuration
    (setq nxml-child-indent 2
          nxml-auto-insert-xml-declaration-flag t
          nxml-slash-auto-complete-flag t
          nxml-bind-meta-tab-to-complete-flag t)

    ;; Helper to format
    (defun pretty-print-xml-region (begin end)
      "Pretty format XML markup in region. You need to have nxml-mode
  http://www.emacswiki.org/cgi-bin/wiki/NxmlMode installed to do
  this.  The function inserts linebreaks to separate tags that have
  nothing but whitespace between them.  It then indents the markup
  by using nxml's indentation rules."
      (interactive "r")
      (save-excursion
        (nxml-mode)
        (goto-char begin)
        (while (search-forward-regexp "\>[ \\t]*\<" nil t)
          (backward-char) (insert "\n"))
        (indent-region begin end))))
#+end_src

** DONE Configuration [100%]
CLOSED: [2021-01-04 Mon 07:03]
*** DONE Default unix configuration
CLOSED: [2021-01-03 Sun 21:52]
=config-general-mode= is applied for all unix configuration files.
For now, I know/use only files with extension ~rc~ or ~conf~.

#+begin_src emacs-lisp
  (use-package config-general-mode
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("\\.conf$" "\\.*rc$"))
#+end_src

*** DONE Authinfo
CLOSED: [2021-01-03 Sun 21:56]
The default =authinfo-mode= provided by emacs 27.1 is pretty nice but doesn't provide proper font-locking.
I started to develop =colored-authinfo-mode= to provide a better colorization for authinfo files.

#+begin_src emacs-lisp
  (use-package colored-authinfo-mode
    :straight (colored-authinfo-mode :repo "seblemaguer/colored-authinfo-mode" :type git :host github)
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("\\.authinfo\\(?:\\.gpg\\)\\'" . colored-authinfo-mode))
#+end_src

*** DONE Apache
CLOSED: [2021-01-04 Mon 06:41]
Nothing fancy here, we just add the support for =apache-mode= for several files which are known to be configuration for Apache.
Because the configuration of Apache requires root permissions, I assign the category SUDO to this package.
#+begin_src emacs-lisp
  (use-package apache-mode
    :tags '("PROGRAMMING" "CONFIGURATION" "SUDO")
    :mode ("\\.htaccess\\'" "httpd\\.conf\\'" "srm\\.conf\\'"
           "access\\.conf\\'" "sites-\\(available\\|enabled\\)/"))
#+end_src

*** DONE SSH configuration
CLOSED: [2021-01-04 Mon 06:48]
Nothing fancy here, we just add the support for =ssh-config-mode= for several files which are known to be configuration for SSH.

#+begin_src emacs-lisp
  (use-package ssh-config-mode
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("/\\.ssh/config\\'" "/system/ssh\\'" "/sshd?_config\\'" "/known_hosts\\'" "/authorized_keys2?\\'")
    :hook (ssh-config-mode . turn-on-font-lock)

    :config
    (autoload 'ssh-config-mode "ssh-config-mode" t))
#+end_src

*** DONE YAML
CLOSED: [2021-01-04 Mon 06:53]
YAML is my main configuration format file as it supports references and more importantly comments.
I mainly rely on =yaml-mode= to which I add outline support for a better navigation.
I also use =yaml-tomato= to get the path at the current point which helps the access to a specific subpart of the configuration.

#+NAME: yaml-pro-keybindings
| Key     | Functon                    | Description |
|---------+----------------------------+-------------|
| C-c M-p | yaml-pro-move-subtree-up   |             |
| C-c M-n | yaml-pro-move-subtree-down |             |

#+begin_src emacs-lisp
  (use-package yaml-mode
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode (".yaml$")
    :hook
    (yaml-mode . yaml-mode-outline-hook)

    :init
    (defun yaml-outline-level ()
      "Return the outline level based on the indentation, hardcoded at 2 spaces."
      (s-count-matches "[ ]\\{2\\}" (match-string 0)))

    (defun yaml-mode-outline-hook ()
      "See https://github.com/yoshiki/yaml-mode/issues/25#issuecomment-792833669"
      (outline-minor-mode)
      (setq outline-regexp
            (rx
             (seq
              bol
              (group (zero-or-more "  ")
                     (or (group
                          (seq (or (seq "\"" (*? (not (in "\"" "\n"))) "\"")
                                   (seq "'" (*? (not (in "'" "\n"))) "'")
                                   (*? (not (in ":" "\n"))))
                               ":"
                               (?? (seq
                                    (*? " ")
                                    (or (seq "&" (one-or-more nonl))
                                        (seq ">-")
                                        (seq "|"))
                                    eol))))
                         (group (seq
                                 "- "
                                 (+ (not (in ":" "\n")))
                                 ":"
                                 (+ nonl)
                                 eol)))))))
      (setq outline-level 'yaml-outline-level)))

  (use-package yaml-tomato
    :tags '("PROGRAMMING CONFIGURATION")
    :commands (yaml-tomato-show-current-path yaml-tomato-copy))

  (use-package yaml-pro
    :tags '("PROGRAMMING CONFIGURATION")
    :hook (yaml-mode . yaml-pro-mode)
    :bind (
      <<keybindings-gen(table=yaml-pro-keybindings)>>
    ))
#+end_src

*** DONE VIM
CLOSED: [2021-01-04 Mon 06:55]
I am using VIM as an alternative editor for quick editions, so I need to be able to modify its configuration.
To do so, I actually use Emacs and rely on =vimrc-mode=.

#+begin_src emacs-lisp
  (use-package vimrc-mode
    :tags '("PROGRAMMING" "CONFIGURATION")
    :mode ("^\\.vimrc\\'" "/etc/vim/vimrc"))
#+end_src

*** DONE GIT
CLOSED: [2021-01-04 Mon 06:58]
I am using GIT as my main VC.
GIT relies on, at least, three types of configuration files: the general ~config~ , the ~gitignore~ and the ~attributes~ files.
I use a dedicated mode for each type.

#+begin_src emacs-lisp
  (use-package git-modes
    :tags '("PROGRAMMING" "CONFIGURATION" "VC")
    :mode
    ("/\.gitconfig\'"    . gitconfig-mode)
    ("/vcs/gitconfig\'"  . gitconfig-mode)
    ("/\.dockerignore\'" . gitignore-mode))
#+end_src

*** DONE Mercurial
CLOSED: [2021-01-04 Mon 06:59]
Aside GIT, I sometimes use mercurial. As for GIT, I use a dedicated mode for each type (~hgignore~ and ~hgrc~) of configuration file.

#+begin_src emacs-lisp
  (use-package hgignore-mode
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))

  (use-package hgrc-mode
    :tags '("PROGRAMMING" "CONFIGURATION" "VC"))
#+end_src

*** DONE Dockerfile
CLOSED: [2021-01-04 Mon 07:01]
I am a constant user of Docker.
Consequently, I need a proper node to edit docker build files as I build my own images for my experiences.

#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :tags '("PROGRAMMING" "CONFIGURATION" "SYSTEM"))
#+end_src

*** DONE CRON
CLOSED: [2021-01-04 Mon 07:03]
CRON is a useful tool to plan some executions.
However the default editor is too raw for me.
While I would generally use VIM for such editions, I prefer to use emacs configured using =crontab-mode= to avoid mistakes.

#+begin_src emacs-lisp
  (use-package crontab-mode
    :tags '("PROGRAMMING" "CONFIGURATION" "SYSTEM"))
#+end_src

** DONE Logging
CLOSED: [2021-01-04 Mon 07:07]
In all of my scripts/software, I rely more on loggers than print.
Therefore, visualizing logs is key and =log-view= is a really flexible mode for this.
While it is configured to open files whose basenames contain ~syslog~ or the extension is composed by ~.log~.
In both cases, backup numbers are as well supported.

#+begin_src emacs-lisp
  (use-package logview
    :tags '("LANGUAGE")
    :commands logview-mode
    :mode
    ("\\.log\\(?:\\.[0-9]+\\)?\\'" . logview-mode)
    ("syslog\\(?:\\.[0-9]+\\)?\\'" . logview-mode))
#+end_src

** TODO Programming languages [88%]
I am using emacs as IDE for multiple languages.
For my research, I am using mainly on python, shell, java and maths-based languages.
I, obviously, write some elisp code as well.
Consequently, this section configure all of these languages.

*** DONE Emacs Lisp
CLOSED: [2021-01-04 Mon 07:38]
The configuration of emacs, to edit (e)lisp files, consists mainly of adding a linter support (~package-lint~) and REPL environment (~elpl~).
I also added a hydra configuration to link properly everything.

#+NAME: elisp-mode-hydra-eval-keybindings
| Key | Function    | Label  | Description |
|-----+-------------+--------+-------------|
| b   | eval-buffer | buffer |             |
| e   | eval-defun  | defun  |             |
| r   | eval-region | region |             |

#+NAME: elisp-mode-hydra-repl-keybindings
| Key | Function | Label | Description |
|-----+----------+-------+-------------|
| I   | elpl     | elpl  |             |

#+NAME: elisp-mode-hydra-formatting-keybindings
| Key | Function                    | Label        | Description |
|-----+-----------------------------+--------------+-------------|
| p   | package-lint-current-buffer | package-lint |             |

#+NAME: elisp-mode-hydra-test-keybindings
| Key | Function      | Label  | Description |
|-----+---------------+--------+-------------|
| t   | ert           | prompt |             |
| T   | (ert t)       | all    |             |
| F   | (ert :failed) | failed |             |

#+NAME: elisp-mode-hydra-doc-keybindings
| Key | Function              | Label       | Description |
|-----+-----------------------+-------------+-------------|
| d   | describe-foo-at-point | thing-at-pt |             |
| f   | describe-function     | function    |             |
| v   | describe-variable     | variable    |             |
| i   | info-lookup-symbol    | info lookup |             |

#+begin_src emacs-lisp
  (use-package emacs-lisp-mode
    :straight nil
    :mode-hydra
    (emacs-lisp-mode
     ("Eval" (
       <<hydra-keybindings-gen(table=elisp-mode-hydra-eval-keybindings)>>
     )

     "REPL" (
       <<hydra-keybindings-gen(table=elisp-mode-hydra-repl-keybindings)>>
     )

     "Formatting/linting" (
       <<hydra-keybindings-gen(table=elisp-mode-hydra-formatting-keybindings)>>
     )

     "Test" (
       <<hydra-keybindings-gen(table=elisp-mode-hydra-test-keybindings)>>
     )

     "Doc" (
       <<hydra-keybindings-gen(table=elisp-mode-hydra-doc-keybindings)>>
     )
    )))

  (use-package package-lint
    :tags '("PROGRAMMING" "ELISP" "COMPILATION")
    :commands package-lint-current-buffer)

  (use-package elpl
    :tags '("PROGRAMMING" "ELISP" "REPL")
    :commands (elpl))
#+end_src

*** TODO C/C++/CMake
**** Use google programming style
#+BEGIN_SRC emacs-lisp
  (use-package google-c-style
    :tags '("PROGRAMMING" "C" "CPP")
    :ensure t
    :hook
    (c-mode-common . google-set-c-style)
    (c-mode-common . google-make-newline-indent))
#+END_SRC

**** Treat =.h= as C++
Identify =.h= files as C++ files instead of C. To enable =c++-mode=
manually, type =M-x c\+\+-mode=.
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))
#+END_SRC

**** Clang-format
***** Installation
#+NAME: clang-format-entry-keybindings
| Key   | Function            | Description |
|-------+---------------------+-------------|
| C-c i | clang-format-region |             |
| C-c u | clang-format-buffer |             |
#+BEGIN_SRC emacs-lisp
  (use-package clang-format
    :ensure t
    :tags '("PROGRAMMING" "C" "CPP")
    :bind (
      <<keybindings-gen(table=clang-format-entry-keybindings)>>
    ))
#+END_SRC

***** Set code style
Use Google's C++ style.
#+BEGIN_SRC emacs-lisp
  (custom-set-variables '(clang-format-style "file"))
#+END_SRC

**** Doxygen Highlighting
Add highlighting for doxygen blocks.
#+BEGIN_SRC emacs-lisp
  (use-package highlight-doxygen
    :tags '("PROGRAMMING" "C" "CPP")
    :ensure t
    :hook
    (c-mode-common . highlight-doxygen-mode))
#+END_SRC
**** CMake
#+begin_src emacs-lisp
  (use-package cmake-mode
    :tags '("PROGRAMMING" "CMAKE")
    :ensure t
    :mode "CMakeLists.txt")
#+end_src

Eldoc for CMake.
#+BEGIN_SRC emacs-lisp
  (use-package eldoc-cmake
    :tags '("PROGRAMMING" "CMAKE")
    :ensure t
    :hook (cmake-mode . eldoc-cmake-enable))
#+END_SRC

Additional syntax highlighting for CMake. For some reason manual activation is still required.
#+BEGIN_SRC emacs-lisp
  (use-package cmake-font-lock
    :tags '("PROGRAMMING" "CMAKE")
    :ensure t
    :init (autoload 'cmake-font-lock-activate "cmake-font-lock" nil t)
    :hook (cmake-mode . cmake-font-lock-activate))
#+END_SRC

*** DONE Java based languages
CLOSED: [2021-01-04 Mon 07:19]
I use Java and two dialects based on Java: Groovy and Kotlin.
I strongly rely on LSP, so the configuration consists mainly on loading major mode and configuring the LSP servers.

#+begin_src emacs-lisp
  (use-package lsp-java
    :tags '("PROGRAMMING" "JAVA" "LSP")
    :hook
    (java-mode . lsp)

    :config
    (setq lsp-java-save-action-organize-imports nil))

  (use-package java-snippets
    :tags '("PROGRAMMING" "JAVA" "COMPLETION"))

  (use-package groovy-mode
    :tags '("PROGRAMMING" "JAVA" "GROOVY")
    :mode ("\.groovy$" "\.gradle$")
    :interpreter ("gradle" "groovy")
    :hook
    (groovy-mode .  (lambda () (inf-groovy-keys)))
    (groovy-mode . lsp-deferred)

    :config
    (autoload 'run-groovy "inf-groovy" "Run an inferior Groovy process")
    (autoload 'inf-groovy-keys "inf-groovy" "Set local key defs for inf-groovy in groovy-mode")

    (setq lsp-groovy-server-file "~/environment/local/lib/groovy-language-server-all.jar"))

  ;; Subpackages
  (use-package groovy-imports
    :tags '("PROGRAMMING" "JAVA" "GROOVY"))

  (use-package kotlin-mode
    :tags '("PROGRAMMING" "JAVA" "KOTLIN")
    :mode "\\.kts?\\'"
    :hook
    (kotlin-mode . lsp-deferred)

    :config
    (setq kotlin-tab-width 4))
#+end_src

*** DONE Mathematics based languages
CLOSED: [2021-01-04 Mon 07:16]
I am using two main (exclusive?!) mathematic dedicated languages: Matlab and R.
For matlab, I rely on =matlab-mode= for which I tweaked the command to avoid matlab desktop loading.
For R, I rely on =ess= which provides excellent support with a reasonable default configuration.

#+begin_src emacs-lisp
  (use-package matlab-load
    :straight matlab-mode
    :tags '("PROGRAMMING" "MATH" "MATLAB")
    :defines (matlab-shell-command-switches mlint-programs)
    :no-require t
    :mode ("\\.m$" . matlab-mode)
    :commands (matlab-shell)

    :config
    ;; (eval-after-load 'company
    ;;   '(add-to-list 'company-backends 'company-matlab))

    ;; (eval-after-load 'flycheck
    ;;   '(require 'flycheck-matlab-mlint)))

    ;; Command defines
    (setq matlab-shell-command-switches '("-nodesktop -nosplash")
          mlint-programs '("mlint" "glnxa64/mlint")))


  ;; ESS for R programming
  (use-package ess
    :tags '("PROGRAMMING" "MATH" "R")
    :config
    (setq ess-default-style 'RRR+))
#+end_src

*** DONE Python
CLOSED: [2021-01-04 Mon 07:42]
Python is my main programming language, so the one I configured the most intensively.
I strongly rely on LSP and the Microsoft ~pyright~ server.
I prefer to use ~ipython~ as the interpreter as it is more powerful.
I use =python-mls= to enhance the REPL environment
Finally, I use =numpydoc= to deal with the documentation.

#+begin_src emacs-lisp
  (use-package python
    :tags '("PROGRAMMING" "PYTHON")

    :dash "Python 3" "Pandas" "NumPy" "SciPy" "Matplotlib"
    :mode
    ("\\.py\\'" . python-mode)
    ("\\.wsgi$" . python-mode)

    :init
    (setq-default indent-tabs-mode nil)

    :config
    (setq python-indent-offset 4
          python-shell-interpreter "ipython"
          python-shell-interpreter-args "--simple-prompt --colors=Linux -i"))

  (use-package lsp-pyright
    :commands (lsp lsp-deferred)
    :tags '("PROGRAMMING" "PYTHON" "LSP")
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (require 'dap-python)
                           (lsp)))
    :custom
    (dap-python-debugger 'debugpy))

  (use-package numpydoc
    :tags '("PROGRAMMING" "PYTHON" "DOCUMENTATION")
    :after python)

  (use-package python-mls
    :tags '("PROGRAMMING" "PYTHON")
    :straight (python-mls :host github :repo "jdtsmith/python-mls")
    :custom
    (python-mls-multiline-history-modifier '(meta shift))
    :hook
    (inferior-python-mode . python-mls-mode))
#+end_src

*** DONE Shell
CLOSED: [2021-01-04 Mon 07:25]
Editing bash/zsh files is relatively straightforward using Emacs' default configuration.
Nonetheless, a proper completion support is lacking and some helpers are always welcomed.
To do so, I use =company-shell= to add shell support using the =company= completion system.
I am using =modern-sh= to enhance the experience (modern syntax highlighting, REPL, ...).

#+NAME: modern-sh-entry-keybindings
| Key    | Function       | Description |
|--------+----------------+-------------|
| C-<f6> | modern-sh-menu |             |

#+begin_src emacs-lisp
  (use-package company-shell
    :tags '("PROGRAMMING" "SHELL" "COMPLETION")
    :hook
    (shell-mode . company-shell-hook)

    :init
    (defun company-shell-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends (append '(company-shell company-shell-env company-fish-shell) company-backends))))

  (use-package modern-sh
    :disabled t
    :tags '("PROGRAMMING" "SHELL")
    :hook (sh-mode . embed-modern-sh-mode-toggle)
    :bind (
      :map modern-sh-mode-map (
        <<keybindings-gen(table=modern-sh-entry-keybindings)>>
      )
    )

    :init
    (defun embed-modern-sh-mode-toggle ()
      (when (buffer-file-name)
        (modern-sh-mode))))
#+end_src

*** DONE Plotting/Graphing
CLOSED: [2021-03-01 Mon 09:39]
I tend to use some specific languages to do some plotting.
For now, I am using only ~graphivz/DOT~, =d2= and ~tikz/pgf~.
This last one is configured on the latex part.
Therefore, in this section, I add the support of =graphviz-dot-mode= and =d2-mode=.

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode
    :tags '("PROGRAMMING" "PLOTTING")
    :init
    (defvar default-tab-width nil)

    :mode ("\\.dot\\'"))

  (use-package d2-mode
    :tags '("PROGRAMMING" "PLOTTING")
    :mode ("\\.d2\\'"))

  (use-package ob-d2
    :init
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((d2 . t))))
#+end_src

*** DONE Web
CLOSED: [2022-01-12 Wed 12:27]
I use =web-mode= to edit any kind of web-programming (html, css, and templates).

#+begin_src emacs-lisp
  (use-package web-mode
    :mode (".twig$" ".html?$" ".tpl$")

    :config
    (setq web-mode-markup-indent-offset 4
          web-mode-css-indent-offset 4
          web-mode-code-indent-offset 4
          web-mode-style-padding 4
          web-mode-script-padding 4
          web-mode-enable-auto-closing t
          web-mode-enable-auto-opening t
          web-mode-enable-auto-pairing t
          web-mode-enable-auto-indentation t)

    ;; Let smartparens handle auto closing brackets, e.g. {{ }} or {% %}
    ;; https://github.com/hlissner/doom-emacs/blob/develop/modules/lang/web/%2Bhtml.el#L56
    (dolist (alist web-mode-engines-auto-pairs)
      (setcdr alist
              (cl-loop for pair in (cdr alist)
                       unless (string-match-p "^[a-z-]" (cdr pair))
                       collect (cons (car pair)
                                     (string-trim-right (cdr pair)
                                                        "\\(?:>\\|]\\|}\\)+\\'")))))
    )
#+end_src

*** DONE Sound and Music
CLOSED: [2023-03-15 Wed 12:54]
=csound= is a neat tool to synthesize sound and music.
The configuration is pretty minimal - just associate the mode to the proper extensions.
#+begin_src emacs-lisp
  (when (executable-find "csound")
    (use-package csound-mode
      :tags '("PROGRAMMING" "SOUND" "MULTIMEDIA")
      :mode (("\\.csd\\'" . csound-mode)
             ("\\.orc\\'" . csound-mode)
             ("\\.sco\\'" . csound-mode)
             ("\\.udo\\'" . csound-mode))))
#+end_src

* DONE Writing / Reading [100%]
I decided to dissociate programming and writing for more clarity.
Nonetheless, both sections rely on the same principles.
Concerning the writing part, I use mainly org-mode and LaTeX (article and shared documents).
I also use markdown for README and collaborative projects.
Finally, concerning the reading part, I consider only PDF Files.
I use libreoffice/office 365 for official documents which can't be handled in PDF.

** DONE LaTeX [100%]
LaTeX is the core languages I am using to write scientific documents and presentations.
My configuration relies mainly on auctex but I had to tweak several part to match my way of dealing with such files.
These tweaks concerns mainly of using =outline= to deal with folding,
using the ~enquote~ command to do some quotation in latex and prepare a proper pdf compilation/synchronization.

#+begin_src emacs-lisp
  (use-package tex-site
    :straight auctex
    :tags '("WRITING" "LATEX")
    :after (tex latex)
    :hook
    (LaTeX-mode . turn-off-auto-fill)
    (LaTeX-mode . (lambda () (TeX-fold-mode t)))
    (LaTeX-mode . LaTeX-math-mode)
    (LaTeX-mode . outline-minor-mode)
    (LaTeX-mode . TeX-source-correlate-mode)
    (TeX-after-compilation-finished-functions . TeX-revert-document-buffer)

    :config
    ;; PDF activated by default
    (TeX-global-PDF-mode 1)

    ;; Diverse
    (setq-default TeX-master nil)
    (setq TeX-parse-self t
          TeX-auto-save t)

    ;; Minor helpers for comment and quotes
    (add-to-list 'LaTeX-verbatim-environments "comment")
    (setq TeX-open-quote "\\enquote{"
          TeX-close-quote "}")

    ;; Indentation
    (setq LaTeX-indent-level 4
          LaTeX-item-indent 0
          TeX-brace-indent-level 4
          TeX-newline-function 'newline-and-indent)

    ;; PDF/Tex correlation
    (setq TeX-source-correlate-method 'synctex
          TeX-view-program-selection '((output-pdf "PDF Tools")))

    ;; Keys
    (define-key LaTeX-mode-map (kbd "C-c C-=") 'align-current))

  (use-package latex-table-wizard
    :tags '("WRITING" "LATEX"))
#+end_src

*** DONE Reftex
CLOSED: [2021-01-04 Mon 11:55]
I am using =reftex= to deal with references.
The configuration consists mainly of pluging it into auctex and expand the citation keywords and commands.

#+begin_src emacs-lisp
  (use-package reftex
    :tags '("WRITING" "LATEX")
    :hook
    (LaTeX-mode . turn-on-reftex)

    :config
    (setq reftex-save-parse-info t
          reftex-enable-partial-scans t
          reftex-use-multiple-selection-buffers t
          reftex-plug-into-AUCTeX t
          reftex-vref-is-default t
          reftex-cite-format
          '((?c    . "\\cite[]{%l}")
            (?t    . "\\textcite{%l}")
            (?a    . "\\autocite[]{%l}")
            (?p    . "\\parencite{%l}")
            (?f    . "\\footcite[][]{%l}")
            (?F    . "\\fullcite[]{%l}")
            (?x    . "[]{%l}")
            (?X    . "{%l}"))

          font-latex-match-reference-keywords
          '(("cite"             "[{")
            ("cites"            "[{}]")
            ("footcite"         "[{")
            ("footcites"        "[{")
            ("parencite"        "[{")
            ("textcite"         "[{")
            ("fullcite"         "[{")
            ("citetitle"        "[{")
            ("citetitles"       "[{")
            ("headlessfullcite" "[{"))

          reftex-cite-prompt-optional-args nil
          reftex-cite-cleanup-optional-args t))
#+end_src

*** DONE Completion
CLOSED: [2021-05-18 Tue 16:53]
For the completion, I need to prepare some proper hook for =company=.
I use two packages =company-auctex= which provides the enhancement of auctex and =company-reftex= which provides a proper completion support for references.
I also uses =company-ipa= to have a better integration of phonetic symbols.

#+begin_src emacs-lisp
  (setq TeX-auto-global (format "%s/auctex/style" user-emacs-directory))

  (use-package company-auctex
    :tags '("WRITING" "LATEX" "COMPLETION")
    :hook
    (LaTeX-mode . company-auctex-hook)

    :init
    (defun company-auctex-hook ()
      (make-local-variable 'company-backends)
      (company-auctex-init)))

  (use-package company-reftex
    :tags '("WRITING" "LATEX" "ORG" "COMPLETION")
    :hook
    (LaTeX-mode . company-reftex-hook)
    (org-mode   . company-reftex-hook)

    :init
    (defun company-reftex-hook ()
      (make-local-variable 'company-backends)
      (set 'company-backends (append '(company-reftex-labels company-reftex-citations) company-backends))))


    (use-package company-ipa
      :tags '("WRITING" "COMPLETION")
      :hook
      (LaTeX-mode . company-ipa-hook)

      :init
      (defun company-ipa-hook ()
        (make-local-variable 'company-backends)
        (add-to-list 'company-backends 'company-ipa-symbols-unicode)))

#+end_src

*** DONE Compilation
CLOSED: [2021-01-04 Mon 12:03]
For the compilation, I prefer to use =latexmk=.
It processes everything automatically which removes the burden of having to define the sequence of commands.
I could have used the auctex default sequence, but I prefer to have an homogeneous process with what I do in the shell!

#+begin_src emacs-lisp
  (when (executable-find "latexmk")
    (use-package auctex-latexmk
      :straight (:type git :host github :repo "wang1zhen/auctex-latexmk")
      :tags '("WRITING" "LATEX" "COMPILATION")
      :config

      ;; Redine TeX-output-mode to get the color !
      (define-derived-mode TeX-output-mode TeX-special-mode "LaTeX Output"
        "Major mode for viewing TeX output.
    \\{TeX-output-mode-map} "
        :syntax-table nil
        (set (make-local-variable 'revert-buffer-function)
             #'TeX-output-revert-buffer)

        (set (make-local-variable 'font-lock-defaults)
             '((("^!.*" . font-lock-warning-face) ; LaTeX error
                ("^-+$" . font-lock-builtin-face) ; latexmk divider
                ("^\\(?:Overfull\\|Underfull\\|Tight\\|Loose\\).*" . font-lock-builtin-face)
                ;; .....
                )))

        ;; special-mode makes it read-only which prevents input from TeX.
        (setq buffer-read-only nil))

      ;; Setup everything
      (setq auctex-latexmk-inherit-TeX-PDF-mode t
            TeX-show-compilation nil)
      (auctex-latexmk-setup)))
#+end_src

*** DONE Preview
CLOSED: [2021-01-04 Mon 12:05]
Complicated equations can be difficult to parse properly at first sight.
I use =xenops= to generate a preview of the equations.
=xenops= is also compatible with org-mode but I use it more with latex.
Therefore, it is activated by default for latex but not for org files.

#+begin_src emacs-lisp
  (use-package xenops
    :tags '("WRITING" "LATEX" "ORG" "DESKTOP")
    :commands (xenops-mode xenops-doctor)
    :hook
    (latex-mode . xenops-mode))
#+end_src

*** DONE Overleaf
CLOSED: [2022-03-08 Tue 16:11]
As an academic, I spend a lot of my time in Overleaf, but I prefer to edit in emacs, so =emacs-overleaf= is key!
#+begin_src emacs-lisp
  (use-package emacs-overleaf
    :tags '("WRITING" "LATEX" "CONNECTED")
    :straight (:type git :host github :repo "seblemaguer/emacs-overleaf")
    :commands (overleaf-setup overleaf-manual-save overleaf-mode)
    :custom (overleaf-auto-sync "never"))
#+end_src

** DONE Bibtex
CLOSED: [2021-01-04 Mon 12:15]
To store bibliography entries, BibTex is the way to go.
The global configuration consists mainly on providing a way to generate proper keys.
Finally, I use bibclean-format to have a clean final bibtex file.

#+NAME: bibtex-tidy-entry-keybindings
| Key    | Function           | Description |
|--------+--------------------+-------------|
| C-c f  | bibtex-tidy-buffer |             |

#+begin_src emacs-lisp
  (use-package bibtex
    :tags '("WRITING" "BIBTEX")
    :straight nil
    :bind (
      :map bibtex-mode-map (
        <<keybindings-gen(table=bibtex-tidy-entry-keybindings)>>
      )
    )

    :config
    (defun bibtex-generate-autokey ()
      (let* ((bibtex-autokey-names nil)
             (bibtex-autokey-year-length 4)
             (bibtex-autokey-name-separator "\0")
             (names (split-string (bibtex-autokey-get-names) "\0"))
             (year (bibtex-autokey-get-year))
             (name-char (cond ((= (length names) 1) 4)
                              ((= (length names) 2) 2)
                              (t 1)))
             (existing-keys (bibtex-parse-keys))
             key)
        (setq names (s-upper-camel-case (car names)))
        (setq key (format "%s:%s" year names))

        (let ((ret key))
          (cl-loop for c from ?a to ?z
                while (assoc ret existing-keys)
                do (setq ret (format "%s:%c" key c)))
          ret)))

    (setq bibtex-align-at-equal-sign t
          bibtex-autokey-name-year-separator ""
          bibtex-autokey-year-title-separator ""
          bibtex-autokey-titleword-first-ignore '("the" "a" "if" "and" "an")
          bibtex-autokey-titleword-length 100
          bibtex-autokey-titlewords 1)

    (defun bibtex-tidy-buffer ()
      "Apply bibtex-tidy to clean the current bibtex buffer."
      (interactive)
      (shell-command
       (format "bibtex-tidy %s %s %s %s"
               "--curly --numeric --space=4 --align=13 --no-escape"
               "--duplicates=key,doi --trailing-commas --no-remove-dupe-fields"
               "--sort-fields=title,shorttitle,author,year,month,day,journal,booktitle,location,on,publisher,address,series,volume,number,pages,doi,isbn,issn,url,urldate,copyright,category,note,metadata"
               (shell-quote-argument (buffer-file-name))))
      (revert-buffer t t t)))
#+end_src

** DONE TikZ/PGF
CLOSED: [2021-01-04 Mon 12:18]
To generate figures, I use sometimes inkscape but main TikZ/PGF.
While ktikz provides a nice tools, the way it deals with the header is problematic for me.
Furthermore, it is not integrated in emacs :D
Therefore, I developed a mode.
However, it relies on a side script ~compilePGF~ being in the PATH!

#+begin_src emacs-lisp
  (use-package tikz-mode
    :straight (tikz-mode :type git :host github :repo "seblemaguer/tikz-mode")
    :tags '("WRITING" "BIBTEX" "DESKTOP"))
#+end_src

** DONE Markdown
CLOSED: [2021-01-04 Mon 12:22]
Markdown is the main language used to write READMEs in collaborative projects.
While I prefer it org-mode, I still have to use it for collaborative purposes.
Consequently, I have to get a proper configuration.
Luckily, =markdown-mode= provide more than enough.
I just added =grip-mode= to have a proper preview of the file.

#+NAME: grip-mode-entry-keybindings
| Key | Function  | Description |
|-----+-----------+-------------|
| g   | grip-mode |             |

#+begin_src emacs-lisp
  (use-package markdown-mode
    :tags '("WRITING" "MARKDOWN")
    :mode ("\\.md$"))

  (use-package grip-mode
    :tags '("WRITING" "MARKDOWN" "DESKTOP")
    :commands (grip-mode)
    :bind (
      :map markdown-mode-command-map (
        <<keybindings-gen(table=grip-mode-entry-keybindings)>>
      )
    ))
#+end_src

** DONE Writing helpers
CLOSED: [2021-01-04 Mon 13:05]
As I am prone to constantly using the same writing ways, I need some helpers to get out the loop.
I am using =academic-phrases= to provided starting points and =mw-thesaurus= to find synonyms and/or related words.

#+begin_src emacs-lisp
  (use-package academic-phrases
    :tags '("WRITING" "HELPERS" "CONNECTED")
    :commands (academic-phrases))

  (use-package mw-thesaurus
    :straight (mw-thesaurus :type git :fetcher github :repo "agzam/mw-thesaurus.el")
    :tags '("WRITING" "HELPERS" "CONNECTED")
    :commands (mw-thesaurus-lookup-at-point))
#+end_src

** DONE Grammar checking
CLOSED: [2021-01-04 Mon 13:06]
To help to deal with my poor English, I am using grammarly to check my text.
The package =grammarly= bring its functionnality into emacs which is a saver for me.

#+begin_src emacs-lisp
  (use-package flycheck-grammarly
    :tags '("WRITING" "CONNECTED")
    :init
    (with-eval-after-load 'flycheck
      (flycheck-grammarly-setup))
    :custom
    (flycheck-grammarly-check-time 0.8))
#+end_src

** DONE Translation
CLOSED: [2022-12-31 Sat 20:10]
As I have the luck to deal with multiple languages (french, english and bulgarian), I need to have a quick access to some translations.
WordReference is my first choice as I find it quite complete and accurate.
As a fallback, I am using google-translate via the package =go-translate=.

#+NAME: gts-translate-entry-keybindings
| Key   | Function         | Description |
|-------+------------------+-------------|
| C-c t | gts-do-translate |             |

#+begin_src emacs-lisp
  (use-package wordreference
    :straight (:type git :host github :repo "emacsmirror/wordreference")
    :tags '("WRITING" "HELPERS" "TRANSLATION" "CONNECTED")
    :commands (wordreference-search))

  (use-package go-translate
    :tags '("WRITING" "HELPERS" "TRANSLATION" "CONNECTED")
    :bind (
      <<keybindings-gen(table=gts-translate-entry-keybindings)>>
    )

    :config
    (setq gts-translate-list '(("en" "fr")
                               ("en" "bg")
                               ("fr" "en")
                               ("bg" "en")))

    ;; config the default translator, it will be used by command gts-do-translate
    (setq gts-default-translator
          (gts-translator
           :picker (gts-prompt-picker)
           :engines (list
             (gts-google-engine :parser (gts-google-summary-parser))
             ;; (gts-google-rpc-engine :parser (gts-google-rpc-parser) :url "https://translate.google.com")
           )

           :render (gts-buffer-render)
           :splitter (gts-paragraph-splitter)
           )))
#+end_src

** DONE PDF
CLOSED: [2021-05-18 Tue 16:53]
Visualizing PDF files in Emacs is quite useful.
I am using =pdf-tools= which provides a lot of functionalities.
The configuration consists mainly of providing proper keyboard based controls using =hydra=.
I am also using =pdf-view-restore= to keep track of where I was before closing emacs.

#+NAME: pdf-tools-keybindings
| Key     | Function                             | Description |
|---------+--------------------------------------+-------------|
| ?       | pdf-tools-hydra/body                 |             |
| <s-spc> | pdf-view-scroll-down-or-next-page    |             |
| <C-s>   | isearch-forward                      |             |
| g       | pdf-view-first-page                  |             |
| G       | pdf-view-last-page                   |             |
| l       | image-forward-hscroll                |             |
| h       | image-backward-hscroll               |             |
| j       | pdf-view-next-page                   |             |
| k       | pdf-view-previous-page               |             |
| e       | pdf-view-goto-page                   |             |
| u       | pdf-view-revert-buffer               |             |
| al      | pdf-annot-list-annotations           |             |
| ad      | pdf-annot-delete                     |             |
| aa      | pdf-annot-attachment-dired           |             |
| am      | pdf-annot-add-markup-annotation      |             |
| at      | pdf-annot-add-text-annotation        |             |
| y       | pdf-view-kill-ring-save              |             |
| i       | pdf-misc-display-metadata            |             |
| s       | pdf-occur                            |             |
| b       | pdf-view-set-slice-from-bounding-box |             |
| r       | pdf-view-reset-slice                 |             |

#+NAME: pdf-tools-hydra-move-keybindings
| Key | Function                       | Label        | Options    | Description |
|-----+--------------------------------+--------------+------------+-------------|
| g   | pdf-view-first-page            | First        |            |             |
| G   | pdf-view-last-page             | Last         |            |             |
| p   | pdf-view-previous-page-command | Previous     | :color red |             |
| n   | pdf-view-next-page-command     | Next         | :color red |             |
| e   | pdf-view-goto-page             | Page         |            |             |
| h   | image-backward-hscroll         | Scroll left  | :color red |             |
| l   | image-forward-hscroll          | Scroll right | :color red |             |

#+NAME: pdf-tools-hydra-history-keybindings
| Key | Function             | Label    | Options    | Description |
|-----+----------------------+----------+------------+-------------|
| B   | pdf-history-backward | Backward | :color red |             |
| N   | pdf-history-forward  | Forward  | :color red |             |

#+NAME: pdf-tools-hydra-scale-keybindings
| Key | Function                             | Label                       | Options    | Description |
|-----+--------------------------------------+-----------------------------+------------+-------------|
| +   | pdf-view-enlarge                     | Enlarge                     | :color red |             |
| -   | pdf-view-shrink                      | Shrink                      | :color red |             |
| 0   | pdf-view-scale-reset                 | Reset                       |            |             |
| H   | pdf-view-fit-height-to-window        | Fit height                  |            |             |
| W   | pdf-view-fit-width-to-window         | Fit width                   |            |             |
| P   | pdf-view-fit-page-to-window          | Fit page                    |            |             |
| b   | pdf-view-set-slice-from-bounding-box | Set slice from bounding box |            |             |
| r   | pdf-view-reset-slice                 | Reset slice                 |            |             |

#+NAME: pdf-tools-hydra-annotations-keybindings
| Key | Function                        | Label  | Description |
|-----+---------------------------------+--------+-------------|
| al  | pdf-annot-list-annotations      | List   |             |
| am  | pdf-annot-add-markup-annotation | Markup |             |
| at  | pdf-annot-add-text-annotation   | Text   |             |
| ad  | pdf-annot-delete                | Delete |             |
| aa  | pdf-annot-attachment-dired      | Dired  |             |
| y   | pdf-view-kill-ring-save         | Yank   |             |

#+NAME: pdf-tools-hydra-search-keybindings
| Key | Function                | Label       | Description |
|-----+-------------------------+-------------+-------------|
| s   | pdf-occur               | Search      |             |
| o   | pdf-outline             | Outline     |             |
| F   | pdf-links-action-perfom | Link        |             |
| f   | pdf-links-isearch-link  | Search link |             |

#+NAME: pdf-tools-hydra-diverse-keybindings
| Key | Function                  | Label         | Description |
|-----+---------------------------+---------------+-------------|
| d   | pdf-view-dark-minor-mode  | Dark mode     |             |
| i   | pdf-misc-display-metadata | Info          |             |
| u   | pdf-view-revert-buffer    | Revert buffer |             |

#+begin_src emacs-lisp
  (use-package pdf-tools
    :straight (pdf-tools :type git :host github :repo "vedang/pdf-tools")
    :tags '("DOCUMENT" "DESKTOP")
    :functions
    (pdf-history-backward
     pdf-history-forward
     pdf-links-action-perfom
     pdf-links-isearch-link
     pdf-view-enlarge
     pdf-view-shrink
     pdf-view-scale-reset
     pdf-view-fit-height-to-window
     pdf-view-fit-width-to-window
     pdf-view-fit-page-to-window
     pdf-view-next-page-command
     pdf-view-previous-page-command
     pdf-view-dark-minor-mode)

    :hook
    (pdf-view-mode . (lambda ()
                       (pdf-misc-size-indication-minor-mode)
                       (pdf-links-minor-mode)
                       (pdf-isearch-minor-mode)
                       (cua-mode 0)))

    :bind (:map pdf-view-mode-map
      <<keybindings-gen(table=pdf-tools-keybindings)>>
    )

    :pretty-hydra
    ((:color blue :hint nil)
     ("Move" (
        <<hydra-keybindings-gen-with-opt(table=pdf-tools-hydra-move-keybindings)>>
      )

      "History" (
        <<hydra-keybindings-gen-with-opt(table=pdf-tools-hydra-history-keybindings)>>
      )

      "Scale/Fit" (
        <<hydra-keybindings-gen-with-opt(table=pdf-tools-hydra-scale-keybindings)>>
      )

      "Annotations" (
        <<hydra-keybindings-gen(table=pdf-tools-hydra-annotations-keybindings)>>
      )

      "Search/Link" (
        <<hydra-keybindings-gen(table=pdf-tools-hydra-search-keybindings)>>
      )

      "Other" (
        <<hydra-keybindings-gen(table=pdf-tools-hydra-diverse-keybindings)>>
      )))

    :magic ("%PDF" . pdf-view-mode)

    :config
    ;; Install what need to be installed !
    (pdf-tools-install t t t)

    ;; open pdfs scaled to fit page
    (setq-default pdf-view-display-size 'fit-page)

    ;; automatically annotate highlights
    (setq pdf-annot-activate-created-annotations t)

    ;; more fine-grained zooming
    (setq pdf-view-resize-factor 1.1))

  (use-package pdf-view-restore
    :after pdf-tools
    :tags '("DOCUMENT" "DESKTOP")
    :hook
    (pdf-view-mode-hook . pdf-view-restore-mode))

  (when (executable-find "diffpdf")
    (use-package diffpdf
      :tags '("DOCUMENT" "DESKTOP")))
#+end_src

*** DONE Grepping
CLOSED: [2021-03-01 Mon 09:45]
I use =pdfgrep= to be able to search inside the pdf document.

#+begin_src emacs-lisp
  (when (executable-find "pdfgrep")
    (use-package pdfgrep
      :tags '("DOCUMENT" "DESKTOP")
      :config
      (pdfgrep-mode)))
#+end_src

*** DONE Connection with org-mode
CLOSED: [2021-03-01 Mon 09:47]
PDF files and org-mode are strongly related.
I use =org-pdftools= to add an org link type for =pdftools=.

#+BEGIN_SRC emacs-lisp
  (use-package org-pdftools
    :tags '("DOCUMENT" "DESKTOP" "ORG")
    :hook (org-mode . org-pdftools-setup-link))
#+END_SRC

** DONE Epub
CLOSED: [2021-02-09 Tue 16:15]
I am using =nov= to read epub files.

#+BEGIN_SRC emacs-lisp
  (use-package nov
    :tags '("DESKTOP" "DOCUMENT")
    :mode ("\\.epub\\'" . nov-mode)
    :commands (nov-mode)
    :config
    (setq nov-text-width 100))
#+END_SRC
* Version Control / Project Management [100%]
My code project management is articulated around three key points: GIT, github/gist and =projectile=.
GIT is used as the version control manager;
github for the non-sensitive repositories;
gist for snippets and helpers;
=projectile= to provide project helpers.

** DONE Git
CLOSED: [2021-01-04 Mon 15:40]
My configuration for GIT relies mainly on =magit=.
Aside the standard key/hydra configuration,
I copied the external opening from https://gist.github.com/dotemacs/9a0433341e75e01461c9
and the pretty configuration is adapted from https://ekaschalk.github.io/post/pretty-magit/

My whole process relies on the commits following this pattern
#+begin_example
[package] operation: short message

optional further description
#+end_example

where:
 - package :: corresponds to subpart of the repository (so mainly packages, modules, or meta and git related informations).
 - operation :: is ~add~, ~update~, ~fix~, ~clean~ or ~doc~
 - short message :: is a short description
 - optional further description :: is used to complete the short description. It is optional and I don't use it so often; only for complicated tweaks

#+NAME: magit-browse-keybindings
| Key | Function        | Description |
|-----+-----------------+-------------|
| o   | magit-open-repo |             |

#+NAME: magit-status-hydra-keybindings
| Key | Function         | Label        | Description |
|-----+------------------+--------------+-------------|
| d   | magit-diff-range | Diff         |             |
| l   | magit-log-all    | Log all      |             |
| s   | magit-status     | Status       |             |
| t   | git-timemachine  | Time machine |             |


#+NAME: magit-remote-hydra-keybindings
| Key | Function          | Label | Description |
|-----+-------------------+-------+-------------|
| f   | magit-pull-branch | Pull  |             |
| p   | magit-push-other  | Push  |             |


#+NAME: magit-operations-hydra-keybindings
| Key | Function            | Label  | Description |
|-----+---------------------+--------+-------------|
| c   | magit-commit-create | Commit |             |
| <   | project-hydra/body  | back   |             |


#+begin_src emacs-lisp
  (use-package magit
    :tags '("VC" "GIT")
    :commands (magit magit-hydra/body magit-get-current-branch)
    :pretty-hydra
    ((:color blue)
     ("Status/Info" (  ;; NOTE: works only if git-timemachine installed
       <<hydra-keybindings-gen(table=magit-status-hydra-keybindings)>>
      )

      "Remote" (
        <<hydra-keybindings-gen(table=magit-remote-hydra-keybindings)>>
      )

      "Operations" (
        <<hydra-keybindings-gen(table=magit-operations-hydra-keybindings)>>
      )))

    :bind (
      :map magit-mode-map (
        <<keybindings-gen(table=magit-browse-keybindings)>>
      )
    )

    :config

    ;; Ignore recent commit
    (setq magit-status-sections-hook
          '(magit-insert-status-headers
            magit-insert-merge-log
            magit-insert-rebase-sequence
            magit-insert-am-sequence
            magit-insert-sequencer-sequence
            magit-insert-bisect-output
            magit-insert-bisect-rest
            magit-insert-bisect-log
            magit-insert-untracked-files
            magit-insert-unstaged-changes
            magit-insert-staged-changes
            magit-insert-stashes
            magit-insert-unpulled-from-upstream
            magit-insert-unpulled-from-pushremote
            magit-insert-unpushed-to-upstream
            magit-insert-unpushed-to-pushremote))

    ;; Update visualization
    (setq pretty-magit-alist nil
          pretty-magit-prompt nil)

    (defmacro pretty-magit (WORD ICON PROPS &optional NO-PROMPT?)
      "Replace sanitized WORD with ICON, PROPS and by default add to prompts."
      `(prog1
           (add-to-list 'pretty-magit-alist
                        (list (rx bow (group ,WORD (eval (if ,NO-PROMPT? "" ":"))))
                              ,ICON ',PROPS))
         (unless ,NO-PROMPT?
           (add-to-list 'pretty-magit-prompt (concat ,WORD ":")))))

    ;; Operations
    (pretty-magit "add:"      ?  (:foreground "#375E97" :height 1.2) t)
    (pretty-magit "update:"   ?↑   (:foreground "#375E97" :height 1.2) t)
    (pretty-magit "fix:"      ?  (:foreground "#FB6542" :height 1.2) t)
    (pretty-magit "clean:"    ?  (:foreground "#FFBB00" :height 1.2) t)
    (pretty-magit "doc:"      ?  (:foreground "#3F681C" :height 1.2) t)

    ;; Meta information
    (pretty-magit "master"    ?  (:box nil :height 1.2)             t)
    (pretty-magit "origin"    ?  (:box nil :height 1.2)             t)
    (pretty-magit "upstream"  ?  (:box nil :height 1.2)             t)

    (defun add-magit-faces ()
      "Add face properties and compose symbols for buffer from pretty-magit."
      (interactive)
      (with-silent-modifications
        (--each pretty-magit-alist
          (-let (((rgx icon props) it))
            (save-excursion
              (goto-char (point-min))
              (while (search-forward-regexp rgx nil t)
                (compose-region
                 (match-beginning 1) (match-end 1) icon)
                (when props
                  (add-face-text-property
                   (match-beginning 1) (match-end 1) props))))))))

    (advice-add 'magit-status :after 'add-magit-faces)
    (advice-add 'magit-refresh-buffer :after 'add-magit-faces)

    ;; Opening repo externally
    (defun parse-url (url)
      "convert a git remote location as a HTTP URL"
      (if (string-match "^http" url)
          url
        (replace-regexp-in-string "\\(.*\\)@\\(.*\\):\\(.*\\)\\(\\.git?\\)"
                                  "https://\\2/\\3"
                                  url)))
    (defun magit-open-repo ()
      "open remote repo URL"
      (interactive)
      (let ((url (magit-get "remote" "origin" "url")))
        (progn
          (browse-url (parse-url url))
          (message "opening repo %s" url)))))

  (use-package magit-tbdiff
    :tags '("VC" "GIT")
    :after magit)

  (use-package magit-todos
    :tags '("VC" "GIT")
    :commands (magit-todos-mode)
    :hook (magit-mode . magit-todos-mode)
    :custom
    (magit-todos-exclude-globs '(".git/" "*.map"))
    (magit-todos-recursive t)
    (magit-todos-depth 10))

  (use-package why-this
    :tags '("VC" "GIT"))
#+end_src

*** DONE Git helpers
CLOSED: [2021-01-04 Mon 15:39]
In order to be more efficient with git, I also need some helpers.
I use =gitignore-snippets= to provide starting gitignore content;
=git-timemachine= to navigate changes of a dedicated file,
 and =git-patch= to send a patch via email (if necessary obviously.)
#+begin_src emacs-lisp
  (use-package gitignore-snippets
    :tags '("VC" "GIT"))

  (use-package git-timemachine
    :commands (git-timemachine-toggle)
    :tags '("VC" "GIT"))

  (use-package gitpatch
    :tags '("VC" "GIT" "CONNECTED")
    :config
    (setq gitpatch-mail-attach-patch-key "C-c i"))
#+end_src
** DONE Github
CLOSED: [2021-01-04 Mon 15:45]
GIT is the tool I am using for VC.
I am mainly using github to store non-sensitive repositories.
To interact with github in emacs, I rely on three packages:
=forge= as an entry point and which is integrating nicely with magit;
=github-explorer= to browse a repository in emacs;
=github-review= to deal with code reviewing (which integrates well with =forge=).

#+NAME: github-review-entry-keybindings
| Key   | Function                        | Description |
|-------+---------------------------------+-------------|
| C-x r | github-review-forge-pr-at-point |             |

#+NAME: github-review-diff-keybindings
| Key   | Function                         | Description |
|-------+----------------------------------+-------------|
| C-c s | my/github-review-kill-suggestion |             |

#+begin_src emacs-lisp
  (use-package forge
    :demand t
    :tags '("VC" "GIT" "GITHUB" "CONNECTED")
    :after magit
    :custom-face
    (forge-topic-closed ((t (:strike-through t :inherit magit-dimmed)))))

  (use-package github-explorer
    :disabled t
    :tags '("VC" "GIT" "GITHUB" "CONNECTED"))

  (use-package gh-notify
    :straight (:type git :host github :repo "anticomputer/gh-notify"))

  ;; Extracted from https://github.com/anticomputer/gh-notify
  (use-package github-review
    :tags '("VC" "GIT" "GITHUB" "CONNECTED")
    :after forge
    :bind (
      <<keybindings-gen(table=github-review-entry-keybindings)>>

      :map diff-mode-map (
        <<keybindings-gen(table=github-review-diff-keybindings)>>
      )
    )

    :config
    (defun my/github-review-kill-suggestion ()
      ;; kill a region of diff+ as a review suggestion template
      (interactive)
      (setq deactivate-mark t)
      (let ((s-region
             (buffer-substring-no-properties
              (region-beginning)
              (region-end))))
        (kill-new
         (format "# ```suggestion\n%s\n# ```\n"
                 (replace-regexp-in-string "^\\+" "# " s-region))))))
#+end_src

** DONE Gist
CLOSED: [2021-01-04 Mon 15:47]
For scripts/helpers/snippets/... which do not deserve to be saved in a dedicated repository,
I am storing them in a dedicated gist.
The package =gist= provides a nice way of dealing with gists.

#+NAME: gist-mode-hydra-basic-keybindings
| Key | Function           | Label        | Description |
|-----+--------------------+--------------+-------------|
| F   | gist-fetch-current | Fetch        |             |
| +   | gist-add-buffer    | Add buffer   |             |
| -   | gist-remove-file   | Remove file  |             |
| g   | gist-list-reload   | List reload  |             |
| k   | gist-kill-current  | Kill current |             |

#+NAME: gist-mode-hydra-information-keybindings
| Key | Function                      | Label            | Description |
|-----+-------------------------------+------------------+-------------|
| e   | gist-edit-current-description | Edit description |             |
| y   | gist-print-current-url        | Print URL        |             |

#+NAME: gist-mode-hydra-starring-keybindings
| Key | Function    | Label  | Description |
|-----+-------------+--------+-------------|
| ^   | gist-unstar | Unstar |             |
| *   | gist-star   | Start  |             |


#+NAME: gist-mode-hydra-remote-keybindings
#+CAPTION: Gist Hydra Remote Keybindings
| Key | Function                | Label              | Description |
|-----+-------------------------+--------------------+-------------|
| b   | gist-browse-current-url | Browse current URL |             |
| f   | gist-fork               | Fork               |             |

#+begin_src emacs-lisp
  (use-package gist
    :tags '("VC" "GIT" "GITHUB" "CONNECTED")
    :mode-hydra
    (gist-list-mode
     (:color red)
     ("Basic" (
       <<hydra-keybindings-gen(table=gist-mode-hydra-basic-keybindings)>>
      )

      "Information" (
       <<hydra-keybindings-gen(table=gist-mode-hydra-information-keybindings)>>
      )

      "Starring" (
       <<hydra-keybindings-gen(table=gist-mode-hydra-starring-keybindings)>>
      )

      "Remote" (
       <<hydra-keybindings-gen(table=gist-mode-hydra-remote-keybindings)>>
      )
     )))
#+end_src

** DONE Project management
CLOSED: [2021-01-04 Mon 16:03]
=projectile= provides a nice way to restrict a lot of complementary packages to a dedicated project.
A project root directory is defined by the root directory of the repository, which is ideal as all my projects are versioned using GIT.
The default configuration is almost optimal.
I just added a bunch of commands which are based on http://endlessparentheses.com/improving-projectile-with-extra-commands.html?source=rss
I also added a hack to avoi hanging issues because of tramp (see https://github.com/bbatsov/projectile/issues/1232)

#+NAME: projectile-hydra-find-keybinding
| Key | Function                          | Label                  | Description |
|-----+-----------------------------------+------------------------+-------------|
| d   | projectile-find-dir               | Find dir               |             |
| s-f | projectile-find-file              | Find file              |             |
| ff  | projectile-find-file-dwim         | File dwim              |             |
| fd  | projectile-find-file-in-directory | Find file in directory |             |
| r   | projectile-recentf                | Recentf                |             |


#+NAME: projectile-hydra-search-keybinding
| Key | Function               | Label       | Description |
|-----+------------------------+-------------+-------------|
| a   | projectile-ag          | Ag chairs   |             |
| o   | projectile-multi-occur | Multi-occur |             |


#+NAME: projectile-hydra-buffers-keybinding
| Key | Function                | Label        | Description |
|-----+-------------------------+--------------+-------------|
| K   | projectile-kill-buffers | Kill buffers |             |


#+NAME: projectile-hydra-cache-keybinding
| Key | Function                          | Label                | Description |
|-----+-----------------------------------+----------------------+-------------|
| p   | projectile-switch-project         | Switch to project    |             |
| x   | projectile-remove-known-project   | Remove known project |             |
| X   | projectile-cleanup-known-projects | Clean known projects |             |
| z   | projectile-cache-current-file     | Cache current file   |             |



#+begin_src emacs-lisp
  (use-package projectile
    :tags '("PROJECT")
    :pretty-hydra
    ((:color teal :hint nil :title "PROJECTILE: %(projectile-project-root)")
     ("Find File" (
        <<hydra-keybindings-gen(table=projectile-hydra-find-keybinding)>>
      )

      "Search/Tags" (
        <<hydra-keybindings-gen(table=projectile-hydra-search-keybinding)>>
      )

      "Buffers" (
        <<hydra-keybindings-gen(table=projectile-hydra-buffers-keybinding)>>
      )

      "Cache" (
        <<hydra-keybindings-gen(table=projectile-hydra-cache-keybinding)>>
      )))

    :config

    ;; Global configuration
    (setq projectile-switch-project-action 'neotree-projectile-action
          projectile-enable-caching t
          projectile-create-missing-test-files t
          projectile-switch-project-action #'projectile-commander
          projectile-ignored-project-function 'file-remote-p)

    ;; Defining some helpers
    (def-projectile-commander-method ?s
      "Open a *shell* buffer for the project."
      ;; This requires a snapshot version of Projectile.
      (projectile-run-shell))

    (def-projectile-commander-method ?c
      "Run `compile' in the project."
      (projectile-compile-project nil))

    (def-projectile-commander-method ?\C-?
      "Go back to project selection."
      (projectile-switch-project))

    ;; Keys
    (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)

    ;; Activate globally
    (projectile-mode)

    ;; Needed to avoid tramp hanging in buffer listing
    (defadvice projectile-project-root (around ignore-remote first activate)
      (unless (file-remote-p default-directory) ad-do-it)))
#+end_src

* Shell [100%]
Sometimes I need to start a terminal inside Emacs (not only for geekery-purposes).
To do so, I rely now on =vterm= coupled with zsh.
I have a specific PowerLevel10K theme for emacs vterm which is more compact (see my zshrc configuration).

#+NAME: multi-vterm-mode-keybindings
| Key | Function                             | Description |
|-----+--------------------------------------+-------------|
| M-r | multi-vterm-rename-buffer            |             |

#+BEGIN_SRC emacs-lisp
  (use-package vterm
    :tags '("TERM")
    :config
    ;; Cleaning
    (setq vterm-kill-buffer-on-exit t)

    ;; Function keys are not used in therm
    (mapcar (lambda (key)
              (define-key vterm-mode-map (kbd key) nil))
            '("<f1>" "<f2>" "<f3>" "<f4>" "<f5>" "<f6>"
              "<f7>" "<f8>" "<f9>" "<f10>" "<f11>" "<f12>"
              "<prior>" "<next>"))

    ;; Better directory tracking
    (push (list "update-pwd" (lambda (path) (setq default-directory path)))
          vterm-eval-cmds)

    ;; Opening file in emacs directly
    (push (list "find-file-below"
                (lambda (path)
                  (if-let* ((buf (find-file-noselect path))
                            (window (display-buffer-below-selected buf nil)))
                      (select-window window)
                    (message "Failed to open file: %s" path))))
          vterm-eval-cmds))

  (use-package multi-vterm
    :tags '("TERM")
    :bind (
      :map vterm-mode-map (
        <<keybindings-gen(table=multi-vterm-mode-keybindings)>>
      )
    ))
#+END_SRC

* DONE File manager [100%]
I am using emacs as my main file manager.
To do so, I rely on =dired= which is builtin package which I tweaked massively and I added multiple subpackages to improve UX.
I also added support for basic image processing and some additional operations (trashing, visualising diffs, ...).

** DONE Dired [100%]
CLOSED: [2021-01-04 Mon 18:55]
The configuration of =dired= focuses mainly on defining keys, tuning the files to omit, and tweaking the LS command used to get the informations.
The hydra mapping is adapted from https://github.com/abo-abo/hydra/wiki/Dired.
I also replace a base deletion by moving the files/directories to the trash.

#+NAME: dired-global-keybindings
| Key     | Function        | Description |
|---------+-----------------+-------------|
| C-x C-d | dired           |             |
| C-x f   | dirvish-fd      |             |
| C-c 1   | find-name-dired |             |
| C-c 2   | find-grep-dired |             |

#+NAME: dired-mode-keybindings
| Key      | Function                        | Description |
|----------+---------------------------------+-------------|
| *        | dirvish-mark-menu               |             |
| C-o      | dired-omit-mode                 |             |
| M-s      | dirvish-setup-menu              |             |
| SPC      | dirvish-history-jump            |             |
| TAB      | dirvish-toggle-subtree          |             |
| b        | dirvish-bookmark-jump           |             |
| e        | dired-open-externally           |             |
| f        | dirvish-file-info-menu          |             |
| p        | dired-emms-play                 |             |
| r        | dirvish-fd-jump                 |             |
| M-<up>   | dired-up-directory              |             |
| M-<down> | dired-find-file                 |             |
| T        | dired-do-transfer-to-remarkable |             |

#+NAME: dired-launch-entry-keybindings
| Key        | Function             | Description |
|------------+----------------------+-------------|
| <C-return> | dired-launch-command |             |

#+begin_src emacs-lisp
  (use-package dirvish
    :tags '("FILE_MANAGEMENT" "DIRED")
    :init
    ;; Let Dirvish take over Dired globally
    (dirvish-override-dired-mode)

    (setq-default dired-omit-files "^\\.\\([a-zA-Z0-9].*\\)?$"
                  dired-omit-mode t)

    :hook (dired-mode . dired-omit-mode)

    :bind (
      <<keybindings-gen(table=dired-global-keybindings)>>

      :map dired-mode-map
      <<keybindings-gen(table=dired-mode-keybindings)>>

      ;; Remap some keys
      ([remap dired-sort-toggle-or-edit] . dirvish-quicksort)
      ([remap dired-do-redisplay]        . dirvish-ls-switches-menu)
      ([remap dired-summary]             . dirvish-dispatch)
      ([remap dired-do-copy]             . dirvish-yank-menu)
    )

    :custom
    (dirvish-attributes '(dirvish-extras
                          dirvish-vc
                          dirvish-yank
                          dirvish-subtree
                          file-size))

    (dirvish-yank-keys '(("y" "Yank (paste) here"           dirvish-yank)
                         ("m" "Move here"                   dirvish-move)
                         ("s" "Make symlinks here"          dirvish-symlink)
                         ("r" "Make relative symlinks here" dirvish-relative-symlink)
                         ("h" "Make hardlinks here"         dirvish-hardlink)
                         ("d" "Duplicate here"              dired-do-copy)))

    (dirvish-bookmarks-alist
     '(("h" "~/" "Home")
       ("d" "~/Downloads/" "Downloads")
       ("t" "~/.local/share/Trash/files/" "TrashCan")))

    :config

    ;; When deleting, send actually to the trash!
    (setq dired-recursive-deletes 'always
          delete-by-moving-to-trash t)

    ;; Enable mouse drag-and-drop files to other applications
    (setq dired-mouse-drag-files t                    ; added in Emacs 29
          mouse-drag-and-drop-region-cross-program t) ; added in Emacs 29

    ;; Make sure to use the long name of flags when exists
    ;; eg. use "--almost-all" instead of "-A"
    ;; Otherwise some commands won't work properly
    (setq dired-listing-switches
          "-l --almost-all --human-readable --time-style=long-iso --group-directories-first --no-group"
          dirvish-attributes
          '(vc-state subtree-state all-the-icons collapse git-msg file-size))

    (defun dired-do-transfer-to-remarkable ()
      "Transfer the marked PDF files to the remarkable. Any other filetype will be ignored."
      (interactive)
      (mapc (lambda (x)
              (when (s-ends-with-p ".pdf" x t)
                (message "Transfering \"%S\" to the reMarkable" x)
                (call-process "pdf2remarkable" nil nil nil x)))
            (dired-get-marked-files nil nil nil nil t)))

    (defun restart-remarkable-ui ()
      "Restarting the ReMarkable UI to acknowledge the presence of the new PDF files."
      (interactive)
      (call-process "/bin/ssh" nil "*remarkable*" nil "remarkable" "systemctl" "restart" "xochitl"))
    )

  (use-package dired-launch
    :tags '("FILE_MANAGEMENT" "DIRED")
    :bind (:map dired-mode-map (
                 <<keybindings-gen(table=dired-launch-entry-keybindings)>>
          ))

    :config
    (setq dired-launch-default-launcher '("xdg-open")))
#+end_src

** DONE Diff
CLOSED: [2021-01-04 Mon 19:10]
Visualizing diff is important especially when I have a file, outside of project files, which is present on multiple machines.
Diff visualization relies mainly on =ediff= but to which I added two primitives to focus on some regions (=diff-region= followed by =diff-region-now=).

#+begin_src emacs-lisp
  (use-package ediff
    :tags '("FILE_MANAGEMENT" "DIFF")
    :config
    (autoload 'diff-mode "diff-mode" "Diff major mode" t)
    (setq diff-switches "-u"
          ediff-auto-refine-limit (* 2 14000)
          ediff-window-setup-function 'ediff-setup-windows-plain
          ediff-split-window-function
          (lambda (&optional arg)
            (if (> (frame-width) 160)
                (split-window-horizontally arg)
              (split-window-vertically arg)))))

  (defun diff-region ()
    "Select a region to compare"
    (interactive)
    (when (use-region-p) ; there is a region
      (let (buf)
        (setq buf (get-buffer-create "*Diff-regionA*"))
        (save-current-buffer
          (set-buffer buf)
          (erase-buffer))
        (append-to-buffer buf (region-beginning) (region-end))))
    (message "Now select other region to compare and run `diff-region-now`"))

  (defun diff-region-now ()
    "Compare current region with region already selected by `diff-region`"
    (interactive)
    (when (use-region-p)
      (let (bufa bufb)
        (setq bufa (get-buffer-create "*Diff-regionA*"))
        (setq bufb (get-buffer-create "*Diff-regionB*"))
        (save-current-buffer
          (set-buffer bufb)
          (erase-buffer))
        (append-to-buffer bufb (region-beginning) (region-end))
        (ediff-buffers bufa bufb))))
#+end_src

** DONE Treemacs
CLOSED: [2021-01-04 Mon 19:25]
To have a quick visualisation (on the sidebar) of the project directory tree (and a little bit further), I am using treemacs.
Aside tweaking the configuration to fit more my needs, a key part of the configuration is to redefine the function ~treemacs--setup-mode-line~.
This is necessary in order to avoid issues with the modeline I use.
I added support for visualizing the git status (=treemacs-magit=),
for project restriction (=treemacs-projectile=) and adding some icons (=treemacs-icons-dired=).

#+NAME: treemacs-entry-keybindings
| Key  | Function | Description |
|------+----------+-------------|
| <f8> | treemacs |             |

#+begin_src emacs-lisp
  (use-package treemacs
    :tags '("FILE_MANAGEMENT" "TREEMACS")
    :bind (
      <<keybindings-gen(table=treemacs-entry-keybindings)>>
    )

    :functions (treemacs-follow-mode treemacs-filewatch-mode)
    :config
    (setq treemacs-collapse-dirs                 (if treemacs-python-executable 3 0)
          treemacs-deferred-git-apply-delay      0.5
          treemacs-display-in-side-window        t
          treemacs-eldoc-display                 t
          treemacs-file-event-delay              5000
          treemacs-file-follow-delay             0.2
          treemacs-follow-after-init             t
          treemacs-git-integration               t
          treemacs-git-command-pipe              ""
          treemacs-goto-tag-strategy             'refetch-index
          treemacs-indentation                   2
          treemacs-indentation-string            " "
          treemacs-is-never-other-window         nil
          treemacs-max-git-entries               5000
          treemacs-missing-project-action        'ask
          treemacs-no-png-images                 nil
          treemacs-no-delete-other-windows       t
          treemacs-project-follow-cleanup        nil
          treemacs-persist-file                  (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
          treemacs-position                      'left
          treemacs-recenter-distance             0.1
          treemacs-recenter-after-file-follow    nil
          treemacs-recenter-after-tag-follow     nil
          treemacs-recenter-after-project-jump   'always
          treemacs-recenter-after-project-expand 'on-distance
          treemacs-show-cursor                   nil
          treemacs-show-hidden-files             t
          treemacs-silent-filewatch              nil
          treemacs-silent-refresh                nil
          treemacs-sorting                       'alphabetic-desc
          treemacs-space-between-root-nodes      t
          treemacs-tag-follow-cleanup            t
          treemacs-tag-follow-delay              1.5
          treemacs-width                         35)

    (defun treemacs--setup-mode-line () "Redefined modeline function to not do anything.")
    (treemacs-follow-mode t)
    (treemacs-filewatch-mode t))

  (use-package treemacs-projectile
    :tags '("FILE_MANAGEMENT" "TREEMACS" "PROJECT")
    :functions treemacs-projectile-create-header
    :config
    (setq treemacs-header-function #'treemacs-projectile-create-header))

  (use-package treemacs-magit
    :tags '("FILE_MANAGEMENT" "TREEMACS" "VC" "GIT"))
#+end_src

** DONE Trashed
CLOSED: [2022-05-07 Sat 08:53]
=rm= is pretty dangerous, so I use =trash-cli= and then manage the trash regularly.
To manage the trash via emacs, =trashed= provides a really interface.

#+begin_src emacs-lisp
  (when (executable-find "trash")
    (use-package trashed
      :tags '("FILE_MANAGEMENT" "DIRED")
      :init
      (defun empty-trash()
        "Command to empty the trash (for now gnome/linux specific)"
        (interactive)
        (shell-command "rm -rf ~/.local/share/Trash/*"))

      (defun open-trash-dir()
        "Command to open the trash dir"
        (interactive)
        (find-file "~/.local/share/Trash/files"))))
#+end_src

** DONE Current File Information
CLOSED: [2023-02-02 Thu 15:56]
#+begin_src emacs-lisp :lexical no
    (use-package file-info
      :tags '("FILE_MANAGEMENT")
      :straight (:host github :repo "artawower/file-info.el")
      :bind (("C-c d" . 'file-info-show)))
#+end_src

* DONE Online [100%]
I am using emacs to deal with a lot of online stuffy.
The main services I consult using emacs are: RSS streams, emails, chats, "exchange services" and CD releases.

** DONE RSS [100%]
To retrieve and visualize my RSS feeds, I use =elfeed=.
The database is stored in the =~/.emacs.d/elfeed=.
I mapped the key =f9= to quickly access the list of entries.
I rely on =elfeed-org= to store the list of feeds and defines some tags as well as on =elfeed-score= to filter entries based on handmade rules.

#+NAME: elfeed-entry-keybindings
| Key  | Function | Description |
|------+----------+-------------|
| <f9> | elfeed   |             |

#+begin_src emacs-lisp
  (use-package elfeed
    :straight (elfeed :type git :host github :repo "skeeto/elfeed"
                      :fork (:host github
                                   :repo "seblemaguer/elfeed"
                                   :branch "fix_emms_bug"))
    :tags '("CONNECTED" "RSS")
    :commands (elfeed elfeed-update)
    :no-require t
    :bind (
      <<keybindings-gen(table=elfeed-entry-keybindings)>>
    )

    :config
    ;; Change the storage directory
    (setq elfeed-db-directory (format "%s/elfeed" user-emacs-directory)

          ;; Formatting dates
          elfeed-search-date-format '("%Y-%m-%d %H:%M" 17 :left))

    (when (fboundp 'elfeed-define-faces)
      (elfeed-define-faces)))
#+end_src

*** DONE Org connection
CLOSED: [2021-01-04 Mon 19:41]
I prefer to store the configuration in an org-mode file as it is more readable.
This configuration is part of my "roaming" so I can have access to it easily.
However, to properly disconnect from work when I am at home, I distinguish 2 RSS configurations:
  - =rss.org= which contains my entertainment feeds,
  - =rss_pro.org= which contains my "work" dedicated feeds.
Because I need a break once and a while at work, I load both files on my work machine but only =rss.org= when I use my personal laptop.

#+begin_src emacs-lisp
  (use-package elfeed-org
    :tags '("CONNECTED" "RSS")
    :if (file-directory-p cloud-org-root-dir)
    :hook (after-init . loading-elfeed)
    :commands (elfeed-org)
    :init
    (defvar rss-files (list (concat cloud-org-root-dir "perso/configuration/rss.org"))
      "RSS ORG filename defined based on the type of machine I am using (pro or other!)")

    ;; Working machine, add the pro list of feeds as well
    (when (string= (system-name) work-hostname)
      (add-to-list 'rss-files (concat cloud-org-root-dir "perso/configuration/rss_pro.org")))

    (defun loading-elfeed ()
      (when (file-exists-p (car rss-files))
        (progn
          (elfeed-org)
          (setq rmh-elfeed-org-files rss-files)
          (rmh-elfeed-org-process rmh-elfeed-org-files rmh-elfeed-org-tree-id)))))
#+end_src

*** DONE Youtube specificities
CLOSED: [2022-07-25 Mon 07:44]
Some of my feeds come from youtube so =elfeed-tube= provides a nice interface to play the video from the feed.

#+NAME: elfeed-tube-entry-keybindings
| Key                 | Function          | Description |
|---------------------+-------------------+-------------|
| F                   | elfeed-tube-fetch |             |
| [remap save-buffer] | elfeed-tube-save  |             |

#+NAME: elfeed-tube-mpv-keybindings
| Key     | Function                    | Description |
|---------+-----------------------------+-------------|
| C-c C-f | elfeed-tube-mpv-follow-mode |             |
| C-c C-p | elfeed-tube-mpv             |             |
| C-c C-w | elfeed-tube-mpv-where       |             |

#+begin_src emacs-lisp
  (use-package elfeed-tube
    :straight (:type git :host github :repo "karthink/elfeed-tube" :files (:defaults (:exclude "elfeed-tube-mpv.el")))
    :after elfeed
    :tags '("CONNECTED" "RSS" "YOUTUBE")
    :demand t
    :config
    ;; (setq elfeed-tube-auto-save-p nil) ; default value
    ;; (setq elfeed-tube-auto-fetch-p t)  ; default value
    (elfeed-tube-setup)

    :bind (
      :map elfeed-show-mode-map (
        <<keybindings-gen(table=elfeed-tube-entry-keybindings)>>
      )

      :map elfeed-search-mode-map (
        <<keybindings-gen(table=elfeed-tube-entry-keybindings)>>
      )
    ))

  (use-package elfeed-tube-mpv
    :straight (:type git :host github :repo "karthink/elfeed-tube" :files ("elfeed-tube-mpv.el"))
    :tags '("CONNECTED" "RSS" "YOUTUBE")

    :bind (
      :map elfeed-show-mode-map (
        <<keybindings-gen(table=elfeed-tube-mpv-keybindings)>>
      )
    ))
#+end_src

*** DONE Notification part
CLOSED: [2021-01-04 Mon 19:46]
For the notification, we simply have to connect sauron and elfeed.
I just need to define a default priority level for each feed.

#+begin_src emacs-lisp
  (use-package sauron-elfeed
    :straight sauron
    :tags '("CONNECTED" "RSS" "NOTIFICATION")
    :commands (elfeed-update-background-start sauron-elfeed-start)
    :hook
    (after-init . sauron-elfeed-start)
    (after-init . elfeed-update-background-start)

    :config
    (cl-loop for feed in elfeed-feeds
             do (when (member 'mustread (cdr feed))
                  (puthash (car feed) 3 sauron-elfeed-prio-hash))))
#+end_src

*** DONE Scoring support
CLOSED: [2022-02-04 Fri 19:34]
Using =elfeed-score= helps me to organize my feeds to have a better view of what is going in the online world.

#+begin_src emacs-lisp
  (use-package elfeed-score
    :tags '("CONNECTED" "RSS")
    :config
    (elfeed-score-enable)
    (define-key elfeed-search-mode-map "=" elfeed-score-map)
    (setq elfeed-search-print-entry-function #'elfeed-score-print-entry
          elfeed-search-sort-function #'elfeed-score-sort))
#+end_src

**** DONE The score rules
CLOSED: [2022-02-04 Fri 19:33]
This part defines the rules to assign the scores for each RSS entries.
A lot are assigned for work related informations and are not actually used in computers which are not the work machine.
This part is also tangled in its dedicated file =~/.emacs.d/elfeed.score=.
Obviously this part is meant to evolve regularly!

#+begin_src emacs-lisp :results output replace :tangle ~/.emacs.d/elfeed.score
  (("title")

   ("content")
   ("title-or-content"
    ;; Emacs related

    ;; Podcasts
    (:text "géraldine mosna-savoye" :title-value 5 :content-value 10 :type r)
    (:text "guillaume meurice" :title-value 5 :content-value 5 :type s)
    (:text "constance" :title-value 5 :content-value 5 :type s)

    ;; Work
    (:text "\\(speech synthesis\\|TTS\\|text-to-speech\\|text to speech\\)" :title-value 10 :content-value 5 :type s)
    (:text "speech synthesis evaluation" :title-value 20 :content-value 10 :type s)
    (:text "evaluate \\(speech synthesis\\|synthetic speech\\)" :title-value 10 :content-value 10 :type s)
    (:text "evaluate \\(speech synthesis\\|synthetic speech\\)" :title-value 10 :content-value 10 :type s)


    ;; Bulk
    (:text "unicode" :title-value -1 :content-value -1 :type s)
    (:text "unicode" :title-value -10 :content-value -10 :type s))

   ("tag")

   ("authors")
   ("feed"
    (:text "Si tu écoutes, j'annule tout" :value -1 :attr t :type s))

   ;; Mark every entries scored below -10 & adjust tags if necessary
   (mark -10)
   ("adjust-tags"))
#+end_src

** DONE Mail [100%]
CLOSED: [2021-01-05 Tue 09:08]
Emacs is my only email client.
It is based around the ecosystem =mu/mu4e= which provides everything we need to deal with emails.
This configuration is articulated around three parts: the authentification part, the composing emails part and the mu4e part.

*** DONE Authentification
CLOSED: [2021-01-05 Tue 08:20]
In previous emacs version (< 27), it was necessary to configure the package =starttls=.
This configuration is remaining here for backward compatibility purposes.

#+begin_src emacs-lisp
  (use-package starttls
    :straight nil
    :tags '("CONNECTED")
    :if (< emacs-major-version 27)
    :config
    (setq starttls-use-gnutls t
          starttls-gnutls-program "gnutls-cli"
          starttls-extra-arguments '("--insecure")
          auth-sources '("~/.authinfo.gpg")))
#+end_src

*** DONE Composing emails
CLOSED: [2021-01-05 Tue 08:27]
To compose emails, I rely on the combination of multiple packages.
Obviously, the entry point is the package =message= whose ~message-mode~ is the major mode used to edit new emails.
I configured the package to support some additional features like a proper signature and a proper formatting.
I also updated the citation line/format.

As I am using multiple account, I use the package =smtpmail-multi= to sort this out.
The default account is my TCD email as it is my daily use email.

Because, sometimes, I want to send rich emails, I use =org-msg= which relies on the HTML exporter provided by =org= to generate HTML emails.
Finally, as I am quite absent-minded, I use a reminder to not forget the attachment: =message-attachment-reminder=.

#+NAME: org-msg-edit-keybindings
| Key         | Function                        | Description |
|-------------+---------------------------------+-------------|
| C-c RET C-c | mml-secure-message-sign-encrypt |             |
| C-c RET C-s | mml-secure-message-sign         |             |
| C-c RET f   | org-msg-attach                  |             |
| C-c RET t   | message-goto-to                 |             |
| C-c RET c   | message-goto-cc                 |             |
| C-c RET b   | message-goto-bcc                |             |
| C-c RET o   | org-msg-goto-body               |             |
| C-c RET s   | message-goto-subject            |             |

#+begin_src emacs-lisp
  (use-package message
    :straight nil
    :tags '("CONNECTED" "MAIL")
    :hook
    (message-mode . format-hook-message)

    :init
    (defun format-hook-message ()
      "Specify some formatting rules for email message writing."
      (auto-fill-mode -1)
      (visual-fill-column-mode -1)
      (diff-hl-mode -1)
      (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
      (visual-line-mode))

    :config
    (setq message-auto-save-directory nil
          message-citation-line-function 'message-insert-formatted-citation-line
          message-citation-line-format  "\n\n-----------------------\nOn %a, %b %d %Y (%-H:%M %Z), %N wrote:\n"
          message-sendmail-f-is-evil nil
          message-kill-buffer-on-exit t
          message-signature-file nil
          message-fill-column 100))

  (use-package smtpmail-multi
    :tags '("CONNECTED" "MAIL")
    :init
    (defun my-oauth2-fetch-access-token (user)
      (replace-regexp-in-string
       "\n$" ""
       (with-temp-buffer
         (call-process
          "oauth2mail" nil t nil
          "--encode-xoauth2"
          "-c" (expand-file-name oauth2mail-config-file) user)
         (buffer-string))))

    (cl-defmethod smtpmail-try-auth-method
      (process (_mech (eql my-xoauth2)) user password)
      (let* ((access-token (my-oauth2-fetch-access-token user)))
        (smtpmail-command-or-throw
         process
         (concat "AUTH XOAUTH2 " access-token)
         235)))

    ;; Register the method
    (with-eval-after-load 'smtpmail
      (add-to-list 'smtpmail-auth-supported 'my-xoauth2))

    :config
    ;; Get account informations from private file
    (when (fboundp 'set-smtpmail-multi-accounts)
      (set-smtpmail-multi-accounts))

    ;; Define default environment
    (setq user-full-name "Sébastien Le Maguer"
          smtpmail-multi-default-account 'tcd
          message-send-mail-function 'smtpmail-multi-send-it
          mail-host-address "tcd.ie"

          ;; Debug part
          smtpmail-debug-info nil
          smtpmail-debug-verbose nil))

  (use-package org-msg
    :straight '(:host github :repo "jeremy-compostella/org-msg")
    :bind (
      :map org-msg-edit-mode-map (
        <<keybindings-gen(table=org-msg-edit-keybindings)>>
      )
    )

    :hook
    (mu4e-compose-pre . org-msg-mode)
    (org-msg-edit-mode . format-hook-message)

    :config
    (defun myorg/mu4e-compose-org-msg()
      (org-hide-block-all)
      (org-hide-drawer-all))

    (setq org-msg-startup "hidestars indent inlineimages"
          org-msg-default-alternatives '((new	   	       . (text))
                                         (reply-to-html  . (text html))
                                         (reply-to-text  . (text)))
          org-msg-enforce-css nil
          org-msg-convert-citation t
          org-msg-signature (format
                             "\n\n#+begin_signature\n--\n%s\n#+end_signature"
                             (with-temp-buffer
                               (insert-file-contents
                                (format "%s/third_parties/mail/signature" user-emacs-directory))
                               (buffer-string))))

    (advice-add 'org-msg-post-setup :after 'myorg/mu4e-compose-org-msg))

  (use-package message-attachment-reminder
    :disabled t
    :tags '("CONNECTED" "MAIL")
    :ensure t)
#+end_src

*** DONE Mu4e [100%]
CLOSED: [2021-01-05 Tue 08:53]
As I previously indicated, =mu4e= is my entry point to deal with emails.
However, it can't be installed via melpa.
I have a bunch of scripts which are configuring my linux environment on ~~/environment/~.
These scripts are installing ~mu~ and =mu4e= so the first thing to do here is to point the current configuration ~load-path~.

The core of the configuration is separated in four main parts:
the hydra definition, the adaptation of the ~mu4e~ environment, the introduction of new primitives and, finally, the definition of contexts.
The last part is the most important as it provides the configuration for the mail accounts.
These configurations are set in the private configuration file and provided by the function =set-mu4e-contexts=.
The introduced new primitive provides a connection to EAF (~mu4e-eaf-wrapper~; see further for EAF).
I also redesigned the header buffer.

#+NAME: mu4e-entry-keybindings
| Key  | Function | Description |
|------+----------+-------------|
| <f2> | mu4e     |             |

#+NAME: mu4e-hydra-general-keybindings
| Key | Function                    | Label          | Description |
|-----+-----------------------------+----------------+-------------|
| n   | mu4e-headers-next           | Next           |             |
| p   | mu4e-headers-previous       | Previous       |             |
| [   | mu4e-select-next-unread     | Next unred     |             |
| ]   | mu4e-select-previous-unread | Previous unred |             |
| y   | mu4e-select-other-view      | Switch view    |             |
| R   | mu4e-compose-reply          | Reply          |             |
| C   | mu4e-compose-new            | Compose        |             |
| F   | mu4e-compose-forward        | Forward        |             |
| o   | my/org-capture-mu4e         | Org capture    |             |

#+NAME: mu4e-hydra-search-keybindings
| Key | Function                          | Label            | Description |
|-----+-----------------------------------+------------------+-------------|
| s   | mu4e-headers-search               | Search           |             |
| S   | mu4e-headers-search-edit          | Edit prev. query |             |
| /   | mu4e-headers-search-narrow        | Narrow search    |             |
| b   | mu4e-headers-search-bookmark      | Search bookmark  |             |
| B   | mu4e-headers-search-bookmark-edit | Edit bookmark    |             |
| {   | mu4e-headers-query-prev           | Previous query   |             |
| }   | mu4e-headers-query-next           | Next query       |             |
| C-+ | mu4e-headers-split-view-grow      | Show more        |             |
| C-- | mu4e-headers-split-view-shrink    | Show less        |             |

#+NAME: mu4e-hydra-mark-keybindings
| Key | Function                         | Label           | Description |
|-----+----------------------------------+-----------------+-------------|
| !   | mu4e-headers-mark-for-read       | Read            |             |
| ?   | mu4e-headers-mark-for-unread     | Unread          |             |
| r   | mu4e-headers-mark-for-refile     | Refile          |             |
| u   | mu4e-headers-mark-for-unmark     | Unmark          |             |
| U   | mu4e-mark-unmark-all             | Unmark All      |             |
| d   | mu4e-headers-mark-for-trash      | Trash           |             |
| D   | mu4e-headers-mark-for-delete     | Delete          |             |
| m   | mu4e-headers-mark-for-move       | Move            |             |
| a   | mu4e-headers-action              | Action          |             |
| A   | mu4e-headers-mark-for-action     | Mark for action |             |
| *   | mu4e-headers-mark-for-something  | *thing          |             |
| #   | mu4e-mark-resolve-deferred-marks | Deferred        |             |
| %   | mu4e-headers-mark-pattern        | Pattern         |             |
| &   | mu4e-headers-mark-custom         | Custom          |             |
| +   | mu4e-headers-mark-for-flag       | Flag            |             |
| -   | mu4e-headers-mark-for-unflag     | Unflag          |             |
| t   | mu4e-headers-mark-subthread      | Subthread       |             |
| T   | mu4e-headers-mark-thread         | Thread          |             |

#+NAME: mu4e-hydra-misc-keybindings
| Key | Function                     | Label           | Description |
|-----+------------------------------+-----------------+-------------|
| q   | mu4e~headers-quit-buffer     | Quit            |             |
| H   | mu4e-display-manual          | Help            |             |
| #   | mu4e-view-pipe               | Through shell   |             |
| `   | mu4e-update-mail-and-index   | Update          |             |
| ;   | mu4e-context-switch          | Switch context  |             |
| j   | mu4e~headers-jump-to-maildir | Jump to maildir |             |

#+NAME: mu4e-hydra-switches-keybindings
| Key | Function                            | Label           | Description |
|-----+-------------------------------------+-----------------+-------------|
| O   | mu4e-headers-change-sorting         | Sorting         |             |
| P   | mu4e-headers-toggle-threading       | Threading       |             |
| Q   | mu4e-headers-toggle-full-search     | Full searching  |             |
| V   | mu4e-headers-toggle-skip-duplicates | Skip dups       |             |
| W   | mu4e-headers-toggle-include-related | Include related |             |

#+NAME: mu4e-headers-mode-keybindings
| Key       | Function                     | Description |
|-----------+------------------------------+-------------|
| <tab>     | mu4e-headers-toggle-at-point |             |
| <left>    | mu4e-headers-fold-at-point   |             |
| <S-left>  | mu4e-headers-fold-all        |             |
| <right>   | mu4e-headers-unfold-at-point |             |
| <S-right> | mu4e-headers-unfold-all      |             |
| #         | mu4e-view-pipe               |             |
| .         | mu4e-hydra/body              |             |

#+NAME: mu4e-main-mode-keybindings
| Key | Function                   | Description                                                  |
|-----+----------------------------+--------------------------------------------------------------|
| u   | mu4e-update-mail-and-index |                                                              |
| q   | previous-buffer            | Override the "exit" mu4e to always keep it in the background |

#+NAME: message-mode-keybindings
| Key     | Function            | Description |
|---------+---------------------+-------------|
| C-c C-a | mail-add-attachment |             |


#+begin_src emacs-lisp
  (use-package mu4e
    :straight (:host github
                     :repo "djcb/mu"
                     :branch "master"
                     :files ("build/mu4e/*.el" "build/mu4e/*.elc" "mu4e/*.el" "mu4e/*.elc")
                     :pre-build (("./autogen.sh") ("make")))
    :tags '("CONNECTED" "MAIL")
    :commands (mu4e)
    :custom   (mu4e-mu-binary (expand-file-name "build/mu/mu" (straight--repos-dir "mu")))
    :bind (
      <<keybindings-gen(table=mu4e-entry-keybindings)>>
    )

    :hook
    (after-init . (lambda () (mu4e t)))

    :pretty-hydra
    ((:color blue :hint nil)
     ("General" (
        <<hydra-keybindings-gen(table=mu4e-hydra-general-keybindings)>>
      )

      "Search" (
        <<hydra-keybindings-gen(table=mu4e-hydra-search-keybindings)>>
      )

      "Mark" (
        <<hydra-keybindings-gen(table=mu4e-hydra-mark-keybindings)>>
      )

      "Miscellany" (
        <<hydra-keybindings-gen(table=mu4e-hydra-misc-keybindings)>>
      )

      "Switches" (
        <<hydra-keybindings-gen(table=mu4e-hydra-switches-keybindings)>>
      )))

    :bind (
      :map mu4e-headers-mode-map (
        <<keybindings-gen(table=mu4e-headers-mode-keybindings)>>
      )

      :map mu4e-main-mode-map (
        <<keybindings-gen(table=mu4e-main-mode-keybindings)>>
      )

      :map message-mode-map (
        <<keybindings-gen(table=message-mode-keybindings)>>
      )
    )

    :custom
    ;; File management
    (mu4e-maildir "~/mail")
    (mu4e-attachment-dir "~/Downloads/")
    (mu4e-change-filenames-when-moving t)

    ;; User interaction
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-compose-forward-as-attachment nil)
    (mu4e-hide-index-messages t)
    (mu4e-compose-context-policy 'ask-if-none)
    (mu4e-confirm-quit nil)
    (mu4e-compose-dont-reply-to-self t)
    (mu4e-update-interval nil)

    ;; Gui
    (mu4e-view-show-addresses t)
    (mu4e-view-show-images t)
    (mu4e-view-use-gnus t)
    (mu4e-use-fancy-chars t)

    ;; headers
    (mu4e-headers-date-format "%a %d %b %Y")
    (mu4e-headers-time-format "%H:%M:%S")

    :config
    ;; use imagemagick, if available
    (when (fboundp 'imagemagick-register-types)
      (imagemagick-register-types))

    (defun mu4e~headers-line-apply-flag-face (msg line)
      line)

    (defun mu4e~headers-field-apply-basic-properties (msg field val width)
      (cl-case field
        (:subject
         (propertize
          (concat
           (mu4e~headers-thread-prefix (mu4e-message-field msg :thread))
           (truncate-string-to-width val 600))
          'face
          (let ((flags (mu4e-message-field msg :flags)))
            (cond
             ((memq 'trashed flags) 'mu4e-trashed-face)
             ((memq 'draft flags) 'mu4e-draft-face)
             ((or (memq 'unread flags) (memq 'new flags))
              'mu4e-unread-face)
             ((memq 'flagged flags) 'mu4e-flagged-face)
             ((memq 'replied flags) 'mu4e-replied-face)
             ((memq 'passed flags) 'mu4e-forwarded-face)
             (t 'mu4e-header-face)))))
        (:thread-subject
         (propertize
          (mu4e~headers-thread-subject msg)
          'face 'font-lock-doc-face))
        ((:maildir :path :message-id) val)
        ((:to :from :cc :bcc)
         (propertize
          (mu4e~headers-contact-str val)
          'face 'font-lock-function-name-face))
        (:from-or-to (mu4e~headers-from-or-to msg))
        (:date
         (propertize
          (format-time-string mu4e-headers-date-format val)
          'face 'font-lock-string-face))
        (:mailing-list (mu4e~headers-mailing-list val))
        (:human-date
         (propertize
          (mu4e~headers-human-date msg)
          'help-echo (format-time-string
                      mu4e-headers-long-date-format
                      (mu4e-msg-field msg :date))
          'face 'font-lock-string-face))
        (:flags
         (propertize (mu4e~headers-flags-str val)
                     'help-echo (format "%S" val)
                     'face 'font-lock-type-face))
        (:tags
         (propertize
          (mapconcat 'identity val ", ")
          'face 'font-lock-builtin-face))
        (:size (mu4e-display-size val))
        (t (mu4e~headers-custom-field msg field)))))

  (use-package mu4e-thread-folding
    :straight (mu4e-thread-folding :type git :host github :repo "rougier/mu4e-thread-folding")
    :tags '("CONNECTED" "MAIL")
    :after (mu4e)
    :config
    (add-to-list 'mu4e-header-info-custom
                 '(:empty . (:name "Empty"
                                   :shortname ""
                                   :function (lambda (msg) "  "))))
    (setq mu4e-headers-fields  '((:empty         .    2)
                                 (:human-date    .   18)
                                 (:size          .    6)
                                 (:flags         .    6)
                                 (:mailing-list  .   10)
                                 (:from          .   22)
                                 (:subject       .  nil))))

  (use-package mu4e-context
    :straight mu4e
    :tags '("CONNECTED" "MAIL")
    :config
    ;; Define the contexts (configuration defined in a private file)
    (when (fboundp 'set-mu4e-contexts)
      (set-mu4e-contexts))

    ;; Adapt the environment
    (setq mu4e-context-policy 'pick-first
          mu4e-user-mail-address-list (delq nil
                                            (mapcar (lambda (context)
                                                      (when (mu4e-context-vars context)
                                                        (cdr (assq 'user-mail-address (mu4e-context-vars context)))))
                                                    mu4e-contexts))))
  (use-package mu4e-bookmarks
    :straight mu4e
    :tags '("CONNECTED" "MAIL")
    :config
    ;; Define the contexts (configuration defined in a private file)
    (when (fboundp 'set-mu4e-bookmarks)
      (set-mu4e-bookmarks))

    (add-to-list 'mu4e-bookmarks
                 '(:name  "Drafts"
                          :query "flag:draft"
                          :key ?d)))

  (use-package org-mu4e
    :disabled t
    :straight mu4e
    :tags '("CONNECTED" "MAIL" "ORG"))
#+end_src

**** DONE Notification
CLOSED: [2021-01-05 Tue 08:52]
I am using =sauron= and =alert= as my notification system.
For now, I am using =mu4e-alert= configured using the ~count~ notification type.
It is quite simple but robust enough to not being bother every 5 min.

#+begin_src emacs-lisp
  (use-package mu4e-alert
    :straight (:host github :repo "seblemaguer/mu4e-alert" :branch "mu-1.7")
    :after (sauron-mode-line)
    :tags '("CONNECTED" "MAIL" "NOTIFICATION")
    :config
    ;; Just notify the counting
    (setq mu4e-alert-email-notification-types '(count))

    ;; Set the style to sauron
    (mu4e-alert-set-default-style 'sauron-mode-line-style)

    ;; Enable everything!
    (mu4e-alert-enable-notifications))
#+end_src

**** DONE Improve visualisation
CLOSED: [2021-08-10 Tue 20:14]

#+begin_src emacs-lisp
  (use-package mu4e-column-faces
    :straight (mu4e-column-faces :type git :host github :repo "Alexander-Miller/mu4e-column-faces")
    :tags '("CONNECTED" "MAIL" "VISUAL")
    :after mu4e
    :config (mu4e-column-faces-mode))
#+end_src

** DONE Calendar
CLOSED: [2022-07-25 Mon 07:46]
My calendar is, for now, stored on google.
=org-gcal= provides the conveniency to synchronize my calendar to my org-agenda.
I also rely on =org-hyperscheduler= which provides an easier way to move around the items.

#+BEGIN_SRC emacs-lisp
  (use-package oauth2-auto
    :straight (oauth2-auto :type git :host github :repo "rhaps0dy/emacs-oauth2-auto"))

  (use-package org-gcal
    :if (boundp 'my-gcal-client-id) ;; Ensure we have the infos to use org-gcal
    :straight (org-gcal :type git :host github :repo "kidd/org-gcal.el")
    :tags '("CALENDAR" "CONNECTED")
    :custom
    (org-gcal-client-id my-gcal-client-id)
    (org-gcal-client-secret my-gcal-client-secret)

    :config
    (setq org-gcal-recurring-events-mode 'nested
          org-gcal-notify-p nil
          org-gcal-fetch-file-alist my-gcal-calendars)

    ;; Add gcal to agenda files
    (dolist (elt org-gcal-fetch-file-alist)
      (add-to-list 'org-agenda-default-files (cdr elt)))
    (defun org-gcal--refresh-token (calendar-id)
      (refresh-gcal-token nil))

    (defun org-gcal--get-access-token (calendar-id)
      (refresh-gcal-token nil)))
#+END_SRC

** DONE Chat [100%]
CLOSED: [2021-01-05 Tue 09:32]
As for the email, I (try to) use emacs as my chatting entry point as well.
To do so, I rely on three key tools: the couple bitlbee/IRC for facebook messenger, skype, ...; slack and matrix.
I added a bunch of helpers to start/stop all the accounts in one shot.

*** DONE IRC
CLOSED: [2021-01-05 Tue 09:32]
The IRC configuration is quite standard.
I added a couple of primitives to access more easily the passwords (~my-irc-password~) and to format properly the chat buffer (~erc-format-buffer~).
I slightly tweaked the formatting to be more tolerant and added a bunch of plugins to enhance the UX.
Finally, the account definition is done in the private configuration file (so it is not shown here!).

#+begin_src emacs-lisp
  (use-package circe
    :tags '("CONNECTED" "CHAT" "IRC")
    :commands (circe circe-server-buffers)
    :hook
    (circe-channel-mode . emojify-mode)

    :init
    (defun circe-network-connected-p (network)
      "Return non-nil if there's any Circe server-buffer whose
      `circe-netwok' is NETWORK."
      (catch 'return
        (dolist (buffer (circe-server-buffers))
          (with-current-buffer buffer
            (if (string= network circe-network)
                (throw 'return t))))))

    (defun circe-maybe-connect (network)
      "Connect to NETWORK, but ask user for confirmation if it's
      already been connected to."
      (interactive "sNetwork: ")
      (if (or (not (circe-network-connected-p network))
              (y-or-n-p (format "Already connected to %s, reconnect?" network)))
          (circe network)))

    (defun circe-start ()
      "Connect to IRC"
      (interactive)
      (circe-maybe-connect "libera"))

    :config

    ;; Completion
    (setq circe-use-cycle-completion t)

    ;; Spam information reduction
    (setq circe-reduce-lurker-spam t)

    ;; Tracking
    (setq lui-track-bar-behavior 'before-switch-to-buffer)
    (enable-lui-track-bar)

    ;; Formatting / Visual
    (enable-circe-color-nicks)
    (enable-circe-display-images))

  (use-package lui-logging
    :straight circe
    :tags '("CONNECTED" "CHAT" "IRC")
    :commands (enable-lui-logging))

  (use-package lui-autopaste
    :straight circe
    :tags '("CONNECTED" "CHAT" "IRC")
    :hook (circe-channel-mode . enable-lui-autopaste)
    :config
    (defvar lui-autopaste-service-gist-url nil
      "The URL for the last gist.")

    (defun lui-autopaste-service-gist (text)
      "Paste TEXT to github using gist.el."
      ;; It's so great gist works with callbacks! It's so much fun to
      ;; work around that!
      (setq lui-autopaste-service-gist-url 'waiting)
      (with-temp-buffer
        (insert text)
        (gist-region (point-min) (point-max) nil
                     (lambda (gist)
                       (when (eq lui-autopaste-service-gist-url
                                 'waiting)
                         (setq lui-autopaste-service-gist-url
                               (oref gist :html-url)))))) ;; FIXME: this provokes a Warning: Unknown slot ‘:html-url’
      (let ((wait 0))
        (while (and (< wait 10)
                    (eq lui-autopaste-service-gist-url
                        'waiting))
          (sit-for 0.1 )
          (setq wait (1+ wait))))
      (if (eq lui-autopaste-service-gist-url 'waiting)
          (progn
            (setq lui-autopaste-service-gist-url nil)
            (error "Couldn't create gist"))
        (prog1 lui-autopaste-service-gist-url
          (setq lui-autopaste-service-gist-url nil))))

    (setq lui-autopaste-function 'lui-autopaste-service-gist))


  (use-package lui
    :straight circe
    :tags '("CONNECTED" "CHAT" "IRC")
    :hook
    (lui-mode . my-lui-setup)

    :init
    (defun my-lui-setup ()
      (setq fringes-outside-margins t
            right-margin-width 21
            word-wrap t
            wrap-prefix "    "))

    :config
    (setq lui-time-stamp-position 'right-margin
          lui-time-stamp-format "[%Y-%m-%d %H:%M:%S]"
          lui-fill-type nil)

    ;; Disabled modeline (tracking-mode) when loading lui
    ;; This is incompatible with nano-emacs!
    (define-minor-mode tracking-mode
      "placehold to actually deactivate anything related to tracking-mode!"
      :group 'tracking
      :global t))

  (use-package lui-irc-colors
    :straight circe
    :tags '("CONNECTED" "CHAT" "IRC")
    :config
    (add-to-list 'lui-pre-output-hook 'lui-irc-colors))

  (use-package circe-notifications
    :tags '("CONNECTED" "CHAT" "IRC" "NOTIFICATION")
    :commands (enable-circe-notifications)
    :custom (circe-notifications-alert-style 'sauron-mode-line-style)
    :hook
    (circe-server-connected . enable-circe-notifications))
#+end_src

*** DONE Matrix
CLOSED: [2021-01-18 Mon 12:11]
The Matrix configuration is based on =ement=.
This package is not in stable stage (yet) but is causing less problem with my way of using emacs than =matrix-client.el=.
=ement= requires =plz= which is not on melpa yet.
Therefore, all the packages are installed using =straight=.

#+BEGIN_SRC emacs-lisp
  (use-package plz
    :straight (plz :type git :host github :repo "alphapapa/plz.el")
    :tags '("CONNECTED" "CHAT" "MATRIX"))

  (use-package ement
    :straight (ement :host github :repo "seblemaguer/ement.el" :branch "notification")
    :tags '("CONNECTED" "CHAT" "MATRIX")
    :custom
    (ement-room-timestamp-format "%d-%m-%Y %H:%M:%S")
    (ement-room-message-format-spec "[%t] %S> %B%r")
    (ement-room-left-margin-width 0)
    (ement-room-right-margin-width 0)
    (ement-notify-notify-predicates '(ement-notify--notifications-sauron))

    :custom-face
    (ement-room-read-receipt-marker ((t (:box '(:line-width 0.1) :height 0.1 :background "red"))))
    (ement-room-fully-read-marker ((t (:box '(:line-width 0.1) :height 0.1 :background "green"))))

    :commands (ement-connect)
    :config

    ;; NOTE: this is dirty but it helps to get rid of timestamps' header I don't want to see
    (defun ement-room--insert-ts-headers (&optional start-node end-node) )

    ;; NOTE: The redefinition is a bit ugly but it allows to define `ement-notify--notifications-sauron'
    (cl-defstruct ement-event
      id sender content origin-server-ts type unsigned state-key
      receipts
      ;; The local slot is an alist used by the local client only.
      local)

    (cl-defstruct ement-room
      id display-name prev-batch
      summary state timeline ephemeral account-data unread-notifications
      latest-ts topic canonical-alias avatar status type invite-state
      (members (make-hash-table :test #'equal) :documentation "Hash table mapping joined user IDs to user structs.")
      ;; The local slot is an alist used by the local client only.
      local
      (receipts (make-hash-table :test #'equal))
      (displaynames (make-hash-table) :documentation "Hash table mapping users to their displayname in this room."))

    (defun ement-notify--notifications-sauron (event room _session)
      "Call `notifications-notify' for EVENT in ROOM on SESSION."
      (pcase-let* (((cl-struct ement-event sender content) event)
                   ((cl-struct ement-room avatar (display-name room-displayname)) room)
                   ((map body) content)
                   (room-name (or room-displayname (ement--room-display-name room)))
                   (sender-name (ement--user-displayname-in room sender))
                   (title (format "%s in %s" sender-name room-name)))
        ;; TODO: Encode HTML entities.
        (when (stringp body)
          ;; If event has no body, it was probably redacted or something, so don't notify.
          (truncate-string-to-width body 60)
          (sauron-add-event (intern room-name) 2 body))))
    )
#+END_SRC

*** DONE Slack
CLOSED: [2021-01-05 Tue 09:29]
The package =slack= (or ~emacs-slack~) provides everything I need to support Slack in emacs.
The change I do concerns mainly the formatting and the completion system.
Because, I prefer to have the completion system, =company=, configured locally for each buffer, I needed to modify its connection with =slack=.

#+NAME: slack-mode-keybindings
| Key | Function                    | Description |
|-----+-----------------------------+-------------|
| @   | slack-message-embed-mention |             |
| #   | slack-message-embed-channel |             |

#+NAME: slack-message-keybindings
| Key     | Function                    | Description |
|---------+-----------------------------+-------------|
| C-c C-e | slack-message-edit          |             |
| C-c C-a | slack-file-upload           |             |
| C-c C-r | slack-thread-show-or-create |             |

#+begin_src emacs-lisp
  (use-package slack
    :straight (slack :type git :host github :repo "yuya373/emacs-slack"
                      :fork (:host github :repo "seblemaguer/emacs-slack"))
    :tags '("CONNECTED" "CHAT" "SLACK")
    :commands (slack-start)
    :no-require t
    :defines (url-http-method url-http-data url-http-extra-headers url-callback-function url-callback-arguments oauth--token-data)

    :custom
    (slack-buffer-emojify               t)
    (slack-modeline-formatter           nil)
    (slack-buffer-create-on-notify      t)
    (slack-display-team-name            t)
    (slack-typing-visibility            'buffer) ;; 'never, 'buffer, 'frame
    (slack-thread-also-send-to-room     nil)
    (slack-profile-image-file-directory (format "%s/tmp/slack/profile_pictures" user-emacs-directory))
    (slack-image-file-directory         (format "%s/tmp/slack/images" user-emacs-directory))
    (slack-file-dir                     "~/Downloads/")

    :hook
    (slack-mode . slack-define-hooks)
    (slack-file-info-buffer-mode . view-mode)

    :bind (
      :map slack-mode-map (
        <<keybindings-gen(table=slack-mode-keybindings)>>
      )

      :map slack-message-buffer-mode-map (
        <<keybindings-gen(table=slack-message-keybindings)>>
      )
    )

    :config
    (defun slack-define-hooks ()
      "Define some useful slack hooks."
      ;; Company part
      (make-local-variable 'company-backends)
      (setq company-backends (copy-tree company-backends))
      (set 'company-backends (append '(company-slack-backend) company-backends))

      ;; Disable smart parens
      (smartparens-mode -1))

    ;; Create directory in case of
    (make-directory slack-profile-image-file-directory t)
    (make-directory slack-image-file-directory t)

    ;; Register the teams (configuration defined in a private file)
    (when (fboundp 'slack-register-teams)
      (slack-register-teams)))
#+end_src

**** DONE Helm-slack
CLOSED: [2021-01-05 Tue 09:21]
As an entry point to use slack, I prefer to use =helm-slack= as it provides a nice view of everthing in one place.

#+begin_src emacs-lisp
  (use-package helm-slack
    :straight (helm-slack :type git :host github :repo "yuya373/helm-slack")
    :tags '("CONNECTED" "CHAT" "SLACK" "COMPLETION")
    :after (slack helm))
#+end_src

*** DONE Telega
CLOSED: [2021-05-20 Thu 17:33]
=Telega= provides an all-in-one solution for Telegram.

#+BEGIN_SRC emacs-lisp
  (use-package telega
    :requires (tracking)
    :tags '("CONNECTED" "CHAT" "TELEGRAM")
    :commands (telega)

    :config
    (require 'telega-alert)
    (telega-alert-mode 1)

    ;; FIXME: telega-transient doesn't work for now
    ;; (require 'telega-transient)
    ;; (telega-transient-mode 1)
    (setq telega-chat-show-deleted-messages-for 'all
          telega-tdlib-min-version "1.7.0")

    (require 'telega-mnz)
    (add-hook 'telega-load-hook 'global-telega-mnz-mode)

    :custom
    (telega-use-tracking-for            'all)
    (telega-chat-prompt-show-avatar-for nil)
    (telega-server-libs-prefix          "/usr")
    (telega-temp-dir                    (format "%s/tmp/telega/images" user-emacs-directory))
    (telega-use-images                  (display-graphic-p))
    ;; (telega-symbol-horizontal-bar       (propertize "-" 'face 'jao-themes-f00))
    ;; (telega-symbol-vertical-bar         (propertize "|" 'face 'jao-themes-dimm))

    :hook
    (telega-chat-mode . telega-chat-hook)
    (telega-root-mode . (lambda () (emojify-mode 1)))

    :init
    (defun telega-chat-hook ()
      (set
       (make-local-variable 'company-backends)
       (append '(telega-company-emoji
                 telega-company-username
                 telega-company-hashtag)
               (when (and telega-chatbuf--chat (telega-chat-bot-p telega-chatbuf--chat))
                 '(telega-company-botcmd))))
      (emojify-mode 1)
      (smartparens-mode -1)))
#+END_SRC

*** DONE Global helpers
CLOSED: [2021-01-05 Tue 09:31]
This section provides three helper functions to connect/disconnect all my chatting accounts in one shot.

#+begin_src emacs-lisp
  (defun communication-start ()
    "Routine to start all chats."
    (interactive)
    (circe-start)
    (telega)
    (slack-start)
    (my-ement-connect))

  (defun communication-shutdown ()
    "Routine to shutdown all chats"
    (interactive)

    (circe-command-GQUIT "time to go back to the real life")
    (telega-kill t)
    (slack-ws-close)
    (call-interactively #'ement-disconnect)

    ;; Clean buffers
    (dolist (buf (buffer-list))
      (cond ((string-prefix-p "*Slack " (buffer-name buf))
             (kill-buffer buf))
            ((string= (with-current-buffer buf major-mode) "circe-mode")
             (kill-buffer buf)))))

  (global-set-key (kbd "S-<f2>") 'communication-start)
  (global-set-key (kbd "C-<f2>") 'communication-shutdown)
#+end_src

** DONE Exchange services [100%]
CLOSED: [2021-01-05 Tue 09:41]

*** DONE Stackexchange
CLOSED: [2021-01-05 Tue 09:41]
To access stackexchange, I rely on the package =sx=.
Everything is nicely configured internally to this package, I just binded some keys for an easier support.

#+begin_src emacs-lisp
  (use-package sx
    :tags '("CONNECTED" "EXCHANGE" "STACKEXCHANGE")
    :functions (sx-open-link)
    :config
    (bind-keys :prefix "C-c s"
               :prefix-map my-sx-map
               :prefix-docstring "Global keymap for SX."
               ("q" . sx-tab-all-questions)
               ("i" . sx-inbox)
               ("o" . sx-open-link)
               ("u" . sx-tab-unanswered-my-tags)
               ("a" . sx-ask)
               ("s" . sx-search)))
#+end_src

*** DONE Reddit
CLOSED: [2021-01-05 Tue 09:39]
For reddit, I rely on the package =md4rd=.
However, there is currently a bug with the hierarchy package which is not embedded in my emacs 27.
As it requires more investigation, I disabled this packaged for now.

#+NAME: md4rd-mode-keybindings
| Key       | Function                  | Description |
|-----------+---------------------------+-------------|
| u         | md4rd-upvote              |             |
| d         | md4rd-downvote            |             |
| o         | md4rd-open                |             |
| t         | md4rd-widget-toggle-line  |             |
| e         | md4rd-widget-expand-all   |             |
| c         | md4rd-widget-collapse-all |             |
| TAB       | widget-forward            |             |
| <backtab> | widget-backward           |             |
| ?         | md4rd-hydra/body          |             |

#+NAME: md4rd-hydra-basic-keybindings
| Key | Function                 | Label       | Description |
|-----+--------------------------+-------------+-------------|
| o   | md4rd-open               | Open        |             |
| t   | md4rd-widget-toggle-line | Toggle line |             |

#+NAME: md4rd-hydra-voting-keybindings
| Key | Function       | Label    | Description |
|-----+----------------+----------+-------------|
| u   | md4rd-upvote   | Upvote   |             |
| d   | md4rd-downvote | Downvote |             |

#+NAME: md4rd-hydra-expanding-keybindings
| Key | Function                  | Label        | Description |
|-----+---------------------------+--------------+-------------|
| e   | md4rd-widget-expand-all   | Expand all   |             |
| c   | md4rd-widget-collapse-all | Collapse all |             |


#+begin_src emacs-lisp
  ;; Not automatically loaded by md4rd
  (use-package tree-mode
    :tags '("CONNECTED" "EXCHANGE" "REDDIT"))

  (use-package cl-extra
    :straight (:type built-in))

  (use-package md4rd
    :tags '("CONNECTED" "EXCHANGE" "REDDIT")
    :pretty-hydra
    ((:color blue :hint none)
     ("Basic" (
        <<hydra-keybindings-gen(table=md4rd-hydra-basic-keybindings)>>
      )

      "Voting" (
        <<hydra-keybindings-gen(table=md4rd-hydra-voting-keybindings)>>
      )

      "Expanding" (
        <<hydra-keybindings-gen(table=md4rd-hydra-expanding-keybindings)>>
      )))

    :bind (
      :map md4rd-mode-map (
        <<keybindings-gen(table=md4rd-mode-keybindings)>>
      )
    )


    :config
    (setq md4rd-subs-active '(emacs orgmode composer audacity Reaper Musescore AudioProgramming)))
#+end_src

** DONE Release
CLOSED: [2021-01-05 Tue 09:42]
Finally, as a proper metalhead and music addict, I sometimes get lost in what is currently released.
In order to have a better view of what is going on, I developped a package named =metal-archives=.
I am using its extension =metal-archives-shopping-list= to maintain a list of release I want to buy.

#+begin_src emacs-lisp
  (use-package metal-archives-shopping-list
    :tags '("CONNECTED" "RELEASE")
    :if (file-directory-p cloud-org-root-dir)
    :commands (metal-archives-shopping-list-update
               metal-archives-retrieve-next-releases
               metal-archives-load-artists-map)
    :hook
    ;; (kill-emacs . metal-archives-shopping-list-update)
    (after-init . metal-archives-load-artists-map)

    :init
    (when (file-exists-p (concat cloud-org-root-dir "perso/music/shopping_list.org" ))
      (setq metal-archives-shopping-list-target-file (concat cloud-org-root-dir "perso/music/shopping_list.org" )))

    :custom
    (metal-archives-shopping-list-root-node "CD")

    :config
    (add-to-list 'org-agenda-files metal-archives-shopping-list-target-file)
    (setq metal-archives-favorite-handle 'metal-archives-shopping-list-add-release-and-alert))
#+end_src

** DONE Youtube
CLOSED: [2021-02-09 Tue 16:12]
To access youtube from Emacs, I am using =ytdious= which is based on the invidious.
It is connected to =youtube-dl= to download the video.

#+NAME: ytdious-entry-keybindings
| Key    | Function | Description |
|--------+----------+-------------|
| <C-f9> | ytdious  |             |

#+NAME: ytdious-mode-keybindings
| Key      | Function         | Description |
|----------+------------------+-------------|
| <return> | ytdious-watch    |             |
| d        | ytdious-download |             |


#+BEGIN_SRC emacs-lisp
  (use-package ytdious
    :tags '("CONNECTED" "MULTIMEDIA")
    :commands (ytdious)
    :bind (
      <<keybindings-gen(table=ytdious-entry-keybindings)>>

      :map ytdious-mode-map (
        <<keybindings-gen(table=ytdious-mode-keybindings)>>
      )
    )

    :custom (ytdious-sort-criterion 'upload_date)
    :init
    (setq ytdious-invidious-api-url "https://invidio.xamh.de/")

    :config
    (defun ytdious-download ()
      "Download video at point"
      (interactive)
      (let* ((video (ytdious-get-current-video))
             (id    (ytdious-video-id video)))
        (youtube-dl (concat "https://www.youtube.com/watch?v=" id))))

    (defun ytdious-watch ()
      "Stream video at point in mpv."
      (interactive)
      (let* ((video (ytdious-get-current-video))
             (id    (ytdious-video-id-fun video)))
        (start-process "ytdious mpv" nil
                       "mpv"
                       (concat "https://www.youtube.com/watch?v=" id)))))
#+END_SRC

** DONE Download
CLOSED: [2021-02-13 Sat 11:56]
Aria2 provides an easy way to manage downloads (both direct and peer-to-peer).
It requires =aria2c= to be available.

#+BEGIN_SRC emacs-lisp
  (when (executable-find "aria2c")
    (use-package aria2
      :straight (aria2 :type git :host github :repo "seblemaguer/aria2")
      :commands aria2-downloads-list
      :tags '("CONNECTED")))
#+END_SRC

* DONE Entertainment [100%]
** DONE Music
CLOSED: [2021-12-10 Fri 12:19]
I am playing music in Emacs using EMMS.
The default configuration is already satisfying but I prefered to tweak a couple of part to make it more useable.
The first thing I changed is to use ~mpv~ as a player as I am already it as a default on my system.
I also tweaked the cache and some rendering part as I have a lot of files to navigate through.
Finally, I activated the browser and assigned the multimedia keys to be understood directly by EMMS.

#+NAME: emms-keybindings
| Key             | Function              | Description |
|-----------------+-----------------------+-------------|
| <f5>            | emms-browse-by-artist |             |
| S-<f5>          | emms-playlist-mode-go |             |
| <XF86AudioPlay> | emms-pause            |             |
| <XF86AudioStop> | emms-stop             |             |
| <XF86AudioPrev> | emms-previous         |             |
| <XF86AudioNext> | emms-next             |             |

#+begin_src emacs-lisp
  (use-package emms
    :tags '("MULTIMEDIA" "MUSIC" "ENTERTAINMENT")
    :commands (emms emms-browse-by-artist with-current-emms-playlist)
    :bind (
      <<keybindings-gen(table=emms-keybindings)>>
    )

    :config
    (emms-all)

    ;; Use mpv player
    (setq emms-player-list '(emms-player-mpv))

    ;; A minor macos adaptation
    (when (eq system-type 'darwin)
      (setq emms-source-file-gnu-find "/usr/local/bin/gfind"))

    ;; Some behaviour definition
    (setq later-do-interval 0.0001
          emms-directory (concat user-emacs-directory "emms")
          emms-playlist-buffer-name "*Music*"
          emms-source-file-default-directory (expand-file-name "~/Music")
          emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
          emms-show-format "NP: %s"
          emms-playlist-default-major-mode 'emms-playlist-mode
          emms-repeat-playlist t
          emms-mode-line-mode-line-function nil  ;; Don't want any info in the mode line
          emms-mode-line-titlebar-function 'emms-mode-line-playlist-current) ;; Put info in the titlebar

    ;; Visualisation activation/deactivation
    (emms-mode-line nil)

    ;; Enable cache and ensure to ignore any kind of URL
    (when (fboundp 'emms-cache)
      (emms-cache 1)
      (defun my-emms-cache-set  (type path track)
        (unless (string-match "^http[s]?://.*" path)
          (emms-cache-set type path track)))
      (setq emms-cache-set-function 'my-emms-cache-set))

    ;; Define routine to update cache without adding tracks to the playlist
    (defun emms-cache-update (dir)
      "Routine to update the cache without updating any playlist -either DIR, or the value of
    `emms-source-file-default-directory'."
      (interactive (list
                    (emms-read-directory-name "Play directory tree: "
                                              (emms-source-file-directory-hint)
                                              emms-source-file-default-directory
                                              t)))
      (let ((files (emms-source-file-directory-tree (expand-file-name dir)
                                                    (emms-source-file-regex)))
            (case-fold-search nil))
        (with-current-emms-playlist
          (point-max)
          (mapc (lambda (file)
                  (unless (or (string-match emms-source-file-exclude-regexp file)
                              (gethash file emms-cache-db))
                    (emms-track 'file file)))
                files))))

    ;; Adapt track description format
    (defun track-description (track)
      "Return a description of the current TRACK."
      (if (and (emms-track-get track 'info-artist)
               (emms-track-get track 'info-title))
          (let ((pmin (emms-track-get track 'info-playing-time-min))
                (psec (emms-track-get track 'info-playing-time-sec))
                (ptot (emms-track-get track 'info-playing-time))
                (art  (emms-track-get track 'info-artist))
                (tit  (emms-track-get track 'info-title))
                (alb  (emms-track-get track 'info-album)))
            (cond ((and pmin psec) (format "%s - %s - %s [%02d:%02d]" art alb tit pmin psec))
                  (ptot (format  "%s - %s - %s [%02d:%02d]" art alb tit (/ ptot 60) (% ptot 60)))
                  (t (emms-track-simple-description track))))
        (progn
          (emms-track-simple-description track))))
    (setq emms-track-description-function 'track-description)

    ;; taken from http://emacs.stackexchange.com/questions/21747/emms-how-can-i-have-a-progress-bar?rq=1
    (defun emms-indicate-seek (_sec)
      "Show the progress bar when seek."
      (let* ((total-playing-time (emms-track-get
                                  (emms-playlist-current-selected-track)
                                  'info-playing-time))
             (elapsed/total (/ (* 100 emms-playing-time) total-playing-time)))
        (with-temp-message (format "[%-100s] %2d%% [%02d:%02d]/[%02d:%02d]"
                                   (make-string (round elapsed/total) ?=)
                                   (round elapsed/total)
                                   (/ (round emms-playing-time) 60) (% (round emms-playing-time) 60)
                                   (/ (round total-playing-time) 60) (% (round total-playing-time) 60))
          (sit-for 2))))
    (add-hook 'emms-player-seeked-functions #'emms-indicate-seek 'append))

  (use-package emms-info-metaflac
    :straight emms
    :tags '("MULTIMEDIA" "MUSIC" "ENTERTAINMENT")
    :config
    (setq emms-info-asynchronously nil
          emms-info-functions '(emms-info-metaflac)))

  (use-package emms-info-libtag
    :straight emms
    :tags '("MULTIMEDIA" "MUSIC" "ENTERTAINMENT")
    :config
    (setq emms-info-asynchronously nil)
    (add-to-list 'emms-info-functions 'emms-info-libtag t))

  (use-package emms-info-native
    :straight emms
    :tags '("MULTIMEDIA" "MUSIC" "ENTERTAINMENT")
    :init
    (setq emms-info-asynchronously nil)
    (add-to-list 'emms-info-functions 'emms-info-native t))

  (use-package emms-browser
    :straight emms
    :tags '("MULTIMEDIA" "MUSIC" "ENTERTAINMENT")
    :config
    ;; Formatting
    (setq emms-browser-info-artist-format "%i☢ %n"
          emms-browser-info-album-format "%i%cS [%y] %n"
          emms-browser-info-title-format "%i♪ %T. %t [%d]"
          emms-browser-playlist-info-album-format "%cS %a - %A : "
          emms-browser-playlist-info-title-format "%i%T. %t [%d]")

    ;; Filtering
    (emms-browser-make-filter "all" #'ignore)
    (emms-browser-make-filter
     "recent - Month"
     (lambda (track) (< 30
                        (time-to-number-of-days
                         (time-subtract (current-time)
                                        (emms-info-track-file-mtime track))))))

    (emms-browser-make-filter
     "recent - Trimester"
     (lambda (track) (< (* 3 30)
                        (time-to-number-of-days
                         (time-subtract (current-time)
                                        (emms-info-track-file-mtime track))))))

    (emms-browser-make-filter
     "not-played"
     (lambda (track)
       (not (funcall (emms-browser-filter-only-recent 365) track))))

    (emms-browser-set-filter (assoc "all" emms-browser-filters))
    )
#+end_src

** DONE TV/Show
CLOSED: [2021-12-10 Fri 12:38]
To sort out what I am currently watching, I use =seriestracker=.

#+begin_src emacs-lisp
  (use-package seriestracker
    :straight (seriestracker :type git :host github :repo "MaximeWack/seriesTracker")
    :tags '("MULTIMEDIA" "ENTERTAINMENT")
    :demand                                                   ;;To force load seriestracker
    :config                                                   ;;These are the default
    (setq seriestracker-file (concat user-emacs-directory "seriestracker.el")
          seriestracker--fold-cycle 'seriestracker-all-folded ;; can also be 'seriestracker-all-unfolded or 'seriestracker-series-folded. Will deternine the folding at startup
          seriestracker-show-watched "hide"                   ;; whether to hide or "show" the watched episodes
          seriestracker-sorting-type "next"))                 ;; or "alpha" for alphabetic sort
#+end_src

** DONE Subtitles
CLOSED: [2023-01-18 Wed 12:16]
Sacha Chua released an great package (=subed=) to edit subtitles files using emacs.
I just modified a couple of bindings to fit my French keyboard layout (the other keys are there for reminder).

#+NAME: subed-keybindings
| Key     | Function                            | Description                                                     |
|---------+-------------------------------------+-----------------------------------------------------------------|
| C-c (   | subed-copy-player-pos-to-start-time | Set the current play-time as the *start* position                 |
| C-c )   | subed-copy-player-pos-to-stop-time  | Set the current play-time as the *end* position                   |
| M-i     | subed-insert-subtitle               | Insert a new subtitle "line"                                    |
| C-c C-v | subed-mpv-play-from-file            | Open a video file to synchronize with the current subtitle file |

#+begin_src emacs-lisp :lexical no
  (use-package subed
    :straight (subed :type git :host github :repo "sachac/subed" :files ("subed/*.el"))
    :bind (
      :map subed-mode-map (
          <<keybindings-gen(table=subed-keybindings)>>
      )
    )
    :hook
    (subed-mode . subed-disable-sync-point-to-player)
    (subed-mode . save-place-local-mode)
    (subed-mode . turn-on-auto-fill)
    (subed-mode . (lambda () (setq-local fill-column 40))))
#+end_src
* DONE Emacs and the rest of the world [100%]
As Emacs is the entry point of my numerical life, I connected to a bunch of other external things.
It can be summarized around three categories:
the connection to the desktop environment,
the connection to the local operating system,
and the connection to servers (mainly computing clusters).

** DONE Emacs and the desktop [100%]
CLOSED: [2021-01-05 Tue 12:51]
In this section, I configure a set of packages to control different desktop aspect using Emacs.
Each subsection focuses on dedicated aspect of the desktop.

*** DONE Desktop environment control
CLOSED: [2021-01-05 Tue 12:41]
=desktop-environment= is package which captures bindings in emacs from multimedia keys (mainly).
I mainly control screen and keyboard brightness using it.

#+begin_src emacs-lisp
  (use-package desktop-environment
    :tags '("DESKTOP")
    :config
    (setq desktop-environment-brightness-normal-increment "-inc 10"
          desktop-environment-brightness-normal-decrement "-dec 10"
          desktop-environment-brightness-small-increment "-inc 5"
          desktop-environment-brightness-small-decrement "-dec 5"
          desktop-environment-brightness-get-command "xbacklight -get"
          desktop-environment-brightness-set-command "xbacklight")
    (desktop-environment-mode))
#+end_src

*** DONE Clipboard
CLOSED: [2021-01-05 Tue 12:39]
Integrate the clipboard to Emacs by using the package =cliphist=.

#+begin_src emacs-lisp
  (when (executable-find "parcellite")
    (use-package cliphist
      :tags '("DESKTOP")))
#+end_src

*** DONE Bluetooth
CLOSED: [2021-01-05 Tue 12:52]
To control the bluetooth devices, I use the package =bluetooth=.
No extra configuration is needed.

#+begin_src emacs-lisp
  (use-package bluetooth
    :tags '("DESKTOP"))
#+end_src

*** DONE Emacs and firefox
CLOSED: [2021-01-05 Tue 12:47]
:PROPERTIES:
:FROM:     https://github.com/GhostText/GhostText
:END:
Sometimes it is difficult to edit a text (from a textarea) in Firefox.
Using =atomic-chrome= coupled with the ~GhostText~ firefox addon, I edit such text in Emacs and its synchronized in firefox automatically.

#+NAME: atomic-chrome-keybindings
| Key     | Function                           | Description |
|---------+------------------------------------+-------------|
| S-c C-c | atomic-chrome-close-current-buffer |             |

#+begin_src emacs-lisp
  (use-package atomic-chrome
    :tags '("DESKTOP")
    :hook
    (after-init . atomic-chrome-start-server)

    :commands
    (atomic-chrome-start-server)

    :init
    (setq atomic-chrome-server-ghost-text-port 4666
          atomic-chrome-default-major-mode 'org-mode)

    :bind (
      <<keybindings-gen(table=atomic-chrome-keybindings)>>

     :map atomic-chrome-edit-mode-map
       ("C-c C-c" . nil)
     )
    )
#+end_src

*** DONE Emacs Application Framework (EAF)
CLOSED: [2021-01-05 Tue 12:51]
Emacs Application Framework (EAF) provides a way to integrate multiple applications internally into Emacs.
Emacs needs to be compiled using the flag ~--with-modules~ as it requires some dynamic linking.
In addition, =eaf= is installed externally as it requires additional compilation effort.
As for =mu4e=, my environment scripts are taking care of the compilation.

#+begin_src emacs-lisp
  (use-package epc
    :tags '("DESKTOP"))

  (use-package eaf
    :straight (eaf :type git
                   :host github
                   :repo "emacs-eaf/emacs-application-framework"
                   :files ("eaf.el" "eaf.py" "applications.json" "extension" "core" "img" "sync-eaf-resources.py"))
    :tags '("DESKTOP")
    :commands (eaf-install-and-update eaf-open eaf-open-browser)
    :custom
    (eaf-pdf-extension-list '("xps" "oxps" "cbz" "epub" "fb2" "fbz"))
    (eaf-browser-continue-where-left-off t)
    (eaf-browser-enable-adblocker t)
    (eaf-apps-to-install '(browser mail pdf-viewer image-viewer markdown-previewer mindmap org-previewer system-monitor video-player))
    ;; (browse-url-browser-function 'eaf-open-browser)

    :init
    (eval-after-load 'mu4e '(lambda ()
                              (add-to-list 'mu4e-view-actions
                                           '("ViewHTML" . mu4e-eaf-wrapper) t)))

    :config
    (when (require 'eaf-browser nil 'noerror)
      (require 'eaf-mail)
      (require 'eaf-pdf-viewer)
      (require 'eaf-image-viewer)
      (require 'eaf-markdown-previewer)
      (require 'eaf-org-previewer)
      (require 'eaf-mindmap)
      (require 'eaf-system-monitor))

    (defun mu4e-eaf-wrapper (msg)
      "Wrapper to be able to add `eaf-open-mail-as-html' in `mu4e-view-actions'."

      (unless (require 'eaf-browser nil 'noerror)
        (error "Need to run `eaf-install-and-update' first!"))
      (eaf-open-mail-as-html)))
#+end_src

*** DONE Printing
CLOSED: [2023-04-07 Fri 12:50]
#+begin_src emacs-lisp :lexical no
  (use-package transient-extras-lp
    :tags '("DESKTOP" "PRINT")
    :config
    (with-eval-after-load 'dired
      (define-key
       dired-mode-map
       (kbd "C-c C-p") #'transient-extras-lp-menu))

    (with-eval-after-load 'pdf-tools
      (define-key
       pdf-misc-minor-mode-map
         (kbd "C-c C-p") #'transient-extras-lp-menu)))
#+end_src

** DONE Emacs and the system [100%]
CLOSED: [2021-01-05 Tue 13:42]
In a lower level, I want to have a better access to some system/(non desktop-)environment tools.
I separated the configuration into three main subsections:
the section dedicated to the system/shell,
the section dedicated to specific tools,
and the section dedicated to background processes/"daemons" management directly into Emacs.

*** DONE System and Shell
CLOSED: [2021-01-05 Tue 13:13]
In this section, I configure packages to access system informations and enforce the shell environment into Emacs.

**** DONE Get system control information
CLOSED: [2021-01-05 Tue 13:11]
To access the global OS information, =sysctl= provides a basic interface.
No extra configuration is needed.

#+begin_src emacs-lisp
  (use-package sysctl
    :tags '("SYSTEM")
    :commands (sysctl))
#+end_src

**** DONE Execute with shell environment
CLOSED: [2021-01-05 Tue 13:13]
Because an important part of my environment relies on a properly configured shell (especially for environment variables),
I use =exec-path-from-shell= to force to run a command using the shell environment.

#+NAME: detached-mode-keybindings
| Key                           | Function                   | Description |
|-------------------------------+----------------------------+-------------|
| [remap async-shell-command]   | detached-shell-command     |             |
| [remap compile]               | detached-compile           |             |
| [remap recompile]             | detached-compile-recompile |             |
| [remap detached-open-session] | detached-consult-session   |             |

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :tags '("SYSTEM")
    :config
    (setq exec-path-from-shell-arguments nil)
    (exec-path-from-shell-initialize))

  (when (executable-find "dtach")
    (use-package detached
      ;; NOTE: the original repo is a pain to access with ssh, using the emacsmirror
      :straight (detached :type git :host github :repo "emacsmirror/detached")
      :tags '("SYSTEM")
      :init
      (detached-init)
      :bind (
        <<keybindings-gen(table=detached-mode-keybindings)>>
      )

      :custom ((detached-show-output-on-attach t)
               (detached-shell-history-file "~/.bash_history"))))
#+end_src

**** DONE Define some short for commands
CLOSED: [2021-07-19 Mon 09:32]
This section defines some helpers for some recurrent commands.
It relies on the package =run-command=.
For now, only global commands are configured but some project specific configuration may be integrated in a near future.

#+NAME: run-command-entry-keybindings
| Key   | Function    | Description |
|-------+-------------+-------------|
| C-c c | run-command |             |

#+begin_src emacs-lisp
  (use-package run-command
    :tags '("SYSTEM")
    :bind (
      <<keybindings-gen(table=run-command-entry-keybindings)>>
    )

    :custom (run-command-recipes '(define-server-commands))
    :init

    (defun define-server-commands ()
      "Define server commands used in run-command"
      (list
       (list :command-name "Start python HTTP server"
             :command-line "python -m http.server")
       (list :command-name "Jekyll serve"
             :command-line "bundle exec jekyll serve"))))
#+end_src

*** DONE Tools
CLOSED: [2021-01-05 Tue 13:21]
This section is dedicated to the configuration of specific tools.
For now, it comprises ~Docker~ and ~Conda~.

**** DONE Docker
CLOSED: [2021-01-05 Tue 13:20]
The package =docker= is already configured to provide everything to interact with Docker.

#+begin_src emacs-lisp
  (when (executable-find "docker")
    (use-package docker
      :commands (docker)
      :tags '("SYSTEM")))
#+end_src

**** DONE Conda
CLOSED: [2021-01-05 Tue 13:18]
I am using conda to configure different environment for ~Python~ and ~R~.
The package =conda= provides all the necessary XXX to integrate conda into Emacs.
I am using my own scripts to install and configure conda into my environment directory.
Consequently, the configuration consists mainly of defining the path of conda and activating =conda= for different modes:
~python-mode~ and ~ess-mode~.

#+begin_src emacs-lisp
  (when (executable-find "conda")
    (use-package conda
      :tags '("SYSTEM" "PYTHON" "R")
      :straight (conda :type git :host github :repo "seblemaguer/conda.el")
      :init
      (setq conda-anaconda-home (expand-file-name "~/environment/local/mamba"))

      (defun conda-hook ()
        "Conda activation hook."
        (setq conda-message-on-environment-switch nil)
        (conda-env-autoactivate-mode t))

      :config
      (conda--get-config)

      :hook
      (python-mode . conda-hook)
      (ess-mode    . conda-hook)))
#+end_src

*** DONE Dealing with processes
CLOSED: [2021-01-05 Tue 13:26]
To deal with background processes, I rely on two packages: =prodigy= and =elcontext=.
=prodigy= is used to run and monitor the processes.
However, =prodigy= doesn't provide a nice way to start processes automatically.
=elcontext= is used to deal with the start.
Yet =elcontext= is still slightly bugged, so I use my own fork right now.
Currently, it is mainly used to start/stop emails but it is likely to be expanded in the future.

#+NAME: prodigy-keybindings
| Key | Function                | Description                     |
|-----+-------------------------+---------------------------------|
| ?   | prodigy-display-process | Display the process information |

#+BEGIN_SRC emacs-lisp
  (use-package prodigy
    :demand t
    :tags '("CONNECTED" "SYSTEM" "PROCESSES" "MAIL")
    :bind (:map prodigy-mode-map (
      <<keybindings-gen(table=prodigy-keybindings)>>
    ))

    :hook
    (kill-emacs . prodigy-force-stop-all-service)

    :config
    ;; Define services
    (when (fboundp 'define-mail-services)
      (define-mail-services))

    (defun prodigy-force-stop-all-service ()
      "Helper to force kill all service"
      (dolist (service prodigy-services)
        (prodigy-stop-service service t))))

  (use-package elcontext
    :straight (elcontext :type git :host github :repo "rollacaster/elcontext"
                         :fork (:host github
                                      :repo "seblemaguer/elcontext"
                                      :branch "fix_missing_hydras_2"))
    :tags '("CONNECTED" "SYSTEM" "PROCESSES" "MAIL")
    :config

    (defun elcontext-start-prodigy (name)
      "Helper to start properly the prodigy service NAME via elcontext."
      (prodigy-start-service
          (prodigy-find-service name)))

    (when (fboundp 'list-mail-services)
      (dolist (name (list-mail-services))
        (setq elcontext--context-id name
              elcontext--context-current (ht (:name name)
                                             (:time (ht))
                                             (:action `(elcontext-start-prodigy ,name))
                                             (:location (ht))
                                             (:directory (expand-file-name "~"))))
        (elcontext-add-context elcontext--context-id elcontext--context-current)))

    ;; Reinit everything
    (setq elcontext--context-id nil
          elcontext--context-current (ht (:name nil)
                                         (:time (ht))
                                         (:action nil)
                                         (:location (ht))))
    (elcontext-global-mode))
#+END_SRC

** DONE Emacs and the servers
CLOSED: [2021-01-05 Tue 13:06]
Finally, I access to computing clusters regularly.
The main tools I am using there are ~docker~ and ~slurm~.
As an entry point, as every Emacs use, I use =tramp= to deal with servers using SSH as a backend.
=slurm-mode= doesn't rely on =tramp= and does not proposes remote access by default.
However, a hack was proposed in [[https://github.com/truls/slurm.el/tree/explicit-username][truls]] fork
I prefere to use my own fork as I would like to expand a bit more the rendering.

#+begin_src emacs-lisp
  (use-package tramp
    :straight (:type built-in)
    :tags '("SYSTEM" "SERVER" "CONNECTED")
    :custom
    (tramp-default-method "ssh")
    (password-cache-expiry 60)
    (tramp-auto-save-directory temporary-file-directory)
    (tramp-verbose 1)

    ;; ;; Debug
    ;; (tramp-verbose 9)
    ;; (tramp-debug-buffer t)

    :init
    ;; (set-default 'tramp-default-proxies-alist (quote ((".*" "\\`root\\'" "/ssh:%h:"))))
    (defun sudo-edit-current-file ()
      "Edit the current file as root"
      (interactive)
      (let ((position (point)))
        (find-alternate-file
         (if (file-remote-p (buffer-file-name))
             (let ((vec (tramp-dissect-file-name (buffer-file-name))))
               (tramp-make-tramp-file-name
                "sudo"
                (tramp-file-name-user vec)
                (tramp-file-name-host vec)
                (tramp-file-name-localname vec)))
           (concat "/sudo::" (buffer-file-name))))
        (goto-char position))))


  (use-package slurm-mode
    :straight (slurm :type git :host github
                     :repo "ffevotte/slurm.el"
                     :fork (:host github
                                  :repo "seblemaguer/slurm.el"
                                  :branch "explicit-username"))
    :tags '("SYSTEM" "SERVER" "CONNECTED"))
#+end_src

** Conveniencies
*** Unit conversion
#+begin_src emacs-lisp :lexical no
(when (executable-find "units")
  (use-package units
    :tags '("HELPERS")
    :hook text-mode
    :config
    (local-set-key (kbd "C-c u") 'units-convert-region-and-insert)))
#+end_src

*** Open Street Map
#+begin_src emacs-lisp :lexical no
  (use-package osm
    :tags '("HELPERS" "DESKTOP")
    :custom
    ;; Take a look at the customization group `osm' for more options.
    (osm-server 'default) ;; Configure the tile server
    (osm-copyright t)     ;; Display the copyright information

    :init
    ;; Load Org link support
    (with-eval-after-load 'org
      (require 'osm-ol)))
#+end_src

* DONE Visual [100%]
For the visual part, I rely mainly on =nano-emacs= developed by Nicolas P. Rougier.
It is a simple layout but incredibly clear and precise.
I deviate from it by prefering my emacs (color) theme (=flatfluc-theme=) and I tweaked a bit the layout (see =nano-layout=).
Concerning the layout, I needed to add a specific font resolution for my surface.
This is done in the ~config~ part of the package loading.
I also need =rainbow-mode= to help visualize the colors when editing the themes.

#+begin_src emacs-lisp
  (use-package rainbow-mode
    :tags '("VISUAL"))

  (use-package flatfluc-theme
    :tags '("VISUAL")
    :init
    ;; Clean some unused information
    (tooltip-mode -1)
    (scroll-bar-mode -1)
    (tool-bar-mode -1)

    ;; Default frame settings
    (setq default-frame-alist
          (append (list
                   '(font . "MesloLGS NF-10") ;; NOTE: the size needs to be spec. else font is too small
                   '(min-height . 1)  '(height . 45)
                   '(min-width  . 1)  '(width  . 81)
                   '(vertical-scroll-bars  . nil)
                   '(internal-border-width . 24)
                   '(left-fringe           . 0)
                   '(right-fringe          . 0)
                   '(tool-bar-lines        . 0)
                   '(menu-bar-lines        . 0))))

    ;; Vertical window divider
    (setq window-divider-default-right-width 5
          window-divider-default-places 'right-only)
    (window-divider-mode 1)

    :config
    (load-theme 'flatfluc t)

    ;; Nicer glyphs for continuation and wrap
    (defface flatfluc-faded `((t :foreground ,fui-soaring-eagle))
      "Faded face inspired by nano-theme. For now defined in the config and not in the theme")
    (set-display-table-slot standard-display-table
                            'truncation (make-glyph-code ?… 'flatfluc-faded))
    (set-display-table-slot standard-display-table
                            'wrap (make-glyph-code ?- 'flatfluc-faded))

    ;; Update alert colors to be flatfluc friendlier
    (setq alert-severity-colors `((urgent   . ,fui-dark-alizarin)
                                  (high     . ,fui-dark-carrot)
                                  (moderate . ,fui-sunflower)
                                  (normal   . ,fui-turquoise)
                                  (low      . "blue")
                                  (trivial  . "purple")))
    )


  (use-package nano-modeline
    :custom
    (nano-modeline-prefix-padding t)
    :config
    ;; ===== Modeline
    (set-face-attribute 'mode-line nil
                        :foreground fui-fg
                        :background fui-deep-clouds
                        ;; :box '(:line-width 1)
                        :box nil
                        :height 100)
    (set-face-attribute 'mode-line-inactive nil
                        :foreground fui-fg
                        :background fui-deep-clouds
                        ;; :box '(:line-width 1)
                        :box nil
                        :height 100)

    (set-face-attribute 'nano-modeline-active-name nil
                        :weight 'bold
                        :box nil)
    (set-face-attribute 'nano-modeline-active-primary nil
                        :weight 'bold
                        :box nil)
    (set-face-attribute 'nano-modeline-active-secondary nil
                        :weight 'bold
                        :box nil)

    (set-face-attribute 'nano-modeline-active-status-RW nil
                        :weight 'bold
                        :foreground fui-dark-asphalt
                        :background fui-emerald
                        :box nil)
    (set-face-attribute 'nano-modeline-active-status-** nil
                        :foreground "white"
                        :background fui-dark-alizarin
                        :weight 'bold
                        :box nil)
    (set-face-attribute 'nano-modeline-active-status-RO nil
                        :foreground "white"
                        :background "#311B92"
                        :weight 'bold
                        :box nil)

    (set-face-attribute 'nano-modeline-inactive-name nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)
    (set-face-attribute 'nano-modeline-inactive-primary nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)
    (set-face-attribute 'nano-modeline-inactive-secondary nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)

    (set-face-attribute 'nano-modeline-inactive-status-RW nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)
    (set-face-attribute 'nano-modeline-inactive-status-** nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)
    (set-face-attribute 'nano-modeline-inactive-status-RO nil
                        :foreground "grey45"
                        :background fui-deep-clouds
                        :box nil)

    (defun my/thin-modeline ()
      "Transform the modeline in a thin faded line"

      (nano-modeline-face-clear 'mode-line)
      (nano-modeline-face-clear 'mode-line-inactive)
      (setq mode-line-format (list ""))
      (setq-default mode-line-format (list ""))
      (set-face-attribute 'mode-line nil
                          :box '(:line-width 1)
                          ;; :foreground (face-background 'nano-subtle)
                          ;; :background "black"
                          :height 0.1)
      (set-face-attribute 'mode-line-inactive nil
                          :box '(:line-width 1)
                          ;; :foreground (face-background 'nano-subtle)
                          ;; :background "black"
                          :height 0.1))

    ;; (add-hook 'nano-modeline-mode-hook #'my/thin-modeline)

    (nano-modeline-mode 1))
#+end_src

** DONE Prism
CLOSED: [2021-01-06 Wed 12:26]
In daemon mode, =prism= is required to be required **after** loading the theme.
Therefore, for now it is here!

#+BEGIN_SRC emacs-lisp
  (use-package prism
    :tags '("CORE" "BUFFER" "VISUAL")
    :config
    (defun load-prism (frame)
      (with-selected-frame frame
        (remove-hook 'after-make-frame-functions 'load-prism)
        (prism-set-colors :num 16
          :desaturations (cl-loop for i from 0 below 16
                                  collect (* i 2.5))
          :lightens (cl-loop for i from 0 below 16
                             collect (* i 2.5))
          :colors (list "#C0392B" "#3498DB" "#16A085")

          :comments-fn
          (lambda (color)
            (prism-blend color
                         (face-attribute 'font-lock-comment-face :foreground) 0.25))

          :strings-fn
          (lambda (color)
            (prism-blend color "white" 0.5)))))

    (if (daemonp)
        (add-hook 'after-make-frame-functions 'load-prism)
      (load-prism (car (frame-list)))))
#+END_SRC

** DONE Font/Glyphs
CLOSED: [2021-01-05 Tue 10:41]
Because, I tend to prefer glyphs to plain text, I tweaked a bit the font to override some glyphs.
This is especially useful for =magit=, =dired=, ...
To do so, I rely mainly on the ~nerdfonts~ collection.

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t
    :config
    (defun set-icon-fonts (CODE-FONT-ALIST)
      "Utility to associate many unicode points with specified fonts."
      (--each CODE-FONT-ALIST
        (-let (((font . codes) it))
          (--each codes
            (set-fontset-font t `(,it . ,it) font)))))

    (defun load-default-fonts ()
      "Helper to load the default fonts when it should be when using the daemon."
      (unless (member "all-the-icons" (font-family-list))
        (all-the-icons-install-fonts t))

      ;; The icons you see are not the correct icons until this is evaluated!
      (set-icon-fonts
       '(("fontawesome"
          ;;                         
          #xf07c #xf0c9 #xf0c4 #xf0cb #xf017 #xf101)

         ("all-the-icons"
          ;;    
          #xe907 #xe928)

         ("github-octicons"
          ;;                        
          #xf091 #xf059 #xf076 #xf075 #xf016 #xf00a)

         ("Symbola"
          ;; 𝕊    ⨂      ∅      ⟻    ⟼     ⊙      𝕋       𝔽
          #x1d54a #x2a02 #x2205 #x27fb #x27fc #x2299 #x1d54b #x1d53d
          ;; 𝔹    𝔇       𝔗
          #x1d539 #x1d507 #x1d517))))

    (defun load-fonts (frame)
      (select-frame frame)
      (load-default-fonts))

    (when (fboundp 'set-fontset-font)
      (if (daemonp)
          (add-hook 'after-make-frame-functions #'load-fonts)
        (load-default-fonts))))
#+end_src

** DONE Helpers [100%]
In order to guide me a little bit more to the information I need,
I introduce a couple of visual helpers.
All of these helpers are configured in this section.

*** DONE Segmenting
CLOSED: [2021-01-05 Tue 10:51]
To segment properly different part of the code, I rely on two key concepts: separators and page breaks
Separators are coming in two ways: unary (like space) and binary (parenthesis style).
For the former, I sometimes activate the builtin =whitespace-mode= but it doesn't require any configuration.
For the latter, I rely on =smartparens= for the editing part and =rainbow-delimiters= to associate a color to each level of parenthesis.
It is to be noted than =smartparens= is much more completing than what I described and I may use some functionalities without knowing it.
Finally, the package =page-break-lines= provides a nice way to visualize a page break (^L) to be easily spotted.

#+begin_src emacs-lisp
  (use-package smartparens-config
    :tags '("VISUAL")
    :straight smartparens
    :hook
    (after-init  . smartparens-global-mode)
    (after-init  . show-smartparens-global-mode)
    (eval-expression-minibuffer-setup . smartparens-mode)

    :init
    (setq sp-show-pair-delay 0.2
          sp-show-pair-from-inside nil
          sp-cancel-autoskip-on-backward-movement nil
          sp-highlight-pair-overlay nil
          sp-highlight-wrap-overlay nil
          sp-highlight-wrap-tag-overlay nil)

    :config
    ;; don't create a pair with single quote in minibuffer
    (sp-local-pair 'minibuffer-inactive-mode "'" nil :actions nil))

  (use-package rainbow-delimiters
    :tags '("VISUAL")
    :hook
    (prog-mode . rainbow-delimiters-mode))

  (use-package page-break-lines
    :tags '("VISUAL")
    :diminish page-break-lines-mode
    :config
    (global-page-break-lines-mode t))
#+end_src

*** DONE Navigating
CLOSED: [2021-01-05 Tue 10:46]
Modifying/Navigating can lead to be slightly confused what has just happened.
I added =googles= to briefly flash to indicate what just changed and =scrollkeeper= to see where I am after a massive scrolling operation.
I also add =xhair= to visualize where I am (line + column) when I need to align things column-wise.

#+NAME: scrollkeeper-remap-keybindings
| Key                         | Function                   | Description |
|-----------------------------+----------------------------+-------------|
| [remap scroll-up-command]   | scrollkeeper-contents-up   |             |
| [remap scroll-down-command] | scrollkeeper-contents-down |             |

#+begin_src emacs-lisp
  (use-package goggles
    :tags '("VISUAL")
    :config
    (goggles-mode)
    (setq-default goggles-pulse t))

  (use-package scrollkeeper
    :straight (scrollkeeper :type git :host github :repo "alphapapa/scrollkeeper.el")
    :tags '("VISUAL")
    :bind (
      <<keybindings-gen(table=scrollkeeper-remap-keybindings)>>
    ))

  (use-package xhair
    :tags '("VISUAL"))
#+end_src

*** DONE Filling
CLOSED: [2021-01-05 Tue 12:36]
To be consistent, I prefer to wrap the line at the ~fill-column~ value.
This is functionality is provided by =visual-fill-column=.

#+BEGIN_SRC emacs-lisp
  (use-package visual-fill-column
    :tags '("VISUAL"))
#+END_SRC

*** DONE Indentation
CLOSED: [2021-03-01 Mon 09:17]
When I am programming, I like seeing clearly at which indentation level I am.
To see this, I am using =highlight-indent-guides=.
Its configuration is pretty standard except I prefer the ~column~ method to the ~fill~ one.

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :tags '("VISUAL")
    :hook
    (prog-mode . highlight-indent-guides-mode)
    :config
    (setq highlight-indent-guides-method 'column))
#+end_src

*** DONE Diff
CLOSED: [2021-01-05 Tue 12:34]
Due to the amount of modifications, I like having indicators which are reminding me what has been changed.
I am using =diff-hl= which provides a diff. status on the (left for me) fringe.
Long lines are also distracting, so I prefer to ellipse them.
To do so, I use =abridge-diff=.

#+begin_src emacs-lisp
  (use-package diff-hl
    :tags '("VISUAL")
    :hook ((after-init . global-diff-hl-mode)
           (dired-mode . diff-hl-dired-mode-unless-remote))

    :init (setq diff-hl-draw-borders t)
    :config

    ;; Highlight on-the-fly
    (diff-hl-flydiff-mode 1)

    ;; Integration with magit
    (with-eval-after-load 'magit
      (add-hook 'magit-post-refresh-hook #'diff-hl-magit-post-refresh)))

  (use-package abridge-diff
    :after magit ;; optional, if you'd like to use with magit
    :tags '("VISUAL")
    :init (abridge-diff-mode 1))
#+end_src

*** DONE Emoji
CLOSED: [2021-01-05 Tue 12:28]
I am chatting, mailing and so on.
I prefer to visualize nicely emojis than the raw text.
To do so, I use the package =emojify= which provides everything needed for this.

#+begin_src emacs-lisp
  (use-package emojify
    :tags '("VISUAL" "DESKTOP")
    :functions (emojify-set-emoji-data)
    :hook (sauron-mode . emojify-mode)
    :config
    (when (featurep 'emojify)
      (emojify-set-emoji-data)))
#+end_src

*** DONE Org-mode
The visual configuration for =org-mode= is based on =org-modern=.
The main tweaks are that some specific colors are defined for some specific keywords and icons are associated to some categories.

CLOSED: [2021-12-10 Fri 14:17]
#+begin_src emacs-lisp
  (use-package org-modern
    :tags '("VISUAL" "ORG")
    :hook
    (org-mode . org-modern-mode)
    (org-agenda-finalize . org-modern-agenda)

    :custom
    (org-modern-table nil)
    (org-modern-tag nil)

    :init

    ;; Org styling, hide markup etc.
    (setq org-hide-emphasis-markers t
          org-pretty-entities t
          org-ellipsis "…")

    ;; Agenda styling
    (setq org-agenda-block-separator ?─
          org-agenda-time-grid '((daily today require-timed)
                                 (800 1000 1200 1400 1600 1800 2000)
                                 " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
          org-agenda-current-time-string
          "⭠ now ─────────────────────────────────────────────────")

    ;; Faces
    (setq org-modern-todo-faces
          '(("TODO"          :background "red1"          :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("IN PROCESS"    :background "lightgray"     :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("MEETING"       :foreground "red1"                              :weight bold)

            ;; Specific helpers
            ("TO-READ"       :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("MAIL"          :background "purple"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; I can't really do anything here!
            ("WAITING"       :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("PAUSED"        :background "orange"        :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("EXEC-STARTED"  :background "light green"   :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("DELEGATED"     :background "gold"          :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; Done but not complete
            ("CANCELLED"     :background "lime green"    :foreground "black" :weight bold :box (:line-width 2 :style released-button))
            ("POSTPONED"     :background "lime green"    :foreground "black" :weight bold :box (:line-width 2 :style released-button))

            ;; Done and I don't care to be complete
            ("EVENT"         :foreground "purple"                            :weight bold)
            ("NOTE"          :foreground "purple"                            :weight bold)
            ("RELEASE"       :foreground "purple"                            :weight bold)
            ("MANDATORY"     :foreground "red"                               :weight bold)

            ;; Done and complete
            ("DONE"          :background "forest green"  :foreground "lightgray" :weight bold :box (:line-width 2 :style released-button))
            )

          org-priority-faces '((?A . (:foreground "red" :weight bold))
                               (?B . (:foreground "orange"  :weight bold))
                               (?C . (:foreground "orange"))
                               (?D . (:foreground "forest green"))
                               (?E . (:foreground "forest green")))

          org-agenda-category-icon-alist `(
                                           ;; Tools / utils
                                           ("[Ee]macs"
                                            ,(format "%s/third_parties/icons/emacs24.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Oo]rg"
                                            ,(format "%s/third_parties/icons/org.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ss]ystem"
                                            ,(format "%s/third_parties/icons/debian.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Tt]ool\\|[Cc]onfiguration\\)s?"
                                            ,(format "%s/third_parties/icons/wrench.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ee]xpe\\(riment\\)s?"
                                            ,(format "%s/third_parties/icons/expes.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Admin / meeting
                                           ("[Aa]dmin"
                                            ,(format "%s/third_parties/icons/admin.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Aa]ppointments?"
                                            ,(format "%s/third_parties/icons/appointment.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Vv]isitors"
                                            ,(format "%s/third_parties/icons/visitors.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Ss]ynsig\\|SSW\\)"
                                            ,(format "%s/third_parties/icons/isca.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Tt]rip\\|[Dd]eplacement\\)"
                                            ,(format "%s/third_parties/icons/trip.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Deadlines / dates
                                           ("\\([Pp]resentations?\\)"
                                            ,(format "%s/third_parties/icons/meeting.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("\\([Pp]apers?\\|[Bb]lio\\|[Aa]rticles?\\|[Rr]eading\\|[Ww]riting\\)"
                                            ,(format "%s/third_parties/icons/book.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Mm]ails?"
                                            ,(format "%s/third_parties/icons/email.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Rr]eviews?"
                                            ,(format "%s/third_parties/icons/review.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("[Ss]upervising"
                                            ,(format "%s/third_parties/icons/visitors.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Personnal dates
                                           ("[rM]edical"
                                            ,(format "%s/third_parties/icons/medical.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Anniv"
                                            ,(format "%s/third_parties/icons/anniversary.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Concert"
                                            ,(format "%s/third_parties/icons/music.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ;; Personnal diverse
                                           ("[Rr]elease"
                                            ,(format "%s/third_parties/icons/cd.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           ("Book"
                                            ,(format "%s/third_parties/icons/book.png" user-emacs-directory)
                                            nil nil :ascent center)

                                           (".*" '(space . (:width (16)))))))

    (use-package org-rainbow-tags
      :tags '("VISUAL" "ORG")
      :straight (:host github :repo "KaratasFurkan/org-rainbow-tags")
      :custom
      (org-rainbow-tags-hash-start-index 10)
      (org-rainbow-tags-extra-face-attributes
       ;; Default is '(:weight 'bold)
       '(:inverse-video t :box t :weight 'bold))
      :hook
      (org-mode . org-rainbow-tags-mode)
      (org-agenda-finalize . org-rainbow-tags-mode))
#+end_src

* Key bindings [100%]
In this section, we define the bindings used globally.
We can consider the following categories:
  - The functional bindings :: which allows the user to access to a functionality from anywhere (e.g. opening the version-control manager)
  - The remapped bindings :: which are homogeneizing or extending existing bindings in multiple modes

An helper to remind these bindings is also provided.

** DONE Functional bindings [100%]
CLOSED: [2021-01-05 Tue 10:03]
This section defines the functional bindings.
Hydra is used as the provider for these bindings.
For now, we consider the following ones: ~main helpers~, ~version control~ and some ~toggling~

*** DONE Main Helper
CLOSED: [2021-01-05 Tue 09:46]
The main helper, mapped to *<f1>* contains the global operations which are interesting to access globally:
 - org-mode capturing and sniffing webpage
 - zooming
 - bookmarking and listing the bookmarks
 - Mail management: listing the synchronization process managed by *prodigy* and creating a new may

#+NAME: org-main-keybindings
| Key | Function                      | Label           | Description |
|-----+-------------------------------+-----------------+-------------|
| c   | org-capture                   | Capture         |             |
| h   | org-web-tools-read-url-as-org | Get URL to org  |             |
| F   | org-gcal-fetch                | Fetch Calendars |             |
| y   | org-gcal-sync                 | Sync. Calendars |             |

#+NAME: help-main-keybindings
| Key | Function          | Label             | Description |
|-----+-------------------+-------------------+-------------|
| f   | describe-function | Describe function |             |
| v   | describe-variable | Describe variable |             |

#+NAME: zoom-main-keybindings
| Key | Function            | Label      | Options     | Description |
|-----+---------------------+------------+-------------+-------------|
| +   | text-scale-increase | Zoom in    | :color pink |             |
| -   | text-scale-decrease | Zoom out   | :color pink |             |
| 0   | text-scale-reset    | Reset zoom |             |             |

#+NAME: bookmark-main-keybindings
| Key | Function         | Label                 | Description |
|-----+------------------+-----------------------+-------------|
| b   | consult-bookmark | List bookmarks        |             |
| B   | bookmark-set     | Bookmark current file |             |

#+NAME: mail-main-keybindings
| Key | Function         | Label        | Description |
|-----+------------------+--------------+-------------|
| m   | mu4e-compose-new | New mail     |             |
| p   | prodigy          | Open prodigy |             |

#+NAME: backup-main-keybindings
| Key | Function             | Label                 | Description |
|-----+----------------------+-----------------------+-------------|
| s   | snapshot-timeline    | List backups          |             |
| S   | snapshot-timemachine | Timemachine on backup |             |

#+begin_src emacs-lisp
  (defun text-scale-reset ()
    "Reset the text scale to its original level (0)."
    (interactive)
    (text-scale-set 0))

  (pretty-hydra-define main-hydra
    (:color teal :hint nil :title "Main")
    ("Org" (
       <<hydra-keybindings-gen(table=org-main-keybindings)>>
     )

     "Help" (
       <<hydra-keybindings-gen(table=help-main-keybindings)>>
     )

     "Zooming"(
       <<hydra-keybindings-gen-with-opt(table=zoom-main-keybindings)>>
     )

     "Bookmark" (
       <<hydra-keybindings-gen(table=bookmark-main-keybindings)>>
     )

     "Mail" (
       <<hydra-keybindings-gen(table=mail-main-keybindings)>>
     )

     "Backup" (
       <<hydra-keybindings-gen(table=backup-main-keybindings)>>
     )
    ))

  (global-set-key (kbd "<f1>") 'main-hydra/body)
#+end_src

*** DONE Project/Version control
CLOSED: [2021-01-05 Tue 09:46]
The following functional binding is the entry point to deal with code project management.
It is mapped to *<f4>*
It deals with:
  - project management using *projectile*
  - version control using *magit*
  - fixme
  - flychecks
  - travis

#+NAME: main-entry-project-keybindings
| Key | Function              | Label         | Description |
|-----+-----------------------+---------------+-------------|
| d   | org-dashboard-display | ORG Dashboard |             |
| p   | projectile-hydra/body | Projectile    |             |

#+NAME: main-entry-vc-keybindings
| Key | Function         | Label | Description |
|-----+------------------+-------+-------------|
| m   | magit-hydra/body | Magit |             |

#+NAME: main-entry-fixme-keybindings
| Key | Function            | Label         | Description |
|-----+---------------------+---------------+-------------|
| f   | fic-view-listing    | Fixme listing |             |
| F   | flycheck-hydra/body | Flycheck      |             |

#+begin_src emacs-lisp
  (pretty-hydra-define project-hydra
    (:color teal :hint nil :title "Project")
    ("Projects" (
       <<hydra-keybindings-gen(table=main-entry-project-keybindings)>>
     )

     "Version Control" (
       <<hydra-keybindings-gen(table=main-entry-vc-keybindings)>>
     )

     "Checking/Notes" (
       <<hydra-keybindings-gen(table=main-entry-fixme-keybindings)>>
     )))

  (global-set-key (kbd "<f4>") 'project-hydra/body)
#+end_src

*** DONE Toggling
CLOSED: [2021-01-05 Tue 10:03]
:PROPERTIES:
:FROM:     https://github.com/jerrypnz/major-mode-hydra.el
:END:
This section configures an access to a bunch of minor modes (or other) which can be toggled.
It is a copy paste of what is proposed in the README file of the [[https://github.com/jerrypnz/major-mode-hydra.el][major-mode-hydra.el repository]].

#+NAME: basic-toggle-keybindings
| Key | Function                  | Label              | Options   | Description |
|-----+---------------------------+--------------------+-----------+-------------|
| n   | display-line-numbers-mode | line number        | :toggle t |             |
| w   | whitespace-mode           | whitespace         | :toggle t |             |
| W   | whitespace-cleanup-mode   | whitespace cleanup | :toggle t |             |
| r   | rainbow-mode              | rainbow            | :toggle t |             |
| L   | page-break-lines-mode     | page break lines   | :toggle t |             |

#+NAME: highlight-toggle-keybindings
| Key | Function            | Label  | Options   | Description |
|-----+---------------------+--------+-----------+-------------|
| s   | symbol-overlay-mode | symbol | :toggle t |             |
| l   | hl-line-mode        | line   | :toggle t |             |
| x   | highlight-sexp-mode | sexp   | :toggle t |             |
| t   | hl-todo-mode        | todo   | :toggle t |             |

#+NAME: coding-toggle-keybindings
| Key | Function                | Label              | Options   | Description |
|-----+-------------------------+--------------------+-----------+-------------|
| p   | smartparens-mode        | smartparens        | :toggle t |             |
| P   | smartparens-strict-mode | smartparens strict | :toggle t |             |
| S   | show-smartparens-mode   | show smartparens   | :toggle t |             |
| f   | flycheck-mode           | flycheck           | :toggle t |             |

#+NAME: debug-toggle-keybindings
| Key | Function              | Label          | Options                                 | Description |
|-----+-----------------------+----------------+-----------------------------------------+-------------|
| D   | toggle-debug-on-error | debug on error | :toggle (default-value 'debug-on-error) |             |
| X   | toggle-debug-on-quit  | debug on quit  | :toggle (default-value 'debug-on-quit)  |             |

#+begin_src emacs-lisp
  ;; (defvar jp-toggles--title (with-faicon "toggle-on" "Toggles" 1 -0.05))
  (defvar jp-toggles--title "Toggles")

  (pretty-hydra-define jp-toggles
    (:color amaranth :quit-key "q" :title jp-toggles--title)
    ("Basic" (
       <<hydra-keybindings-gen-with-opt(table=basic-toggle-keybindings)>>
     )

     "Highlight" (
       <<hydra-keybindings-gen-with-opt(table=highlight-toggle-keybindings)>>
     )

     "Coding" (
       <<hydra-keybindings-gen-with-opt(table=coding-toggle-keybindings)>>
     )

     "Debug" (
       <<hydra-keybindings-gen-with-opt(table=debug-toggle-keybindings)>>
     )))

  (global-set-key (kbd "<f3>") 'jp-toggles/body)
#+end_src

** DONE Remapped bindings [100%]
CLOSED: [2021-01-05 Tue 10:01]
The following bindings are remapped to be homogeneous accross the different modes and OS.
It concerns mainly the bindings to comment/uncomment and some macos related issues.

*** DONE Commenting
CLOSED: [2021-01-05 Tue 09:50]
I prefer to use a _C-c C-c_ to compile and therefore, the bindings to comment a section of the code should be remapped.
I select _C-c C-;_ to comment and _C-c C-:_ to uncomment.
Adding a toggle support for the commenting would be a good idea too

#+NAME: comment-keybindings
| Key     | Function         | Description              |
|---------+------------------+--------------------------|
| C-c C-; | comment-region   | Commenting the region    |
| C-c C-: | uncomment-region | Uncommenting the regiion |

#+begin_src emacs-lisp
  (use-package cc-mode
    :tags '("CORE" "BINDING")
    :bind
    (;; Global
     <<keybindings-gen(table=comment-keybindings)>>

     :map c-mode-base-map
          <<keybindings-gen(table=comment-keybindings)>>
     :map c++-mode-map
          <<keybindings-gen(table=comment-keybindings)>>))
#+end_src

*** DONE Mac key remapping
CLOSED: [2021-01-05 Tue 10:01]
I don't know if it is still needed, but I keep this here for now.

#+begin_src emacs-lisp
  (global-set-key (kbd "C-c =") 'compare-windows)
  (global-set-key (kbd "<end>") 'move-end-of-line)
  (global-set-key (kbd "<home>") 'move-beginning-of-line)
#+end_src

** DONE Reminder for bindings
CLOSED: [2021-01-05 Tue 09:49]
Finally, because of the amount of keys, I sometimes need a reminder of what is what.
To do so, I am using =remind-bindings=.

#+NAME: remind-bindings-keybindings
| Key     | Function                      | Description              |
|---------+-------------------------------+--------------------------|
| <f10>   | remind-bindings-togglebuffer  |                          |
| C-<f10> | remind-bindings-specific-mode |                          |

#+begin_src emacs-lisp
  (use-package remind-bindings
    :tags '("HELPER" "CORE" "BINDING")
    :bind (
       <<keybindings-gen(table=remind-bindings-keybindings)>>
     ))
#+end_src

* Provide
We finish the configuration, let's provide it!

#+begin_src emacs-lisp
  (provide 'init)
#+end_src
